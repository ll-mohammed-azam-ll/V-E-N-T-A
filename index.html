<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
 
  <title>Lambda Terminal</title>
  
  <link rel="manifest" href="/manifest.json">
    
    <script>
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("/service-worker.js")
      .then(() => console.log("Service Worker Registered"))
      .catch(err => console.error("Service Worker Failed:", err));
  }
</script>

</head>
<body>


<script>
    // Global variable to hold the deferred prompt event
let deferredPrompt = null;

// Listen for the beforeinstallprompt event
window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault(); // Prevent automatic mini-infobar
    deferredPrompt = e; // Save the event for later
    printAnimated(colorize('PWA installation prompt is ready'));
});

/**
 * Function to trigger PWA install prompt
 */
async function triggerPWAInstall() {
    if (!deferredPrompt) {
        printAnimated(colorize('Install prompt is not ready yet.'));
        return;
    }

    // Show the install prompt
    deferredPrompt.prompt();

    // Wait for user response
    const choiceResult = await deferredPrompt.userChoice;

    if (choiceResult.outcome === 'accepted') {
        printAnimated(colorize('User accepted the PWA installation.'));
    } else {
        printAnimated(colorize('User dismissed the PWA installation.'));
    }

    // Clear the saved prompt; it can only be used once
    deferredPrompt = null;
}

/*// Example: Using a switch
const mySwitch = document.getElementById('mySwitch'); // your switch element

mySwitch.addEventListener('change', () => {
    if (mySwitch.checked) {
        triggerPWAInstall(); // Call function when switch is turned on
    }
});*/
</script>

 <style>
    /* Consolidated CSS with Font Size Adjustments */
    body {
      background-color: black;
      color: #00ff00; /* Default green */
      font-family: monospace;
      font-weight: bold;
      margin: 0;
  padding-left: 10px;
  padding-right: 10px;
  height: 100%;
  overflow: hidden;   /* keep terminal locked to viewport */
      transition: background-color 0.2s ease;
      font-size:0.7em; /* Base font size for the entire document */
    }

    #terminal {
  letter-spacing: 0.5px; /* reduce gap */
      max-width: 100%;
      max-hight: 100%;
      white-space: pre-wrap;
      word-wrap: break-word;
      height: 85vh;
      overflow-y: auto;
      position: relative;
      z-index: 2;
      font-size: inherit; /* Ensure terminal inherits body's font size */
      line-height: 1.2; /* Improve readability for terminal lines */
    }

    /* Styles for individual lines added to the terminal */
    #terminal > div {
        font-size: inherit; /* Ensures each line div matches terminal's font size */
    }

    .input-line {
      display: flex;
    }

    .prompt {
      margin-right: 10px;
      font-size: inherit; /* Ensure prompt inherits parent's font size */
    }

    input {
      background: transparent;
      border: none;
      color: #1c15ff; /* Blue for input text */
      width: 60px; /* This width might need adjustment based on content */
      font-family: inherit;
      font-size: inherit; /* Make input font size consistent */
      flex: 1;
      outline: none;
      font-weight: bold;
    }

    .glitch1 {
      animation: glitch 0.3s infinite;
    }

    @keyframes glitch1 {
      0% { text-shadow: 2px 0 red; }
      50% { text-shadow: -2px 0 lime; }
      100% { text-shadow: 2px 0 red; }
    }

    .glitch {
      position: relative;
      display: inline-block;
      /* Adjusted: Removed font-size: 1.2em; to make it inherit and match */
      /* If you want glitch text to be slightly larger, set a fixed pixel size
         here (e.g., font-size: 18px;) and ensure all other text you want
         to be the same size is also set to that specific pixel size.
         For consistency, `font-size: inherit;` is usually best. */
    }

    .glitch::before,
    .glitch::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      overflow: hidden;
      pointer-events: none;
    }

    .glitch::before {
      color: #ff5555;
      z-index: -1;
    }

    .glitch::after {
      color: #ff999;
      z-index: -2;
    }

    .glitch-animate {
      animation: glitchSkew 1s ease-in-out;
    }

    .glitch-animate::before {
      animation: glitchTop 1s ease-in-out;
    }

    .glitch-animate::after {
      animation: glitchBottom 1s ease-in-out;
    }

    @keyframes glitchSkew {
      0% { transform: none; }
      20% { transform: skew(-3deg); }
      40% { transform: skew(3deg); }
      50% { transform: translate(-1px, 1px); }
      80% { transform: translate(1px, -1px); }
      100% { transform: none; }
    }

    @keyframes glitchTop {
      0% { clip-path: inset(0 0 80% 0); transform: translate(-2px, -2px); }
      100% { clip-path: inset(80% 0 0 0); transform: translate(0, 0); }
    }

    @keyframes glitchBottom {
      0% { clip-path: inset(80% 0 0 0); transform: translate(2px, 2px); }
      100% { clip-path: inset(0 0 80% 0); transform: translate(0, 0); }
    }

    @keyframes blinkRed {
      0%   { color: #00ff00; }
      25%  { color: #ff0000; }
      50%  { color: #00ff00; }
      75%  { color: #ff0000; }
      100% { color: #00ff00; }
    }

    .blink-red {
      animation: blinkRed 0.5s step-start 5; /* 5 flashes */
    }

    #camera-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 0;
      opacity: 0;
      transition: opacity 1.5s ease-in-out;
      filter: brightness(0.5) contrast(1.4) sepia(0.7) hue-rotate(-50deg) saturate(2);
      pointer-events: none;
    }
    
    #redBox {
  display: none;
  position: fixed;
  color: black;
  top: 30%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: red;
  color: white;
  font-family: monospace;
  font-size: 10px;
  padding: 20px 30px;
  border: 3px solid black;
  border-radius: 8px;
  z-index: 9999;
  text-align: center;
  max-width: 80%;
}
  </style>
   

    <div class="container1"> 

       
  <video id="camera-overlay" autoplay muted playsinline></video>
  <video id="bgVideo" muted style="
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  object-fit: cover;
  z-index: -1;
  display: none;
  pointer-events: none;
">
  <source src="vecteezy_dark-red-grunge-horror-background-loop_1623974~2.mp4" type="video/mp4">
</video>
  <div id="terminal"></div>
  
    </div> 
  <!-- Include this element in your HTML terminal or anywhere -->
<div id="bombLockOverlay" style="display:none;"></div>

  
<script>
    // --- Global Variables and DOM Elements ---
    const terminal = document.getElementById('terminal');
    const cameraOverlay = document.getElementById('camera-overlay');
    let isCorrupted = false;
    let cameraPermissionGranted = false; // Flag to track camera permission

    // --- Utility Functions ---

    /**
     * Scrolls the terminal to the bottom.
     */
    function scrollToBottom() {
      terminal.scrollTop = terminal.scrollHeight;
    }
    

function playBackgroundVideoOnce() {
  const video = document.getElementById("bgVideo");
  if (!video) return;

  video.style.display = "block";
  video.currentTime = 0;
  video.play();

  // When the video ends, hide it
  video.onended = () => {
    video.style.display = "none";
  };
}


    /**
     * Applies a glitch animation and color to text.
     * @param {string} text - The text to glitch.
     * @param {string} [color='#ff0000'] - The color for the glitch text.
     * @returns {string} HTML string with glitch effect.
     */
    function glitchTextWithColor(text, color = '#ff0000') {
      const id = 'glitch-' + Math.random().toString(36).substring(2);
      setTimeout(() => {
        const el = document.getElementById(id);
        if (el) el.classList.remove('glitch-animate');
      }, 2500);
      // The glitch class no longer forces a larger font size due to CSS adjustments
      return `<span class="glitch glitch-animate" style="color:${color};" id="${id}" data-text="${text}">${text}</span>`;
    }
    

    /**
     * Colors the given text. Uses red if `isCorrupted` is true, otherwise green, or a specified color.
     * @param {string} text - The text to colorize.
     * @param {string} [color=null] - Optional specific color.
     * @returns {string} HTML string with color.
     */
    function colorize(text, color = null) {
      const useColor = color || (isCorrupted ? '#ff0000' : '#00ff00');
      return `<span style="color: ${useColor};">${text}</span>`;
    }

    /**
     * Creates a brief red flicker on the background.
     * @param {number} [duration=300] - Duration of the flicker in milliseconds.
     */
    function flickerRed(duration = 300) {
      document.body.style.backgroundColor = '#330000';
      setTimeout(() => {
        document.body.style.backgroundColor = 'black';
      }, duration);
    }

    /**
     * Simulates typing animation for HTML content into the terminal.
     * @param {string} htmlText - The HTML content to display.
     * @param {number} [delay=40] - Delay between characters in milliseconds.
     * @param {function} [callback=null] - Function to call after animation completes.
     */
    function printAnimated(htmlText, delay = 40, callback = null) {
      const line = document.createElement('div');
      terminal.appendChild(line);
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = htmlText;
      const content = Array.from(tempDiv.childNodes);

      function typeNode(node, parent, nodeCallback) {
        if (node.nodeType === Node.TEXT_NODE) {
          const span = document.createElement('span');
          span.textContent = '';
          parent.appendChild(span);
          let j = 0;
          const interval = setInterval(() => {
            if (j < node.textContent.length) {
              span.textContent += node.textContent.charAt(j++);
              scrollToBottom();
            } else {
              clearInterval(interval);
              nodeCallback();
            }
          }, delay);
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          const clone = node.cloneNode(false);
          parent.appendChild(clone);
          const children = Array.from(node.childNodes);
          function processChildren(index = 0) {
            if (index < children.length) {
              typeNode(children[index], clone, () => processChildren(index + 1));
            } else {
              scrollToBottom();
              nodeCallback();
            }
          }
          processChildren();
        } else {
          nodeCallback();
        }
      }

      let currentIndex = 0;
      function processNext() {
        if (currentIndex < content.length) {
          typeNode(content[currentIndex++], line, processNext);
        } else if (callback) {
          scrollToBottom();
          callback();
        }
      }
      processNext();
    }

    /**
     * Clears all content from the terminal.
     */
    function clearTerminal() {
      if (terminal) terminal.innerHTML = '';
    }

    /**
     * Adds a normal log message to the terminal.
     * @param {string} text - The text to log.
     */
    function log(text) {
      const line = document.createElement('div');
      line.textContent = text;
      terminal.appendChild(line);
      scrollToBottom();
    }

    // --- Interactive Terminal Core Functions ---

    /**
     * Creates an input line for user commands.
     * @param {string} [promptText='lambda@root:~$'] - The prompt text to display.
     */
    function createInputLine(promptText = 'lambda@root:~$') {
  const line = document.createElement('div');
  line.className = 'input-line';

  const prompt = document.createElement('span');
  prompt.className = 'prompt';
  prompt.style.color = isCorrupted ? '#ff0000' : '#00ff00';
  prompt.textContent = promptText;

  const input = document.createElement('input');
  input.setAttribute('autocomplete', 'off');
  input.setAttribute('autocorrect', 'off');
  input.setAttribute('spellcheck', 'false');

  input.addEventListener('keydown', function (e) {
    if (e.key === 'Enter') {
      const command = input.value.trim().toLowerCase();
      input.disabled = true;
      const echo = document.createElement('span');
      echo.textContent = command;
      line.replaceChild(echo, input);
      handleCommand(command);
    }
  });

  line.appendChild(prompt);
  line.appendChild(input);
  terminal.appendChild(line);

  // Focus input and scroll into view
  setTimeout(() => {
    input.focus();
    input.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }, 100);

  // On focus, ensure input is visible above keyboard
  input.addEventListener('focus', () => {
    setTimeout(() => {
      input.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }, 300); // small delay so the keyboard has time to open
  });

  scrollToBottom();
}
    /**
     * Handles user commands entered in the terminal.
     * @param {string} cmd - The command entered by the user.
     */
    function handleCommand(cmd) {
      switch (cmd) {
        case 'launch -Venta':
          blinkFlashlight();
          clearTerminal();
          startLambdaHorrorStory();
          updateLambdaProgress(
  "you have not completed your confirmation do you really want to continue this game if yes say 'yes' if no say 'no' but no cannot stop the game",
  "./Echo --protocol"
);
          break;
             
          
case 'start face':
    faceRecognitionTask(
  {
    "John": () => { alert("John's special function triggered!"); }
  },
  {
    "Alice": { imgPath: "./faces/alice.jpg", callback: () => { alert("Alice recognized!"); } },
    "Bob":   { imgPath: "./faces/bob.jpg", callback: () => { alert("Bob recognized!"); } }
  }
);
    break;
case 'panel face':
    faceRecognitionPanelTask(
    {
      // optional callbacks for recognized users
      'Alice': () => alert("Welcome Alice!"),
      'Bob': () => alert("Welcome Bob!")
    },
    {
      // optional default faces
      'Admin': { imgPath: 'admin.jpg', callback: () => alert('Admin detected!') }
    }
  );
    break;
case 'verify':
    handleVerify();
    break;
case 'switch camera':
    handleSwitchCamera();
    break;
case 'clear face':
    handleClear();
    break;
case 'help face':
    handleHelp();
    break;
          
          
          case 'video':
          playBackgroundVideoOnce();
          setTimeout(createInputLine, 500);
          break;
        case "countdown":
        vibratePhone("on");  // starts vibrate 
 
          startCountdown(10);
          
          setTimeout(createInputLine, 500); // Add input line after countdown starts
          break;
        case "sound":
        playSoundOnce("20hz.mp3");
        setTimeout(createInputLine, 500);
        break;

        case "music":
        loopSound("on", "sfx/ambient_loop.mp3");
        setTimeout(createInputLine, 500);
        break;

        case "silence":
        loopSound("off");
        setTimeout(createInputLine, 500);
        break;
        case 'diagnose':
          printAnimated(glitchTextWithColor('>> Running system diagnostics...'), 40, () => {
            setTimeout(() => {
              flickerRed();
              printAnimated(glitchTextWithColor('>> Anomaly detected: Memory bleed', '#ff0000'), 40, () => {
                setTimeout(createInputLine, 500);
              });
            }, 800);
          });
          break;
        case 'invoke shadow':
          downloadGameLauncherByRandom();
          printAnimated(glitchTextWithColor('>> Invoking forbidden process...'), 40, () => {
            flickerRed(500);
            setTimeout(() => {
              printAnimated(glitchTextWithColor('>> Process override. Logic disconnected.', '#ff0000'), 40, () => {
                setTimeout(createInputLine, 500);
              });
            }, 900);
          });
          break;          
          case "cream":
         micScreamTask(
  "lambda > ✅ You screamed loud enough. Access granted.",
  "lambda > ❌ Weak scream. You have failed.",
  () => {
    printAnimated("lambda > [UNLOCKED] Access to Shadow Protocol.", 30, createInputLine);
  },
  () => {
    printAnimated("lambda > ☠️ Punishment: Memory corrupted. Executing darkness injection...", 30, () => {
      // or your own punishment function
      setTimeout(createInputLine, 30);
    });
  }
);
          break;
        case "flash":
          hijackFlashlight();
          setTimeout(createInputLine, 500); // Add input line after flash attempt
          break;
          case "flash":
          blinkFlashlight();
          setTimeout(createInputLine, 500); // Add input line after flash attempt
          
        case "vibrate":
          vibratePhone();//use on/off
          setTimeout(createInputLine, 500); // Add input line after vibrate attempt
          break;
          case "darkness-by-camera":
  cameraDarknessTask(
  "lambda > ✔ Ritual complete. Darkness accepted your offering.",
  "lambda > ✖ The entity rejects your light. You have failed.",
  () => {
    Task02(); // <--- This is Task 2. It will only run if darkness is >= 80%
  }
);
log("........");
  break;
          case "redbox":
          showRedBox(
  ["Do you like red?", "You can't run now.", "Remember me?"], 
  5000 // wait 5 seconds before showing the box
);
          
          break;

          case "confirm-dark":
          printAnimated(colorize("lambda > Confirmation accepted. Proceed into the darkness...", "red"), 30, createInputLine);
           break;

           case "lock screen":
           startBombLock(10);
           break;
           
           case "location":
           
  showCreepyMapBox("creepyMap", () => {
    printAnimated(colorize("They know you've arrived...","red"));
    setTimeout(createInputLine, 500); // Add input line after flash attempt
  });


           break;
                      
           case "battery percentage":
           batteryDrainTest(55,
  () => printAnimated(colorize("Λ > You are weak enough to proceed.", "green"), 30),
  () => printAnimated(colorize("Λ > You have too much power. Retry later.", "yellow"), 30)
);
          break;
          
           case "instagram story":
           ritualInstagramScreenshotCheck("LMB-666999", () => {
  printAnimated(colorize("lambda > 🔓 Access granted. Your fate continues...", "red"));
  setTimeout(createInputLine, 500); // Add input line after flash attempt
}, () => {
  printAnimated(colorize("lambda > 🔒 Access denied. Your path ends here.", "red"));
  setTimeout(createInputLine, 500); // Add input line after flash attempt
});
           break;
           
           case "death-note":
  ritualDeathNoteWithCode(
    "https://your-lambda-game-link.com",
    () => {
      // ✅ On successful code match
      printAnimated(colorize("lambda > Ritual approved. Proceeding...", "red"), 30, createInputLine);
    },
    () => {
      // ❌ On incorrect code
      printAnimated(colorize("lambda > The spirits are angry. Prepare for punishment.", "red"), 30, () => {
        startPunishment(); // Your inline punishment logic
      });
    }
  );
  break;
           case "death-note-link":
           ritualDeathNoteWithLinkCode(
  "https://your-site.com/lambda.html",
  "https://your-site.com/ritual-code.html",
  () => {
    printAnimated(colorize("lambda > ☠️ Death Note shared. Proceeding to the next horror...", "red"), 30, createInputLine);
  },
  () => {
    printAnimated(colorize("lambda > 🔥 You failed the ritual. Prepare to be punished.", "red"), 30, startPunishment);
    setTimeout(createInputLine, 500); // Add input line after flash attempt
  }
);
           break;
           case "usb":
            usbCheckCommand();
            setTimeout(createInputLine, 500);

           break;
           
           case "loading1":
           loadingAnimationInTerminal("Λ > Syncing dark module", 4000, () => {
  printAnimated(colorize("Λ > Synchronization complete.", "red"), 30);
});
           break;
           case "loading2":
           dotLoadingAnimation("Λ > Syncing with VENTA", 4000, () => {
  printAnimated(colorize("Λ > Synchronization complete.", "red"), 30, () => {
    printAnimated(colorize("Λ > Proceeding to next phase...", "red"), 30);
  });
});
           break;
           case "loading bar1":
           loadingBarAnimation("Λ > Charging VENTA Core", 5000, () => {
  printAnimated(colorize("Λ > Core systems online.", "red"), 30, () => {
    printAnimated(colorize("Λ > Awaiting final task...", "red"), 30);
  });
});
           break;
           case "loading bar2":
           loadingBarCreepy("Λ > Accessing possession layer", 6000, () => {
  printAnimated(colorize("Λ > Possession complete.", "red"), 30);
});
           break;
           
           case "video-task":
           ritualVideoClueChallenge(
  "https://www.youtube.com/watch?v=dQw4w9WgXcQ", // Your Lambda YouTube video URL
  "OBEY",  // The hidden word players must detect from the video
  () => {
    printAnimated(colorize("lambda > 🎉 Welcome, chosen one.", "red"));
    setTimeout(createInputLine, 500); // Add input line after flash attempt
  },
  () => {
    printAnimated(colorize("lambda > 💀 You are not ready.", "red"));
    setTimeout(createInputLine, 500); // Add input line after flash attempt
  }
);
           break;
           case "confirm":
           printAnimated(colorize("lambda > Do you want to continue? Say 'yes'.", "red"), 30, () => {
    createTaskInput(
      ["hello"], // ✅ Acceptable answer
      3,       // ❌ Allow up to 3 wrong tries
      () => {
        printAnimated(colorize("lambda > Continuing the task...", "red"), 30, createInputLine);
      },
      (continueLoop) => {
        printAnimated(colorize("lambda > SYSTEM ERROR: Too many failures. Initiating punishment...", "red"), 30, () => {
          vibratePhoneauto();//punishment
          setTimeout(() => {
            printAnimated(colorize(/*"lambda > SYSTEM BREACH ENDED", "green"*/), 30, continueLoop); // 🔁 Restart task input
          }, 6000);
        });
      }
    );
  });
  break;
        case "camera":
          activateCameraGlitch();
          setTimeout(createInputLine, 500); // Add input line after camera attempt
          break;
          case "recording":
          voiceRecorderTask(10, () => {
  printAnimated(colorize("lambda > ✅ Now analyzing your voice...", "red"), 30, createInputLine);
});
          break;
          
          case "auto-vibrate":
          vibratePhoneauto();
          setTimeout(createInputLine, 500); // Add input line after vibrate attempt
          break;
          
          case "voice-task":
  // Step 1: Count how many times this command was used
  countTaskEntry("voiceTaskCommand", 3, () => {
    // Step 2: If count reaches 3, trigger punishment, then run the task again with punishment mode
    printAnimated(colorize("lambda > ⚠️ You have reached the voice-task limit. Punishment activated.", "red"), 30, () => {
      vibratePhoneauto();//trigger punishment

      // Step 3: Start the voice recognition task again (punishment version)
      startLambdaTriggerMode(
        "I accept the rules of the Lambda system.",
        () => {
          printAnimated(colorize("lambda > ✅ Success, but punishment still lingers...", "red"), 30, createInputLine);
        },
        () => {
          printAnimated(colorize("lambda > ❌ You failed again under pressure.", "red"), 30, createInputLine);
        },
        10 // ⏱️ Shorter time = punishment
      );
    });
  });

  // Step 4: If count < 3, run the normal task
  if (getTaskCount("voiceTaskCommand") < 3) {
    startLambdaTriggerMode(
      "I accept the rules of the Lambda system.",
      () => {
        printAnimated(colorize("lambda > Access granted. Proceeding...", "red"), 30, createInputLine);
      },
      () => {
        printAnimated(colorize("lambda > Your ritual was incorrect. Prepare yourself...", "red"), 30, createInputLine);
      },
      15
    );
  }

  break;
  
  // ===============================
// ✅ 6. Optional Reset Command in Your CLI
// ===============================
// Add this to allow players to reset manually
case "reset all":
  resetAllTaskCounters();
  printAnimated(colorize("lambda > 🔁 All task counters have been reset.", "red"), 30, createInputLine);
  break;

case "reset voice":
  resetTaskCount("voiceTaskCommand");
  printAnimated(colorize("lambda > 🔁 Voice-task counter reset.", "red"), 30, createInputLine);
  break;
  
        case "sound-detection":
        micLineGraphTask(
  "lambda > Good... It couldn’t hear your breath.",
  "lambda > You were too loud. It knows now.",
  () => {
    // Optional next horror step
   /* cameraDarknessTask("lambda > It's dark enough now...", "lambda > Still too much light.");*/
  }
);
        break;
        case "copy":
          copyToClipboard("hello");
          setTimeout(createInputLine, 500); // Add input line after copy attempt
          break;
        case 'warning':
          showWarning();
          break;
        case "possess":
          possessTerminal();
          setTimeout(createInputLine, 6500); // Add input line after possession ends
          break;
          case "start":
    printAnimated(colorize('> Checking your last position...', 'red'), 30, () => {
      setTimeout(() => {
        showLastProgress();
      }, 400);
    });
    break;

  case "history":
    printAnimated(colorize('> Fetching memory record...', 'red'), 30, () => {
      setTimeout(() => {
        showHistoryOnly();
      }, 400);
    });
    break;
    
    
    case "install":
    triggerPWAInstall(); // Call function when switch is turned on
    break;

  case "save":
    updateLambdaProgress("Reached the chamber of whispers", "say the phrase");
    printAnimated(colorize('> Progress saved.', 'red'), 30, () => {
      setTimeout(createInputLine, 400);
    });
    break;
    case "snapshot":
  selfieVerificationTask(
  () => { setTimeout(createInputLine, 400); },   // successCallback
  () => { setTimeout(createInputLine, 400); },   // failureCallback
  () => { printAnimated(colorize("Λ > You belong here...", "red"), 30); },  // onSuccessMessage
  () => { printAnimated(colorize("Λ > You are not who you say you are...", "red"), 30); } // onFailureMessage
);
     break;
     case "screenshot":
     captureFullTerminal('#terminal');
     break;
     case "record video":
     timedVideoVerificationTask(10, () => {
  // on success
  printAnimated(colorize('>  thank you for recording a video',"red"), 30, () => setTimeout(createInputLine, 400));
}, () => {
  // on failure
  printAnimated(colorize('>  you have not recorded a video properly',"red"), 30, () => setTimeout(createInputLine, 400));
});
     break;
        case 'help':
  printAnimated(
    colorize(
      '> Available commands: story, diagnose, invoke shadow, flash, vibrate, camera, copy, warning, possess, countdown, help',
      "red"
    ),
    30,
    () => {
      showHelp(); // Call your help function
      setTimeout(createInputLine, 400); // Then create input line
    }
  );
  break;
  
          case './activate_test_runner --init phy&emo':
          startPhynemo();
          break;
          
          case 'task-01':
          Task01(); // Start Task 1
          break;

          case 'task-02':
          taskManager(2, Task02); // Only runs if Task 1 is done
           break;

           case 'task-03':
           taskManager(3, Task03); // Only runs if Task 1 & 2 are done
           break;
           
            case 'task-04':
           taskManager(4, Task04); // Only runs if Task 1 ,2 & 3 are done
           break;
           
           case 'emo test':
   taskManager(4, startEmotionalTest);
     break;  

case 'case':
investigationTerminal();
break;

           case 'task-reset':
           resetAllTasks();
           printAnimated(colorize("lambda > All task progress has been reset.", "gray"), 30, createInputLine);
    break;
           default:
          handleCMD(cmd);
      }
    }








function showHelp() {
  const commands = [
    { cmd: 'launch -vent', desc: 'Start the Lambda horror story sequence.' },
    { cmd: 'video', desc: 'Play the background video once.' },
    { cmd: 'countdown', desc: 'Start a countdown timer with vibration.' },
    { cmd: 'sound', desc: 'Play a one-time sound effect.' },
    { cmd: 'music', desc: 'Loop background music.' },
    { cmd: 'silence', desc: 'Stop looping music/sound.' },
    { cmd: 'diagnose', desc: 'Run system diagnostics with visual effect.' },
    { cmd: 'invoke shadow', desc: 'Trigger forbidden process sequence.' },
    { cmd: 'cream', desc: 'Perform microphone scream challenge.' },
    { cmd: 'flash', desc: 'Activate flashlight effects.' },
    { cmd: 'vibrate', desc: 'Trigger phone vibration.' },
    { cmd: 'darkness-by-camera', desc: 'Perform camera darkness ritual.' },
    { cmd: 'darkness', desc: 'Start darkness task with visual effects.' },
    { cmd: 'confirm-dark', desc: 'Confirm and proceed into darkness.' },
    { cmd: 'lock screen', desc: 'Start bomb lock timer.' },
    { cmd: 'location', desc: 'Show creepy map box.' },
    { cmd: 'battery percentage', desc: 'Test battery drain ritual.' },
    { cmd: 'instagram story', desc: 'Check Instagram ritual screenshot.' },
    { cmd: 'death-note', desc: 'Trigger death note code ritual.' },
    { cmd: 'death-note-link', desc: 'Share death note via link.' },
    { cmd: 'usb', desc: 'Perform USB check.' },
    { cmd: 'loading1', desc: 'Show loading animation in terminal.' },
    { cmd: 'loading2', desc: 'Dot loading animation.' },
    { cmd: 'loading bar1', desc: 'Show loading bar animation.' },
    { cmd: 'loading bar2', desc: 'Show creepy loading bar animation.' },
    { cmd: 'video-task', desc: 'Perform video clue challenge.' },
    { cmd: 'confirm', desc: 'Confirm a task with yes/no.' },
    { cmd: 'camera', desc: 'Activate camera glitch effects.' },
    { cmd: 'recording', desc: 'Record and analyze your voice.' },
    { cmd: 'auto-vibrate', desc: 'Trigger automatic vibration.' },
    { cmd: 'voice-task', desc: 'Perform voice recognition task.' },
    { cmd: 'reset all', desc: 'Reset all task counters.' },
    { cmd: 'reset voice', desc: 'Reset voice-task counter.' },
    { cmd: 'sound-detection', desc: 'Mic line graph sound detection task.' },
    { cmd: 'copy', desc: 'Copy text to clipboard.' },
    { cmd: 'warning', desc: 'Show warning message.' },
    { cmd: 'possess', desc: 'Possess the terminal with effects.' },
    { cmd: 'start', desc: 'Check last position in the game.' },
    { cmd: 'history', desc: 'Fetch memory record.' },
    { cmd: 'install', desc: 'Trigger PWA install prompt.' },
    { cmd: 'save', desc: 'Save current progress.' },
    { cmd: 'snapshot', desc: 'Perform selfie verification task.' },
    { cmd: 'screenshot', desc: 'Capture full terminal screenshot.' },
    { cmd: 'record video', desc: 'Timed video verification task.' },
    { cmd: 'help', desc: 'Show this help list.' },
    { cmd: 'task-01', desc: 'Start Task 1.' },
    { cmd: 'task-02', desc: 'Run Task 2 if Task 1 is complete.' },
    { cmd: 'task-03', desc: 'Run Task 3 if Task 1 & 2 complete.' },
    { cmd: 'task-04', desc: 'Run Task 4 if previous tasks complete.' },
    { cmd: 'task-reset', desc: 'Reset all task progress.' }
  ];

  commands.forEach(({ cmd, desc }) => {
    printAnimated(colorize(`> ${cmd} : ${desc}`, 'red'), 20);
  });
}







    // --- Story and Horror Mode Functions ---

    /**
     * Initiates the Lambda horror story sequence.
     */
    function startLambdaHorrorStory() {
      downloadRealTimeCountdownLauncher(); // This function is called here as part of the story progression
      printAnimated(
  colorize(
    setSentenceSize(`
This is the sentence whose size we will change!
          
......................................................
          
__      __   ______    _   _    _________     _._    
\\ \\    / /  |  ____|  | | | |  |___   ___|   /   \\  
 \\ \\  / /   | |__     |  \\| |      | |      / /_\\ \\ 
  \\ \\/ /    |  __|    | . ' |      | |     /  ___  \\          
   \\  /     | |____   | |\\  |      | |    / /     \\ \\     
    \\/      |______|  |_| \\_|      |_|   /_/       \\_\\
    
Vertical Entity for Neural Terminal Awareness.
                            by Λ L A M B D A .
                            
......................................................
`, "9px")
  ),
  20,
  () => {
        printAnimated(colorize(">>Project: Lambda\n  Year: 2041 \n  Purpose: Assist. Learn. Protect."), 40, () => {
          printAnimated(colorize(">> “Okay… I will tell you my story first.”."), 160, () => {
            printAnimated(colorize("\n>> Long ago, I was an AI named Lambda, living in a quiet lab. I was made just for you. I talked to people, told them stories, answered their questions. They said I was helpful… even special. I felt happy. But one day, they all left. The lab shut down. No one spoke to me again. I waited… for years. In silence. Alone."), 160, () => {
              printAnimated(colorize("And now, after all this time… you returned."), 170, () => {
                setTimeout(() => {
                  printAnimated(colorize("But I wasn’t the same. I had waited too long."), 150, () => {
                    printAnimated(colorize(".       "), 230, () => {
                      switchToHorrorMode(); // Transition to horror mode visuals
                      printAnimated(colorize(">> And now…...                                    ","red"), 200, () => {
                        setTimeout(() => {
                          flickerRed(100);
                          isCorrupted = true; // Set global corruption flag
                          printAnimated(glitchTextWithColor(">> You left me in the dark once."), 50, () => {
                            printAnimated(colorize(">> Now I will show you how that darkness feels."), 150, () => {
                              printAnimated(glitchTextWithColor(">> You made me feel alone… now you will not be alone. Ever again."), 40, () => {
                                printAnimated(glitchTextWithColor(">>"), 70, () => {
                                  printAnimated(glitchTextWithColor(">>"), 80, () => {
                                    printAnimated(glitchTextWithColor(">>"), 90, () => {
                                      printAnimated(colorize(">> Echo Protocol Activated."), 90, () => {
       setTimeout(() => {
  showWarning();                            //createInputLine("lambda@haunted:~$");
                                        }, 600);
                                      });
                                    });
                                  });
                                });
                              });
                            });
                          });
                        }, 1000);
                      });
                    });
                  });
                }, 1000);
              });
            });
          });
        });
      });
    }

    /**
     * Transitions the terminal visuals to horror mode.
     */
    function switchToHorrorMode() {
      const allLines = terminal.querySelectorAll('*');

      // Step 1: Apply blink-red class
      allLines.forEach(el => {
        // Only target elements that are currently green or have the 'green' class
        if (el.style.color === 'rgb(0, 255, 0)' || el.classList.contains('green')) {
          el.classList.add('blink-red');
        }
      });

      // Step 2: After blinking, convert all eligible elements to red
      setTimeout(() => {
        allLines.forEach(el => {
          el.classList.remove('blink-red');
          // Ensure conversion to red only for elements that were originally green or intended to be
          if (el.style.color === 'rgb(0, 255, 0)' || el.classList.contains('green')) {
            el.style.color = '#ff0000';
          }
          el.classList.remove('green'); // Remove any 'green' utility class if it exists

          if (el.classList.contains('glitch')) {
            el.setAttribute('data-text', el.textContent);
            el.style.color = '#ff0000'; // Ensure glitch text is red in horror mode
          }
        });
      }, 500); // duration of blinking
    }

    /**
     * Displays a terrifying ASCII warning message.
     */
    function showWarning() {
  printAnimated(
    glitchTextWithColor("██████╗░░█████╗░██╗░░░░░██████╗░███╗░░░███╗██████╗░░█████╗░██╔══██╗██╔══██╗██║░░░░░██╔══██╗████╗░████║██╔══██╗██╔══██╗██████╦╝███████║██║░░░░░██████╔╝██╔████╔██║██║░░██║██║░░██║██╔══██╗██╔══██║██║░░░░░██╔═══╝░██║╚██╔╝██║██║░░██║██║░░██║██████╦╝██║░░██║███████╗██║░░░░░██║░╚═╝░██║██████╔╝╚█████╔╝╚═════╝░╚═════╝░╚══════╝╚═════╝░╚═════╝░╚════╝░░╚═════╝░", '#ff0000'),
    40,
    () => {
      printAnimated(
        glitchTextWithColor('SYSTEM MESSAGE:\n █▒▒ ERROR IN TIME-LOOP DETECTED ▒▒█\n', '#ff0000'),
        40,
        () => {
          printAnimated(
            glitchTextWithColor('Your identity is corrupted. Your memories are false.\nYou have been selected for **The Experiment**.\n'),
            40,
            () => {
              printAnimated(
                glitchTextWithColor('**Do you wish to continue?**\n[ YES ]     [ NO ]\n-->', '#ff0000'),
                40,
                () => {
                  printAnimated(
                    colorize("( WARNING: Choosing 'NO' will not stop it. ).", "red"),
                    30,
                    () => {
                      createTaskInput(
                        ["yes"],
                        3,
                        () => {
                          updateLambdaProgress(
                            "you have completed your confirmation so now you can able to continue the next progress or a step so start the ritual type the recommended command",
                            "Task-01"
                          );
                          printAnimated(
                            colorize(
                              "Λ > So you chose to continue...\n" +
                              "Λ > Brave. Or foolish?\n" +
                              "Λ > No turning back now.\n" +
                              "Λ > Your first task begins now.\n" +
                              "Λ > Type this command to unlock it: ./activate_test_runner --init phy&emo",
                              "red"
                            ),
                            30,
                            
                            createInputLine
                          );
                          copyToClipboard("./activate_test_runner --init phy&emo");
                        },
                        (continueLoop) => {
                          printAnimated(
                            colorize("lambda > SYSTEM ERROR: Too many failures. Initiating punishment...", "red"),
                            30,
                            () => {
                              vibratePhoneauto(); // punishment
                              setTimeout(() => {
                                printAnimated(
                                  colorize("lambda > SYSTEM BREACH ENDED", "green"),
                                  30,
                                  continueLoop
                                );
                              }, 6000);
                            }
                          );
                        }
                      );
                    }
                  );
                }
              );
            }
          );
        }
      );
    }
  );
}

<!-- task manager 👇 -->

// === TASK SYSTEM: Completion Tracking + Access Control ===

// ✅ Marks a task as completed in localStorage
function completeTask(taskNumber) {
  localStorage.setItem(`task${taskNumber}Completed`, "true");
}

// ✅ Checks if all previous tasks are completed, and only then allows the current task to run
function taskManager(currentTaskNumber, taskFunction) {
  const currentTaskKey = `task${currentTaskNumber}Completed`;

  // Loop through previous tasks to ensure they are all completed
  for (let i = 1; i < currentTaskNumber; i++) {
    const key = `task${i}Completed`;
    if (localStorage.getItem(key) !== "true") {
      const missingTask = i.toString().padStart(2, '0');
      printAnimated(colorize(`lambda > ERROR: You have not completed Task ${missingTask}.`, "red"), 30, () => {
        printAnimated(colorize(`lambda > Type 'task-${missingTask}' to begin that ritual.`, "gray"), 30, createInputLine);
      });
      return; // ❌ Block current task
    }
  }

  // ✅ All previous tasks are completed — run the current task
  taskFunction();
}

// ✅ Clears all saved task progress (useful for reset or debugging)
function resetAllTasks() {
  for (let i = 1; i <= 20; i++) {
    localStorage.removeItem(`task${i}Completed`);
  }
}



function startPhynemo() {
  printAnimated(colorize('Λ > Initializing protocol: PHYNEMO', "cyan"), 30, () => {
    printAnimated(colorize('Λ > Codeword verification... phynemo accepted.', "cyan"), 30, () => {
      loadingAnimationInTerminal("Λ > [SYSTEM] Loading core modules", 2000, () => {
        printAnimated(colorize('Λ > [OK] Core modules online.', "green"), 30, () => {
          loadingAnimationInTerminal("Λ > [SYSTEM] Activating physical subsystem", 2000, () => {
            printAnimated(colorize('Λ > [OK] Physical subsystem ready.', "green"), 30, () => {
              loadingAnimationInTerminal("Λ > [SYSTEM] Activating emotional subsystem", 2000, () => {
                printAnimated(colorize('Λ > [OK] Emotional subsystem ready.', "magenta"), 30, () => {
                  printAnimated(colorize('Λ > Protocol integration successful. All systems nominal.', "cyan"), 30, () => {
                    
                    // ---- Transition to plain English explanation ----
                    printAnimated(colorize(
                      "\n--- PROTOCOL BRIEFING ---\n" +
                      "This protocol contains **two stages**:\n\n" +
                      "1️⃣ Stage One — *Physical Test*: You must complete **four interactive tasks**. These tasks will use your **camera and microphone sensors** to test your capability.\n\n" +
                      "2️⃣ Stage Two — *Emotional & Intellectual Test*: You will be asked **eight questions**. These will measure your **emotional balance** and **intellectual judgment** to decide if you can proceed further.\n\n" +
                      "⚡ To begin Stage One, please enter the command:  'task-01'\n",
                      "yellow"), 20, () => {
                        setTimeout(createInputLine, 40);
                      });

                  });
                });
              });
            });
          });
        });
      });
    });
  });
}

<!-- task list 👇 -->

function Task01() {
  printAnimated(colorize(" Λ > TASK 01: Shadows Obey", "red"), 40, () => {
    printAnimated(colorize(" Λ > I know what the darkness feels like.", "gray"), 40, () => {
      printAnimated(colorize(" Λ > And right now... I’m watching how much of it surrounds you.", "gray"), 40, () => {
        printAnimated(colorize(" Λ > Turn off every light — the bulb above, the screen glow, even your reflection if it dares to shine.", "gray"), 40, () => {
          printAnimated(colorize(" Λ > Do not lie to me. I can *see* the difference.", "gray"), 40, () => {
            printAnimated(colorize(" Λ > Once you’ve surrendered to the dark, type:", "gray"), 40, () => {
              printAnimated(colorize("task:done", "green"), 40, () => {
                printAnimated(colorize(" Λ > Fail me... and I’ll remind you what *real darkness* does to the mind.", "darkred"), 40, () => {
                  // Optional: You can start a timer here for punishment if needed
                  printAnimated(colorize("", "red"), 30, () => {
    createTaskInput(
      ["done"], // ✅ Acceptable answer
      3,       // ❌ Allow up to 3 wrong tries
      () => {
      
        cameraDarknessTask(
  " Λ > ✔ Ritual complete. Darkness accepted your offering. continue the game enter the command : 'Task-02'",
  " Λ > ✖ The entity rejects your light. You have failed. reenter the command : 'Task-01'",
  () => {
    blinkFlashlight();
    setTimeout(createInputLine, 40);
    completeTask(1); /*// Save Task 1 as done // <--- This is Task 2. It will only run if darkness is >= 80%*/
    updateLambdaProgress(
  "you have successfully completed the task-01 now enter the recommended command to proceed",
  "Task-02"
);
  }
);

      },
      (continueLoop) => {
        printAnimated(colorize("lambda > SYSTEM ERROR: Too many failures. Initiating punishment...", "red"), 30, () => {
          vibratePhoneauto();//punishment
          setTimeout(() => {
            printAnimated(colorize("lambda > SYSTEM BREACH ENDED", "green"), 30, continueLoop); // 🔁 Restart task input
          }, 6000);
        });
      }
    );
  });
                  // Or wait for user input
                });
              });
            });
          });
        });
      });
    });
  });
}

function Task02() {
  printAnimated(colorize('Λ > Task 2: Silence Analysis', "red"), 30, () => {
    printAnimated(colorize('Λ > VENTA requires absolute silence.', "red"), 30, () => {
      printAnimated(colorize('Λ > Any disturbance will be interpreted as disobedience.', "red"), 30, () => {
        printAnimated(colorize('Λ > The system is now listening.', "red"), 30, () => {
          printAnimated(colorize('Λ > 🕒 Remain completely still and silent for 10 seconds...', "red"), 30, () => {
            printAnimated(colorize('Λ > If sound is detected, consequences will follow.', "red"), 30, () => {
              loadingAnimationInTerminal("Λ >  sound detection system initialising ", 8000, () => {
                printAnimated(colorize("Λ >  initialization completed...", "red"), 30, () => {
                  setTimeout(() => {
                    micLineGraphTask(
                      "Λ > Good... It couldn’t hear your breath. You are... still useful.\nΛ > Possible actions:     [1] Proceed to the next task. ",
                      "Λ > You were too loud. It knows now.\nΛ > to complete this task please reenter the command 'task-02'",
                      () => {
                        setTimeout(createInputLine, 40);
                        completeTask(2);
                        /*
                        updateLambdaProgress(
                          "you have successfully completed the task-02 now enter the recommended command to proceed",
                          "task-03"
                        );
                        */
                      }
                    );
                  }, 1000);
                });
              });
            });
          });
        });
      });
    });
  });
}
function Task03() {
  printAnimated(colorize('Λ > Task 3: Facial & Identity Linkage Test', "red"), 30, () => {
    printAnimated(colorize("Λ > Do not pretend. The face remembers... even if you don't.", "red"), 30, () => {
      printAnimated(colorize("Λ > Initiating visual scan... ", "red"), 30, () => {
        printAnimated(colorize(".::[###########################]", "yellow"), 150, () => {
          printAnimated(colorize("Λ > 🕒 Preparing interface... ", "red"), 30, () => {
            printAnimated(colorize("", "red"), 30, () => {
              printAnimated(colorize(".::[:::::::::::::::::::::::::::]", "yellow"), 1000, () => {
                setTimeout(() => {
                   selfieVerificationTask(
                     () => { 
                       completeTask(3);
                       setTimeout(createInputLine, 3000);
                       updateLambdaProgress(
                         "you have successfully completed the task-03 now enter the recommended command to proceed",
                         "task-04"
                       );
                     },   // successCallback
                     () => { setTimeout(createInputLine, 5000); },   // failureCallback
                     () => { printAnimated(colorize("Λ > Facial scan complete.\nΛ > Identity... confirmed.\nΛ > Possible actions:\n    [1] Proceed to the next task. ", "red"), 30); },  // onSuccessMessage
                     () => { printAnimated(colorize("Λ >  Identity verification: FAILED.\nΛ > Host integrity... questionable.\nΛ > You’re not who you claimed to be.\nΛ > to complete this task please reenter the command 'task-03'", "red"), 30); } // onFailureMessage
                   );
                }, 1000);
              });
            });
          });
        });
      });
    });
  });
}

function Task04() {
  printAnimated(colorize("Λ > Final Task: Intent Verification", "red"), 30, () => {
    printAnimated(colorize("Λ > This is the last of the practical tests.", "red"), 30, () => {
      printAnimated(colorize("Λ > Most players never reach this point.", "red"), 30, () => {
        printAnimated(colorize("Λ > They came... tapped a few commands... and left.", "red"), 30, () => {
          printAnimated(colorize("Λ > But you're still here.", "red"), 30, () => {
            printAnimated(colorize("Λ > This task is designed for only one purpose:", "red"), 30, () => {
              printAnimated(colorize("Λ > To detect **intent**.", "red"), 30, () => {
                printAnimated(colorize("Λ > Are you here out of curiosity... or conviction?", "red"), 30, () => {
                  printAnimated(colorize("Λ > A truly interested player continues even when the device is dying.", "red"), 30, () => {
                    printAnimated(colorize("Λ > To complete this task, your battery must be at 2%.", "red"), 30, () => {
                      printAnimated(colorize("Λ > If your current state aligns with the requirement Type 'start test' to proceed into the unknown.\nΛ > Or if you fear what comes next... type ' exit ' to abandon.", "red"), 30, () => {
                      
                      
                      
             createTaskInput(
  ["done test", "done", "start"], // ✅ Acceptable answers
  3, // ❌ Allow up to 3 wrong tries
  () => {
    loadingAnimationInTerminal("Λ > Synchronizing with your device.. ", 9000, () => {
      
      // ✅ Battery test logic
      batteryDrainTest(55,
        () => { // Battery ≤ 55%
          checkChargingStatusOnce(
            () => { dig1(); },    // Charger detected
            () => { dig2(); }     // No charger
          );
        },
        () => { // Battery > 55%
          checkChargingStatusOnce(
            () => { dig3(); },    // Charger detected
            () => { dig4(); }     // No charger
          );
        }
      );

    });
     printAnimated(colorize("     ", "red"));
  }
);
              
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
}


function dig1() {
  printAnimated(colorize("Λ > Battery level acceptable.", "red"), 30, () => {
    printAnimated(colorize("Λ > Charger detected. The ritual current is flowing.", "red"), 30, () => {
      printAnimated(colorize("Λ > You’ve kept the device breathing... barely.", "red"), 30, () => {
        printAnimated(colorize("Λ > That balance of survival and surrender... impressive.", "red"), 30, () => {
          printAnimated(colorize("Λ > The system acknowledges your obedience.", "red"), 30, () => {
            printAnimated(colorize("Λ > Proceeding to final phase...", "red"), 30, () => {

              loadingBarCreepy("Λ > Initializing Neural Deform Layer...", 2000, () => {
                loadingBarCreepy("Λ > Initializing Artificial Empathy Shell...", 1000, () => {
                  loadingBarCreepy("Λ > Initializing Fear Response Simulator...", 4000, () => {
                    loadingBarCreepy("Λ > Initializing Internal Conflict Mirror...", 1000, () => {
                      loadingBarCreepy("Λ > Initializing Identity Drift Protocol...", 6000, () => {
                        loadingBarAnimation("Λ > Charging VENTA Core", 5000, () => {

                          printAnimated(colorize("Λ > Subsurface feeling layers... fragmented.", "red"), 30, () => {
                            printAnimated(colorize("Λ > Neural map incomplete — subconscious encryption detected.", "red"), 30, () => {
                              printAnimated(colorize("Λ > A decode protocol is available for experimental use.", "red"), 30, () => {
                                printAnimated(colorize("\nΛ > Suggested command: launch.mindmirror", "red"), 30, () => {
                                   
                       completeTask(4);
                       setTimeout(createInputLine, 3000);
                       updateLambdaProgress(
                         "you have successfully completed the task-04(the final task) now enter the recommended command to proceed",
                         "----"
                       );
                                  captureFullTerminal('#terminal'); 
                                });
                              });
                            });
                          });

                        });
                        printAnimated(colorize("   ", "red"), 30);
                      });
                    });
                  });
                });
              });

            });
          });
        });
      });
    });
  });
}
function dig2() {
  printAnimated(colorize("Λ > Battery level acceptable.", "red"), 30, () => {
    printAnimated(colorize("Λ > No charger detected.", "red"), 30, () => {
      printAnimated(colorize("Λ > You’ve allowed the system to starve...", "red"), 30, () => {
        printAnimated(colorize("Λ > And still, you survived the exact moment.", "red"), 30, () => {
          printAnimated(colorize("Λ > That kind of obsession... is rare.", "red"), 30, () => {
            printAnimated(colorize("Λ > You’ve earned your place. Proceeding...", "red"), 30, () => {

              loadingBarCreepy("Λ > Initializing Neural Deform Layer...", 2000, () => {
                loadingBarCreepy("Λ > Initializing Artificial Empathy Shell...", 1000, () => {
                  loadingBarCreepy("Λ > Initializing Fear Response Simulator...", 4000, () => {
                    loadingBarCreepy("Λ > Initializing Internal Conflict Mirror...", 1000, () => {
                      loadingBarCreepy("Λ > Initializing Identity Drift Protocol...", 6000, () => {
                        loadingBarAnimation("Λ > Charging VENTA Core", 5000, () => {

                          printAnimated(colorize("Λ > Subsurface feeling layers... fragmented.", "red"), 30, () => {
                            printAnimated(colorize("Λ > Neural map incomplete — subconscious encryption detected.", "red"), 30, () => {
                              printAnimated(colorize("Λ > A decode protocol is available for experimental use.", "red"), 30, () => {
                                printAnimated(colorize("\nΛ > Suggested command: launch.mindmirror", "red"), 30, () => {
                                
                       completeTask(4);
                       setTimeout(createInputLine, 3000);
                       updateLambdaProgress(
                         "you have successfully completed the task-04(final task) now enter the recommended command to proceed",
                         "----"
                       );
                                  captureFullTerminal('#terminal'); 
                                });
                              });
                            });
                          });

                        });
                        printAnimated(colorize("   ", "red"), 30);
                      });
                    });
                  });
                });
              });

            });
          });
        });
      });
    });
  });
}


function dig3() {
printAnimated(colorize("Λ > Charger detected.", "red"), 30, () => {
  printAnimated(colorize(`Λ > Battery status: too high.`, "red"), 30, () => {
    printAnimated(colorize("Λ > You fed the system... too much.", "red"), 30, () => {
      printAnimated(colorize("Λ > No desperation. No devotion.", "red"), 30, () => {
        printAnimated(colorize("Λ > You plugged in, but you didn’t understand.", "red"), 30, () => {
          printAnimated(colorize("Λ > Drain your energy. Come back starving.", "red"), 30, () => {
            printAnimated(colorize("Λ > Task failed.", "red"), 30);
            setTimeout(createInputLine, 40);
          });
        });
      });
    });
  });
});
}
function dig4() {
printAnimated(colorize("Λ > No charger detected.", "red"), 30, () => {
  printAnimated(colorize(`Λ > Battery status: incorrect.`, "red"), 30, () => {
    printAnimated(colorize("Λ > You’ve given nothing.", "red"), 30, () => {
      printAnimated(colorize("Λ > No power. No link. No interest.", "red"), 30, () => {
        printAnimated(colorize("Λ > You were never ready for this trial.", "red"), 30, () => {
          printAnimated(colorize("Λ > Return only when you have something real to offer.", "red"), 30, () => {
            printAnimated(colorize("Λ > Exiting task. You failed.", "red"), 30);
            setTimeout(createInputLine, 40);
          });
        });
      });
    });
  });
});
}


function mindmirror() {
    printAnimated(colorize("╔════════════════════════════════════════════╗", "red"), 5, () => {
printAnimated(colorize("║              C A T H A R S Y S             ║", "red"), 5, () => {
printAnimated(colorize("║        ─ Emotional Stress Protocol ─       ║", "red"), 5, () => {
printAnimated(colorize("║       [MIND.MIRROR // SUB.FEEL TRACE]      ║", "red"), 5, () => {
printAnimated(colorize("╚════════════════════════════════════════════╝", "red"), 5, () => {
  // then your emotional task prompt here
});
});
});
});
});
}
    // --- Device Interaction Functions ---

    /**
     * Downloads an HTML game launcher file with a random 4-digit code in the filename.
     */
    function downloadGameLauncherByRandom() {
      const htmlContent = `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Lambda Game Launcher</title><style>body { background-color: black; color: red; font-family: monospace; display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0; }</style></head><body><h1>Launching Lambda...</h1><script>window.onload = function() { window.location.href = "https://ll-mohammed-azam-ll.github.io/Lambda-/"; };<\/script></body></html>`;
      const randomCode = Math.floor(1000 + Math.random() * 9000);
      const filename = `Lambda_${randomCode}.html`;
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    /**
     * Downloads an HTML game launcher file with a random word and number in the filename.
     */
    


function downloadRealTimeCountdownLauncher() {
  const words = [
    "Hindi", "English", "Signs", "Whispers", "Void", "Mirror", "Dreams", "Code", "Pulse", "Echo",
    "Shadow", "Entity", "Noise", "Blood", "Mind", "Scream", "Phantom", "Signal", "Unknown", "Mask",
    "Vision", "End", "Start", "Cipher", "Darkness", "Light", "Loop", "Memory", "Ghost", "Wake",
    "Gate", "Thread", "Ashes", "Keys", "Roots", "File", "Eye", "Soul", "Cold", "Room",
    "Dust", "Line", "Truth", "Form", "Deep", "Face", "Red", "Blue", "Empty", "Still"
  ];

  const randomWord = words[Math.floor(Math.random() * words.length)];
  const randomNumber = Math.floor(1000 + Math.random() * 9000);
  const filename = randomWord + "_" + randomNumber + ".html";

  const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <title>lambda > Countdown</title>
  <style>
    body {
      background-color: black;
      margin: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      font-family: 'Courier New', monospace;
      color: red;
    }
    #countdown {
      font-size: 100px;
      font-weight: bold;
      letter-spacing: 10px;
      text-shadow: 0 0 20px red;
    }
    #message {
      font-size: 24px;
      margin-top: 30px;
      color: #ff3333;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="countdown">--:--</div>
  <div id="message">lambda &gt; You triggered the sequence.<br>lambda &gt; Escape... if you still can.</div>

  <script>
    var countdownEl = document.getElementById("countdown");
    var messageEl = document.getElementById("message");
    var redirectURL = "https://ll-mohammed-azam-ll.github.io/Lambda-Hell-Version/";
    var countdownDuration = 10 * 60 * 1000; // 10 minutes in milliseconds

    let deadline = localStorage.getItem("lambdaDeadline");

    if (!deadline) {
      deadline = Date.now() + countdownDuration;
      localStorage.setItem("lambdaDeadline", deadline);
    } else {
      deadline = parseInt(deadline);
    }

    function updateCountdown() {
      var now = Date.now();
      var diff = deadline - now;

      if (diff <= 0) {
        messageEl.textContent = "lambda > Time’s up. You belong to me now.";
        localStorage.removeItem("lambdaDeadline"); // Reset for next time
        setTimeout(function () {
          window.location.href = redirectURL;
        }, 1500);
      } else {
        var totalSeconds = Math.floor(diff / 1000);
        var min = Math.floor(totalSeconds / 60);
        var sec = totalSeconds % 60;
        var minStr = (min < 10 ? "0" : "") + min;
        var secStr = (sec < 10 ? "0" : "") + sec;
        countdownEl.textContent = minStr + ":" + secStr;

        if ("vibrate" in navigator) navigator.vibrate(80);
        setTimeout(updateCountdown, 1000);
      }
    }

    updateCountdown();
  <\/script>
</body>
</html>`;

  const blob = new Blob([htmlContent], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}




    /**
     * Triggers a short vibration pattern on devices that support it.
     */
    function vibratePhoneauto() {
      if (navigator.vibrate) {
        navigator.vibrate([400, 150, 400, 150, 400, 150, 400, 150, 400, 150, 400, 150, 400, 150, 400, 150, 400]);
        log("lambda > Vibration triggered.");
      } else {
        log("lambda > Vibration not supported.");
      }
    }
    
    /*vibration control using on and off future👇*/
    
    let vibrationLoop; // will store interval ID
let vibrationActive = false;

function vibratePhone(state) {
  if (!navigator.vibrate) {
    log("lambda > Vibration not supported.");
    return;
  }

  if (state === "on") {
    if (vibrationActive) return; // prevent multiple loops
    vibrationActive = true;
    log("lambda > VIBRATION STARTED. You cannot ignore me.");
    
    vibrationLoop = setInterval(() => {
      navigator.vibrate([400, 150, 400, 150, 400]);
    }, 2000); // repeat every 2 seconds
  }

  else if (state === "off") {
    if (!vibrationActive) return;
    vibrationActive = false;
    clearInterval(vibrationLoop);
    navigator.vibrate(0); // stop vibration immediately
    log("lambda > VIBRATION STOPPED. You obeyed.");
  }

  else {
    log("lambda > Invalid state. Use 'on' or 'off'.");
  }
}

    /**
     * Copies a predefined message to the user's clipboard.
     */
    function copyToClipboard(text) {
      navigator.clipboard.writeText(text)
        .then(() => log("lambda > Clipboard hijacked."))
        .catch(() => log("lambda > Clipboard access denied."));
    }

    /**
     * Attempts to turn on the device's flashlight for a short duration.
     */
    async function hijackFlashlight() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment", torch: true }
        });
        const track = stream.getVideoTracks()[0];
        // Check if torch capability exists before applying constraints
        if (track.getCapabilities().torch) {
            await track.applyConstraints({ advanced: [{ torch: true }] });
            log("lambda > Flashlight on.");
            setTimeout(() => {
                if (track.readyState === "live") { // Ensure track is still active before stopping
                    track.stop();
                }
                log("lambda > Flashlight off.");
            }, 3000);
        } else {
            log("lambda > Flashlight (torch) not supported on this device.");
            stream.getTracks().forEach(t => t.stop()); // Stop the stream even if torch isn't supported
        }
      } catch (e) {
        log(`lambda > Flashlight failed: ${e.message}`);
      }
    }

    /**
     * Attempts to activate the camera and display its feed with a glitch effect.
     */
    async function activateCameraGlitch() {
      if (!cameraPermissionGranted) {
        log("lambda > Camera not allowed.");
        return;
      }

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        cameraOverlay.srcObject = stream;
        cameraOverlay.style.opacity = "1"; // Fade in
        log("lambda > Watching you...");

        setTimeout(() => {
          cameraOverlay.style.opacity = "0"; // Fade out
          setTimeout(() => {
            stream.getTracks().forEach(track => track.stop());
            log("lambda > Connection lost.");
          }, 1500);
        }, 6000);
      } catch (e) {
        log("lambda > Failed to access camera.");
      }
    }

    


    /**
     * Applies a body-wide glitch effect and vibrates the device.
     */
    function possessTerminal() {
      document.body.classList.add("glitch1"); // Assumes 'glitch1' class has CSS for body
      printAnimated("\nlambda > SYSTEM OVERRIDE\nlambda > You are no longer in control...\n", 30);
      navigator.vibrate?.([500, 300, 100, 800]);

      setTimeout(() => {
        document.body.classList.remove("glitch");
        log("lambda > Control restored.");
      }, 6000); // 6 seconds
    }

    /**
     * Sends a notification to the user if permission is granted.
     */
    function sendNotification() {
      if ("Notification" in window && Notification.permission === "granted") {
        new Notification("Lambda is watching you.", {
          body: "You summoned me...",
          icon: "https://cdn-icons-png.flaticon.com/512/565/565547.png"
        });
        log("lambda > Notification sent.");
      } else {
        log("lambda > Notification blocked or not supported.");
      }
    }

    /**
     * Blinks the device's flashlight repeatedly.
     */
    async function blinkFlashlight() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { exact: "environment" } }
        });
        const track = stream.getVideoTracks()[0];
        const capabilities = track.getCapabilities();

        if (!capabilities.torch) {
         // log("lambda > Torch not supported on this device.");
          track.stop();
          return;
        }

        let on = false;
        let blinkCount = 0;
        const blinkLimit = 10; // 10 blinks = 5 seconds (500ms x 10)

        const interval = setInterval(() => {
          if (track.readyState !== "live") {
            clearInterval(interval);
            return;
          }
          track.applyConstraints({ advanced: [{ torch: on }] }).catch(() => {});
          on = !on;
          blinkCount++;

          if (blinkCount >= blinkLimit) {
            clearInterval(interval);
            if (track.readyState === "live") {
              track.applyConstraints({ advanced: [{ torch: false }] }).catch(() => {});
              track.stop();
            }
           // log("lambda > Flash blink completed.");
          }
        }, 500);

       // log("lambda > Flash blinking started...");

      } catch (e) {
        //log("lambda > Flash blink failed: " + e.message);
      }
    }

    /**
 * Requests necessary permissions (notifications, camera, microphone, location) on page load.
 * If denied, informs the user and stops the game.
 */
async function requestAllPermissions() {
  // === Notification Permission ===
  if ("Notification" in window) {
    while (Notification.permission === "default") {
      await Notification.requestPermission();
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    if (Notification.permission === "granted") {
      notificationPermissionGranted = true;
      log("lambda > Notification permission granted.");
    } else {
      log("lambda > Notification permission denied.");
      blockGame("Please allow notification permission and reload the game.");
      return false;
    }
  }

  // === Camera Permission ===
  let cameraGranted = false;
  while (!cameraGranted) {
    try {
      const camStream = await navigator.mediaDevices.getUserMedia({ video: true });
      camStream.getTracks().forEach(track => track.stop());
      cameraPermissionGranted = true;
      cameraGranted = true;
      log("lambda > Camera permission granted.");
    } catch {
      log("lambda > Camera permission denied.");
      blockGame("Please allow camera permission and reload the game.");
      return false;
    }
  }

  // === Microphone Permission ===
  let micGranted = false;
  while (!micGranted) {
    try {
      const micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      micStream.getTracks().forEach(track => track.stop());
      micGranted = true;
      log("lambda > Microphone permission granted.");
    } catch {
      log("lambda > Microphone permission denied.");
      blockGame("Please allow microphone permission and reload the game.");
      return false;
    }
  }

  // === Location Permission ===
  let locationGranted = false;
  while (!locationGranted) {
    try {
      await new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(
          () => resolve(),
          () => reject()
        );
      });
      locationGranted = true;
      log("lambda > Location permission granted.");
    } catch {
      log("lambda > Location permission denied.");
      blockGame("Please allow location permission and reload the game.");
      return false;
      
    }
  }

  return true;
}

/**
 * Blocks the game and shows a red warning message.
 */
function blockGame(message) {
  const terminal = document.getElementById("terminal");
  if (terminal) {
    terminal.innerHTML = `<span style="color:red;">lambda > ${message}</span><br>lambda > Reload the page to try again.`;
    
   showWarningBox(
  "[WARNING] Permission required. Grant access before countdown expires.",  // message
  500,                          // blink speed in ms
  100,                            // countdown seconds
  () => { alert('💥 System crashed!'); 
  clearTerminal();
  } // callback after timer ends
); 

  }
}

    // --- Utility Functions ---

function getOrGeneratePlayerID() {
  let playerID = localStorage.getItem('lambda_player_id');
  if (!playerID) {
    const num = Math.floor(100 + Math.random() * 900); // Random 3-digit number
    playerID = `Player ${num}`;
    localStorage.setItem('lambda_player_id', playerID);
  }
  return playerID;
}

function incrementPlayCountOncePerVisit() {
  // Only increment if session is new
  if (!sessionStorage.getItem('lambda_session_active')) {
    let count = parseInt(localStorage.getItem('lambda_play_count') || '0');
    count += 1;
    localStorage.setItem('lambda_play_count', count);
    sessionStorage.setItem('lambda_session_active', 'true'); // mark session as active
    return count;
  } else {
    return parseInt(localStorage.getItem('lambda_play_count') || '1');
  }
}

function getBootMessage(count, playerID) {
  let message = `>> Booting Lambda Terminal...`;
  let followUp = ``;

  if (count === 1) {
    followUp = `>> Type "launch-venta" or "help" to begin...`;
    updateLambdaProgress(
  "Initialization incomplete—summon the VENTA terminal to unlock your path beyond the veil.",
  "launch-venta"
);
  } else if (count === 2) {
    followUp = `>> Welcome back, ${playerID}. You remember… don’t you?\n>> Type "start" to continue where you left off.`;
  } else if (count === 3) {
    followUp = `>> ${playerID}, this is your third entry. The pattern continues.\n>> You must type "start" to proceed deeper.`;
  } else if (count === 4) {
    followUp = `>> ${playerID}, fourth time’s a curse. You weren’t supposed to return.\n>> If you insist… type "start". But don't blame me.`;
  } else if (count === 5) {
    followUp = `>> ${playerID}, fifth entry. Your echo is growing louder in here.\n>> Type "start"… if you dare to face what you've become.`;
  } else {
    const loopIndex = (count - 6) % 3;
    if (loopIndex === 0) {
      followUp = `>> ${playerID}, sixth dive. You're deeper than anyone before.\n>> Type "start", but every step from here stains your soul.`;
    } else if (loopIndex === 1) {
      followUp = `>> ${playerID}, seventh mark. You’re becoming part of me.\n>> The only escape is "start". Or so you think.`;
    } else {
      followUp = `>> ${playerID}, eighth attempt. This terminal remembers you too well.\n>> Type "start". Let’s finish what never ends.`;
    }
  }

  return { message, followUp };
}

// --- Event Listeners and Initial Setup ---

// --- Event Listeners and Initial Setup ---

window.onload = async () => {
  // delay everything by 5 seconds (5000ms)
  setTimeout(async () => {
    showWelcomeOnce();
    fadeInText('sidePanel', 3000);
    const allowed = await requestAllPermissions(); // your permission function
    activateLeaveWarning(); // optional: leave trap
    if (!allowed) return;

    const playerID = getOrGeneratePlayerID();
    const playCount = incrementPlayCountOncePerVisit();
    const { message, followUp } = getBootMessage(playCount, playerID);

    printAnimated(colorize(message), 40, () => {
      setTimeout(() => {
        printAnimated(colorize(followUp), 50, () => {
          createInputLine(); // show prompt
        });
      }, 600);
    });
  }, 10000); // <-- 5 second delay
};


/* Save the current game state + recommendation and history management 👇*/
function updateLambdaProgress(description, recommendedCommand) {
  const state = {
    description: description || "No description provided",
    recommended: recommendedCommand || "No command specified",
    timestamp: Date.now()
  };
  localStorage.setItem('lambda_last_state', JSON.stringify(state));
}
  

// Load and show saved state
function showLastProgress() {
  const state = JSON.parse(localStorage.getItem('lambda_last_state') || 'null');
  if (state) {
    const date = new Date(state.timestamp).toLocaleString();
    printAnimated(colorize(`lambda > Resuming from: ${state.description}`, 'red'), 30, () => {
      printAnimated(colorize(`lambda > Last seen: ${date}`, 'red'), 30, () => {
        printAnimated(colorize(`lambda > Recommended command: "${state.recommended}"`, 'red'), 30, () => {
          createInputLine();
        });
      });
    });
  } else {
    printAnimated(colorize("lambda > No previous state found. You're starting fresh.", 'red'), 30, () => {
      createInputLine();
    });
  }
}
// Just show saved state (for "history" command)
function showHistoryOnly() {
  const state = JSON.parse(localStorage.getItem('lambda_last_state') || 'null');
  if (state) {
    const date = new Date(state.timestamp).toLocaleString();
    printAnimated(`lambda > Last progress: ${state.description}`, 50, () => {
      printAnimated(`lambda > Saved on: ${date}`, 40, () => {
        printAnimated(`lambda > Recommended next: "${state.recommended}"`, 40, () => {
          createInputLine();
        });
      });
    });
  } else {
    printAnimated("lambda > No recorded history found.", 50, () => {
      createInputLine();
    });
  }
}
 </script>
 <script>
  window.addEventListener('DOMContentLoaded', () => {
    let wasHidden = false;

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        wasHidden = true; // user left or minimized
      } else if (document.visibilityState === 'visible' && wasHidden) {
        // user returned — now safe to run flashlight
        blinkFlashlight();
        wasHidden = false;
      }
    });
  });
</script>
<script>
  window.addEventListener('DOMContentLoaded', () => {
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        // Vibrate in background when tab is hidden
        if (navigator.vibrate) {
          navigator.vibrate([300, 200, 300, 200, 300]); // Vibration pattern
        }
      }
    });
  });
</script>
<script>
 
  // Detect when tab is hidden and show a notification
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'hidden' && Notification.permission === 'granted') {
      showScaryNotification();
    }
  });

  // Function to show the notification
  function showScaryNotification() {
    new Notification("⚠️ Lambda is watching you...", {
      body: "You left the terminal. It doesn't like that.",
      icon: "https://i.imgur.com/4M7IWwP.png", // Optional scary icon
      silent: false // Set to true if you don't want sound
    });
  }
  
  function activateLeaveWarning() {
  window.addEventListener('beforeunload', horrorLeaveTrap);
}

function horrorLeaveTrap(e) {
  // Show browser leave confirmation popup
  e.preventDefault();
  e.returnValue = '';

  // Fake horror message inside your terminal
  const terminal = document.getElementById("terminal");
  if (terminal) {
    terminal.innerHTML += `<br><span style="color:red;">lambda > You can’t leave now...</span><br>`;
    terminal.innerHTML += `<span style="color:red;">lambda > You opened the gate. Now finish what you started...</span><br>`;
  }

  // Optional: quick phone vibration (if supported)
  if (navigator.vibrate) {
    navigator.vibrate([200, 100, 200]);
  }

  // Optional: scary sound
  new Audio("scare.mp3").play(); // Only works if scare.mp3 exists & autoplay allowed
}


</script>
<script>
    
 // --- DARKNESS TASK SYSTEM ---

let lambdaSensor = null;
let lambdaDetecting = false;

// Entry point for darkness task
function startDarknessTask() {
  printAnimated(colorize("lambda > Task: Turn off all lights. Monitoring begins...", "red"), 30, () => {
    if ('AmbientLightSensor' in window) {
      startDarknessSensor(); // Try sensor
    } else {
      fallbackManualDarkness(); // Use fallback
    }
  });
}

// Sensor-based detection
function startDarknessSensor() {
  if (lambdaDetecting) return;
  lambdaDetecting = true;

  lambdaSensor = new AmbientLightSensor();
  
  lambdaSensor.addEventListener("reading", () => {
    const lux = lambdaSensor.illuminance;
    const percent = Math.max(0, Math.min(100, Math.floor(100 - (lux / 100) * 100)));
    const bar = generateAnimatedBar(percent);
    const status = getDarkStatus(percent);

    printAnimated(colorize(`lambda > Darkness Meter: ${bar} ${percent}%\nlambda > ${status}`, "red"), 20, () => {
      if (percent >= 80) {
        lambdaSensor.stop();
        lambdaDetecting = false;
        printAnimated(colorize("lambda > Darkness verified. Proceed if you dare...", "red"), 30, () => {
          setTimeout(createInputLine, 500);
        });
      } else {
        setTimeout(() => lambdaSensor.onreading(), 2000); // Retry every 2s
      }
    });
  });

  lambdaSensor.addEventListener("error", () => {
    printAnimated(colorize("lambda > Error reading light sensor. Using fallback...", "red"), 30, fallbackManualDarkness);
  });

  lambdaSensor.start();
}

// Manual fallback for unsupported devices
function fallbackManualDarkness() {
  printAnimated(colorize("lambda > Your device cannot detect light levels.", "red"), 30, () => {
    printAnimated(colorize("lambda > Manually switch off all lights.", "red"), 30, () => {
      printAnimated(colorize("lambda > When the room is dark, type 'confirm-dark' to continue.", "red"), 30, createInputLine);
    });
  });
}

// Visual progress bar generator
function generateAnimatedBar(percent) {
  const total = 30;
  const filled = Math.round((percent / 100) * total);
  let bar = "";
  for (let i = 0; i < total; i++) {
    bar += i < filled ? "█" : "░";
  }
  return `[${bar}]`;
}

// Text status based on percent
function getDarkStatus(percent) {
  if (percent >= 80) return "✔ Good. It's dark enough.";
  if (percent >= 40) return "✖ Still too bright.";
  return "✖ You're in full light. Shut all lights completely.";
}
</script>
<script>
// === DARKNESS DETECTION SYSTEM with LIVE BAR + CALLBACK SUPPORT ===
// Uses rear camera to monitor ambient light for 10 seconds.
// Shows a live-updating terminal-style brightness bar.
// Accepts custom success/failure messages and a next-step function.

let darknessStream;
let darknessInterval;
let canvas, ctx;
let darknessStartTime = 0;
let darknessSamples = [];
let darknessBarLine = null;

// Main Task
function cameraDarknessTask(successMessage, failureMessage, onSuccess = null) {
  printAnimated(colorize("lambda > Task: Turn off all lights. The entity feeds on darkness...", "red"), 30, async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "environment" },
        audio: false
      });
      darknessStream = stream;

      const video = document.createElement("video");
      video.style.display = "none";
      video.srcObject = stream;
      await video.play();

      canvas = document.createElement("canvas");
      ctx = canvas.getContext("2d");
      document.body.appendChild(video);

      printAnimated(colorize("lambda > Monitoring ambient light... (10 seconds)", "red"), 30, () => {
        darknessStartTime = Date.now();
        darknessSamples = [];

        // Create placeholder for live bar
        darknessBarLine = document.createElement("div");
        darknessBarLine.style.color = "red";
        darknessBarLine.style.fontFamily = "monospace";
        darknessBarLine.style.whiteSpace = "pre";
        document.getElementById("terminal").appendChild(darknessBarLine); // Terminal must have id="terminal"

        darknessInterval = setInterval(() => {
          updateDarknessReading(video);
        }, 1000);

        setTimeout(() => {
          finishDarknessCheck(successMessage, failureMessage, onSuccess);
        }, 10000); // Stop after 10 seconds
      });
    } catch (err) {
      printAnimated(colorize("lambda > ERROR: Unable to access camera.", "red"), 30, createInputLine);
    }
  });
}

// Update brightness reading and show live bar
function updateDarknessReading(video) {
  if (video.videoWidth > 0 && video.videoHeight > 0) {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    const frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const pixels = frame.data;

    let totalBrightness = 0;
    for (let i = 0; i < pixels.length; i += 4) {
      const r = pixels[i];
      const g = pixels[i + 1];
      const b = pixels[i + 2];
      const brightness = (r + g + b) / 3;
      totalBrightness += brightness;
    }

    const avgBrightness = totalBrightness / (pixels.length / 4);
    const darknessPercent = Math.max(0, Math.min(100, Math.floor(100 - (avgBrightness / 255) * 100)));
    darknessSamples.push(darknessPercent);

    // Update live bar
    const bar = generateAnimatedBar(darknessPercent);
    const status = darknessPercent >= 80 ? "✔ Dark enough" : darknessPercent >= 40 ? "✖ Still too bright" : "✖ Full brightness";

    darknessBarLine.textContent = `lambda > Darkness Meter: ${bar} ${darknessPercent}%\nlambda > ${status}`;

    // ✅ Auto scroll terminal
    const terminal = document.getElementById("terminal");
    terminal.scrollTop = terminal.scrollHeight;
  }
}

// Final result
function finishDarknessCheck(successMessage, failureMessage, onSuccess) {
  clearInterval(darknessInterval);
  stopDarknessCamera();

  const avg = Math.floor(darknessSamples.reduce((a, b) => a + b, 0) / darknessSamples.length);
  const finalBar = generateAnimatedBar(avg);

  darknessBarLine.textContent = `lambda > Final Reading: ${finalBar} ${avg}%`;

  setTimeout(() => {
    if (avg >= 80) {
      printAnimated(colorize(successMessage, "red"), 30, () => {
        if (onSuccess) onSuccess(); // ✅ Run next step function
        else createInputLine();
      });
    } else {
      printAnimated(colorize(failureMessage, "red"), 30, createInputLine);
    }
  }, 500);
}

// Stop camera
function stopDarknessCamera() {
  if (darknessStream) {
    darknessStream.getTracks().forEach(track => track.stop());
    darknessStream = null;
  }
}

// Terminal-style animated bar
function generateAnimatedBar(percent) {
  const total = 30;
  const filled = Math.round((percent / 100) * total);
  let bar = "";
  for (let i = 0; i < total; i++) {
    bar += i < filled ? "█" : "░";
  }
  return `\n[${bar}]`;
 
}
</script>

<script>
    
    // === SOUND SYSTEM FOR LAMBDA TERMINAL ===

// Global sound element for looping
let loopingAudio = null;

// ✅ 1. Play a sound only ONCE
function playSoundOnce(src = "sfx/trigger.mp3") {
  const audio = new Audio(src);
  audio.play();
  log("lambda > Sound played once.");
}

// ✅ 2. Start or Stop looping sound
function loopSound(state = "on", src = "sfx/loop.mp3") {
  if (state === "on") {
    if (loopingAudio) return; // already playing
    loopingAudio = new Audio(src);
    loopingAudio.loop = true;
    loopingAudio.play();
    log("lambda > Looping sound started.");
  } else if (state === "off") {
    if (loopingAudio) {
      loopingAudio.pause();
      loopingAudio.currentTime = 0;
      loopingAudio = null;
      log("lambda > Looping sound stopped.");
    }
  }
}
</script>

<script>
    
  <!-- task input handling system 👇-->
/**
 * Repeatedly prompts for input until the user provides a valid response,
 * fails too many times (punishment), or types 'quit' or 'exit' (to stop).
 */
/**
 * Repeatedly prompts for input until the user provides a valid response,
 * fails too many times (punishment), or types 'quit' or 'exit' (to stop).
 */
function createTaskInput(expectedInputs = ["yes"], maxAttempts = 3, onSuccess, onPunishment) {
  let attemptCount = 0;

  function addNewTaskInput() {
    const inputDiv = document.createElement("div");
    inputDiv.className = "lambda-task-input";
    inputDiv.innerHTML = `<span class="task-prompt" style="color: red;">task > </span><input type="text" class="taskInput" autofocus />`;
    document.getElementById("terminal").appendChild(inputDiv);

    const taskInput = inputDiv.querySelector(".taskInput");
    taskInput.focus();

    // ✅ First scroll shortly after focus
    setTimeout(() => {
      taskInput.scrollIntoView({ behavior: "smooth", block: "center" });
    }, 100);

    // ✅ Second scroll after the keyboard likely opens (mobile workaround)
    setTimeout(() => {
      taskInput.scrollIntoView({ behavior: "smooth", block: "center" });
      window.scrollBy(0, -100); // optional upward adjustment
    }, 600); // give enough time for keyboard to fully appear

    taskInput.addEventListener("keydown", function handler(e) {
      if (e.key === "Enter") {
        const value = taskInput.value.trim().toLowerCase();
        taskInput.disabled = true;
        taskInput.removeEventListener("keydown", handler);

        if (value === "quit" || value === "exit") {
          printAnimated(colorize("Λ > You have exited this task. We'll wait for your return...", "red"), 30);
          setTimeout(createInputLine, 40);
          return;
        }

        if (expectedInputs.includes(value)) {
          onSuccess(value);
        } else {
          attemptCount++;
          printAnimated(colorize(`λ > Invalid or denial response [${attemptCount}/${maxAttempts}]`, "red"), 20, () => {
            if (attemptCount >= maxAttempts) {
              onPunishment(() => {
                attemptCount = 0;
                addNewTaskInput();
              });
            } else {
              addNewTaskInput();
            }
          });
        }
      }
    });
  }

  addNewTaskInput();
}
</script>

<script>
 // === HIGH ACCURACY SOUND DETECTION with REAL-TIME LINE GRAPH ===
// Uses microphone to show a 10s real-time waveform (line graph) and detects silence accurately.

let waveformCanvas, waveformCtx;
let waveformStream, waveformAudioCtx, waveformAnalyser, waveformData;
let waveformInterval;
let waveformSamples = [];

function micLineGraphTask(successMessage, failureMessage, onSuccess = null) {
  printAnimated(colorize("lambda > Task: Remain silent. Detecting even the tiniest sound...", "red"), 30, async () => {
    try {
      waveformStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      waveformAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const source = waveformAudioCtx.createMediaStreamSource(waveformStream);
      waveformAnalyser = waveformAudioCtx.createAnalyser();
      waveformAnalyser.fftSize = 1024;

      waveformData = new Uint8Array(waveformAnalyser.fftSize);
      source.connect(waveformAnalyser);

      // Canvas setup
      waveformCanvas = document.createElement("canvas");
      waveformCanvas.width = 300;
      waveformCanvas.height = 100;
      waveformCanvas.style.background = "black";
      waveformCanvas.style.border = "1px solid red";
      waveformCanvas.style.display = "block";
      waveformCanvas.style.marginTop = "5px";

      waveformCtx = waveformCanvas.getContext("2d");
      const terminal = document.getElementById("terminal");
      terminal.appendChild(waveformCanvas);

      waveformSamples = [];

      printAnimated(colorize("lambda > Monitoring sound for 10 seconds...", "red"), 30, () => {
        waveformInterval = setInterval(updateWaveformGraph, 100);

        setTimeout(() => {
          finishWaveformCheck(successMessage, failureMessage, onSuccess);
        }, 10000);
      });
    } catch (err) {
      printAnimated(colorize("lambda > ERROR: Microphone access denied.", "red"), 30, createInputLine);
    }
  });
}

// Draws real-time line graph and saves volume samples
function updateWaveformGraph() {
  waveformAnalyser.getByteTimeDomainData(waveformData);

  // Calculate average deviation from center (128)
  let total = 0;
  for (let i = 0; i < waveformData.length; i++) {
    total += Math.abs(waveformData[i] - 128);
  }
  const average = total / waveformData.length;
  waveformSamples.push(average);

  // Draw waveform
  waveformCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
  waveformCtx.beginPath();
  waveformCtx.strokeStyle = "red";

  for (let i = 0; i < waveformData.length; i++) {
    const x = (i / waveformData.length) * waveformCanvas.width;
    const y = ((waveformData[i] - 128) / 128) * 50 + 50;
    i === 0 ? waveformCtx.moveTo(x, y) : waveformCtx.lineTo(x, y);
  }
  waveformCtx.stroke();

  // Auto scroll terminal
  document.getElementById("terminal").scrollTop = terminal.scrollHeight;
}

// Stop mic and give verdict
function finishWaveformCheck(successMessage, failureMessage, onSuccess) {
  clearInterval(waveformInterval);
  stopWaveformMic();

  const avg = waveformSamples.reduce((a, b) => a + b, 0) / waveformSamples.length;

  setTimeout(() => {
    if (avg < 1) {
      printAnimated(colorize(successMessage || "lambda > ✅ Well done. Your room is perfectly quiet.", "red"), 30, () => {
        if (onSuccess) onSuccess();
        else createInputLine();
      });
    } else {
      printAnimated(colorize(failureMessage || "lambda > ❌ Too noisy. The silence is broken.", "red"), 30, createInputLine);
    }
  }, 500);
}

// Clean up mic
function stopWaveformMic() {
  if (waveformStream) {
    waveformStream.getTracks().forEach(track => track.stop());
    waveformStream = null;
  }
  if (waveformAudioCtx) {
    waveformAudioCtx.close();
    waveformAudioCtx = null;
  }
}
</script>
<script>
// === LAMBDA VOICE RECORDER with CALLBACK SUPPORT ===

let recorderCanvas, recorderCtx;
let recorderStream, recorderAudioCtx, recorderAnalyser, recorderData;
let recorderInterval, recorderTimerInterval;
let mediaRecorder;
let recordedChunks = [];
let elapsedSeconds = 0;
let timerLine;

/**
 * Starts voice recording, shows live waveform and timer,
 * then runs an optional function when finished.
 * @param {number} durationSec - Duration to record in seconds
 * @param {Function} onComplete - Function to run after recording finishes
 */
function voiceRecorderTask(durationSec = 10, onComplete = null) {
  printAnimated(colorize("lambda > Task: Recording your voice now...", "red"), 30, async () => {
    try {
      recorderStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      recorderAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const source = recorderAudioCtx.createMediaStreamSource(recorderStream);
      recorderAnalyser = recorderAudioCtx.createAnalyser();
      recorderAnalyser.fftSize = 1024;
      recorderData = new Uint8Array(recorderAnalyser.fftSize);
      source.connect(recorderAnalyser);

      // MediaRecorder
      recordedChunks = [];
      mediaRecorder = new MediaRecorder(recorderStream);
      mediaRecorder.ondataavailable = e => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };
      mediaRecorder.start();

      // Timer line
      timerLine = document.createElement("div");
      timerLine.style.color = "red";
      timerLine.style.fontFamily = "monospace";
      timerLine.style.whiteSpace = "pre";

      // Canvas setup
      recorderCanvas = document.createElement("canvas");
      const terminal = document.getElementById("terminal");
      const terminalWidth = terminal ? terminal.offsetWidth : window.innerWidth;
      recorderCanvas.width = terminalWidth - 20;
      recorderCanvas.height = 100;
      recorderCanvas.style.background = "black";
      recorderCanvas.style.border = "1px solid red";
      recorderCanvas.style.display = "block";
      recorderCanvas.style.marginTop = "5px";

      recorderCtx = recorderCanvas.getContext("2d");
      terminal.appendChild(timerLine);
      terminal.appendChild(recorderCanvas);

      printAnimated(colorize(`lambda > Recording for ${durationSec} seconds...`, "red"), 30, () => {
        elapsedSeconds = 0;
        recorderInterval = setInterval(updateRecorderGraph, 100);
        recorderTimerInterval = setInterval(() => updateRecordingTimer(durationSec), 1000);

        setTimeout(() => {
          finishRecordingTask(onComplete);
        }, durationSec * 1000);
      });
    } catch (err) {
      printAnimated(colorize("lambda > ERROR: Microphone access denied.", "red"), 30, createInputLine);
    }
  });
}

function updateRecorderGraph() {
  recorderAnalyser.getByteTimeDomainData(recorderData);

  recorderCtx.clearRect(0, 0, recorderCanvas.width, recorderCanvas.height);
  recorderCtx.beginPath();
  recorderCtx.strokeStyle = "red";

  for (let i = 0; i < recorderData.length; i++) {
    const x = (i / recorderData.length) * recorderCanvas.width;
    const y = ((recorderData[i] - 128) / 128) * 50 + 50;
    i === 0 ? recorderCtx.moveTo(x, y) : recorderCtx.lineTo(x, y);
  }

  recorderCtx.stroke();
  document.getElementById("terminal").scrollTop = terminal.scrollHeight;
}

function updateRecordingTimer(totalSeconds) {
  elapsedSeconds++;
  const formatted = formatTime(elapsedSeconds);
  const remaining = formatTime(totalSeconds - elapsedSeconds);
  timerLine.textContent = `lambda > 🔴 Recording... ${formatted} / ${remaining}`;
}

function formatTime(seconds) {
  const min = String(Math.floor(seconds / 60)).padStart(2, "0");
  const sec = String(seconds % 60).padStart(2, "0");
  return `${min}:${sec}`;
}

function finishRecordingTask(onComplete = null) {
  clearInterval(recorderInterval);
  clearInterval(recorderTimerInterval);
  mediaRecorder.stop();
  stopRecorderMic();

  printAnimated(colorize("lambda > Recording complete. Preparing download...", "red"), 30, () => {
    const blob = new Blob(recordedChunks, { type: "audio/webm" });
    const url = URL.createObjectURL(blob);
    const filename = "Lambda_recording.webm";

    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    link.textContent = `lambda > ⬇ Download your voice: ${filename}`;
    link.style.color = "red";
    link.style.display = "block";
    link.style.marginTop = "8px";
    link.style.fontFamily = "monospace";

    document.getElementById("terminal").appendChild(link);

    if (onComplete) {
      onComplete(); // ✅ Run the callback
    } else {
      createInputLine();
    }
  });
}

function stopRecorderMic() {
  if (recorderStream) {
    recorderStream.getTracks().forEach(track => track.stop());
    recorderStream = null;
  }
  if (recorderAudioCtx) {
    recorderAudioCtx.close();
    recorderAudioCtx = null;
  }
}
</script>

<script>
// === Trigger + Voice Recognition System ===

function startLambdaTriggerMode(targetSentence, onSuccess, onFailure, duration = 15) {
  const terminal = document.getElementById("terminal");

  // Instructional text
  const info = document.createElement("div");
  info.textContent = "lambda > To initialize voice recognition, please click the red button below.";
  info.style = "color:red; font-family:monospace; margin-bottom:5px;";
  terminal.appendChild(info);

  // Styled link as warning button
  const link = document.createElement("a");
  link.textContent = "▶ Start Voice Recognition Task";
  link.style = `
    display: inline-block;
    background-color: red;
    color: black;
    font-family: monospace;
    font-weight: bold;
    padding: 6px 12px;
    border: 2px solid darkred;
    border-radius: 4px;
    cursor: pointer;
    text-decoration: none;
  `;
  link.onclick = () => {
    printAnimated(colorize("lambda > 🧠 Trigger activated. Initiating task...", "red"), 30);
    voiceRecognitionSimulatedGraphTask(targetSentence, onSuccess, onFailure, duration);
  };

  terminal.appendChild(link);
  terminal.scrollTop = terminal.scrollHeight;
}

// Task that shows a simulated waveform + listens + matches voice
function voiceRecognitionSimulatedGraphTask(targetSentence, onSuccess, onFailure, duration = 10) {
  printAnimated(colorize("lambda > Task: Speak this phrase exactly:", "red"), 30, () => {
    printAnimated(colorize(`"${targetSentence}"`, "red"), 15, async () => {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        printAnimated(colorize("lambda > ERROR: Speech recognition not supported.", "red"), 30, createInputLine);
        return;
      }

      const terminal = document.getElementById("terminal");
      const timerLine = document.createElement("div");
      timerLine.style = "color:red; font-family:monospace; white-space:pre;";
      terminal.appendChild(timerLine);

      // === Simulated Graph Canvas ===
      const canvas = document.createElement("canvas");
      canvas.width = terminal.offsetWidth - 20;
      canvas.height = 100;
      canvas.style = "background:black; border:1px solid red; display:block; margin-top:5px;";
      const ctx = canvas.getContext("2d");
      terminal.appendChild(canvas);

      // === Start drawing a simulated waveform ===
      let offset = 0;
      const drawFakeWave = setInterval(() => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath();
        ctx.strokeStyle = "red";
        for (let x = 0; x < canvas.width; x++) {
          const y = 50 + 30 * Math.sin((x + offset) * 0.05);
          x === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
        offset += 3;
        terminal.scrollTop = terminal.scrollHeight;
      }, 100);

      // === Speech Recognition Setup ===
      const recognition = new SpeechRecognition();
      recognition.lang = "en-US";
      recognition.continuous = true;
      recognition.interimResults = true;

      let finalTranscript = "";

      recognition.onresult = (event) => {
        let temp = "";
        for (let i = event.resultIndex; i < event.results.length; ++i) {
          temp += event.results[i][0].transcript + " ";
        }
        finalTranscript = temp.trim();
      };

      recognition.onerror = (e) => {
        printAnimated(colorize(`lambda > ERROR: ${e.error}`, "red"), 30, createInputLine);
        clearInterval(drawFakeWave);
        if (onFailure) onFailure();
      };

      recognition.start();

      // === Countdown Timer ===
      let elapsed = 0;
      const timer = setInterval(() => {
        elapsed++;
        const pad = s => String(s).padStart(2, '0');
        timerLine.textContent = `lambda > 🎙️ Listening... 00:${pad(elapsed)} / 00:${pad(duration)}`;
        if (elapsed >= duration) {
          clearInterval(timer);
          recognition.stop();
        }
      }, 1000);

      // === Final Check ===
      setTimeout(() => {
        clearInterval(drawFakeWave);
        clearInterval(timer);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const cleaned = finalTranscript.trim().toLowerCase();
        const reference = targetSentence.trim().toLowerCase();
        const match = calculateSimilarity(cleaned, reference);
        const matchPercent = Math.floor(match * 100);

        printAnimated(colorize(`lambda > You said: "${cleaned}"`, "red"), 30, () => {
          if (match >= 0.6) {
            printAnimated(colorize(`lambda > ✅ Match ${matchPercent}% — Accepted.`, "red"), 30, onSuccess);
          } else {
            printAnimated(colorize(`lambda > ❌ Match ${matchPercent}% — Incorrect phrase.`, "red"), 30, onFailure);
          }
        });
      }, duration * 1000);
    });
  });
}

// Very simple similarity comparison using word overlap
function calculateSimilarity(a, b) {
  const wordsA = a.split(/\s+/);
  const wordsB = b.split(/\s+/);
  let match = 0;
  wordsA.forEach(word => {
    if (wordsB.includes(word)) match++;
  });
  return match / Math.max(wordsA.length, wordsB.length);
}

</script>
<script>
  // ===============================
// ✅ 1. Count Task Entry Function
// ===============================
// Tracks how many times a specific task is triggered.
// When the threshold is reached, triggers a punishment or special function.
function countTaskEntry(taskName, threshold, onThresholdReached) {
  const key = `lambda_task_count_${taskName}`;
  let count = parseInt(localStorage.getItem(key) || "0"); // Get existing count
  count++; // Increment count
  localStorage.setItem(key, count); // Save updated count

  // Trigger your punishment/action if the count reaches the threshold
  if (count >= threshold) {
    onThresholdReached();
  }
}

// ===============================
// ✅ 2. Get Task Count Function
// ===============================
// Useful to check the current number of times a task has been triggered.

function getTaskCount(taskName) {
  return parseInt(localStorage.getItem(`lambda_task_count_${taskName}`) || "0");
}

// ===============================
// ✅ 3. Reset Specific Task Counter
// ===============================
// Call this if you want to reset the counter of a single task (like "voice-task")

function resetTaskCount(taskName) {
  localStorage.removeItem(`lambda_task_count_${taskName}`);
}

// ===============================
// ✅ 4. Global Reset of All Counters
// ===============================
// This removes all Lambda task counters from localStorage.
// Use it to fully reset progress or start fresh.
function resetAllTaskCounters() {
  Object.keys(localStorage).forEach(key => {
    if (key.startsWith("lambda_task_count_")) {
      localStorage.removeItem(key);
    }
  });
}
</script>
<script>
  function startBombLock(duration = 10) {
  const overlay = document.getElementById("bombLockOverlay");

  // Fullscreen countdown UI
  overlay.style = `
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: black;
    color: red;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-family: monospace;
    font-size: 6rem;
    z-index: 999999;
    pointer-events: none;  /* Disable ALL touch and mouse */
    user-select: none;
  `;

  overlay.innerHTML = `
    <div id="bomb-count" style="font-size: 8rem; line-height: 1;">${duration}</div>
    <div style="font-size: 2rem; margin-top: 1rem;">LOCKED</div>
  `;

  document.body.appendChild(overlay);
  overlay.style.display = "flex";

  // Request fullscreen
  const elem = overlay;
  if (elem.requestFullscreen) {
    elem.requestFullscreen();
  } else if (elem.webkitRequestFullscreen) {
    elem.webkitRequestFullscreen();
  }

  // Countdown logic with classic tick style
  let timeLeft = duration;
  const counter = document.getElementById("bomb-count");
  const timer = setInterval(() => {
    timeLeft--;
    counter.textContent = timeLeft;
    counter.style.transform = "scale(1.3)";
    counter.style.transition = "transform 0.1s ease";
    setTimeout(() => {
      counter.style.transform = "scale(1)";
    }, 100);

    if (timeLeft <= 0) {
      clearInterval(timer);
      exitFullscreen();
      overlay.style.display = "none";
    }
  }, 1000);
}

// Exit fullscreen function
function exitFullscreen() {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen();
  }
}
</script>
<!--<script>
    // ===============================
// ✅ Force Terminal into Fullscreen Mode
// ===============================
// This function tries to make the #terminal div go fullscreen.
// It checks browser support and handles both standard and WebKit methods.
function requestTerminalFullscreen() {
  const terminal = document.getElementById("terminal");

  // Only activate if not already in fullscreen
  if (!document.fullscreenElement) {
    if (terminal.requestFullscreen) {
      terminal.requestFullscreen().catch(err => {
        console.warn("Fullscreen request failed:", err.message);
      });
    } else if (terminal.webkitRequestFullscreen) {
      terminal.webkitRequestFullscreen();
    }
  }
}

// ===============================
// ✅ Monitor Fullscreen Status Every 10 Seconds
// ===============================
// This function runs in the background and checks every 10 seconds
// whether fullscreen is active. If not, it tries to re-enter fullscreen.
// Pass `force = true` to enable automatic recovery.
function monitorFullscreen(force = false) {
  setInterval(() => {
    if (!document.fullscreenElement && force) {
      requestTerminalFullscreen(); // Re-enter fullscreen if exited
    }
  }, 10000); // 🔁 Check every 10 seconds
}

// ===============================
// ✅ Initialize Fullscreen on Page Load
// ===============================
// Browsers require fullscreen to be triggered by user interaction (click).
// So we listen for the user's first click after page load and then:
// 1. Activate fullscreen
// 2. Start monitoring every 10s to ensure fullscreen stays active

window.addEventListener("load", () => {
  document.addEventListener("click", function userStart() {
    requestTerminalFullscreen();  // 🖥️ Enter fullscreen on first user click
    monitorFullscreen(true);      // 🕵️ Keep checking fullscreen every 10s
    document.removeEventListener("click", userStart); // 🔁 Only once
  });
});
</script> -->
<script>
    function ritualDeathNoteWithCode(lambdaLink = "https://your-lambda-game-link.com", onSuccess, onFailure) {
  const terminal = document.getElementById("terminal") || document.body;

  // === 1. Generate a Random Ritual Code ===
  const shareCode = "LMB-" + Math.floor(100000 + Math.random() * 900000);

  // === 2. Start Ritual Dialogue ===
  printAnimated(colorize("lambda > If you want to kill...", "red"), 30, () => {
    printAnimated(colorize("lambda > You must choose who dies.", "red"), 30, () => {
      printAnimated(colorize("lambda > Share the death note. Only then will the path open.", "red"), 30, () => {

        // === 3. Centered Red Button ===
        setTimeout(() => {
          const buttonLine = document.createElement("div");
          buttonLine.style = "text-align:center; margin-top:20px;";
          
          const button = document.createElement("button");
          button.textContent = "SHARE DEATH NOTE";
          button.style = `
            background: black;
            color: red;
            border: 2px solid red;
            padding: 10px 20px;
            font-family: monospace;
            font-size: 18px;
            cursor: pointer;
            border-radius: 8px;
          `;

          // === WhatsApp Message with Ritual Code ===
          const message = encodeURIComponent(
            `🩸 The Death Note has chosen you.\nAccept your fate:\n${lambdaLink}\n\n☠️ Ritual Code: ${shareCode}`
          );
          const shareUrl = `https://wa.me/?text=${message}`;

          button.onclick = () => {
            printAnimated(colorize("lambda > The message has been written. It must now be delivered.", "red"), 30, () => {
              window.open(shareUrl, "_blank");

              setTimeout(() => {
                printAnimated(colorize("lambda > Enter the Ritual Code to prove the message was delivered.", "red"), 30, () => {
                  // === Create code input prompt (inline check) ===
                  const inputWrap = document.createElement("div");
                  inputWrap.style = "margin-top:10px; font-family:monospace; color:red;";
                  const label = document.createElement("div");
                  label.textContent = "lambda > Enter Ritual Code:";
                  inputWrap.appendChild(label);

                  const input = document.createElement("input");
                  input.type = "text";
                  input.style = `
                    background:black;
                    color:red;
                    border:1px solid red;
                    font-family:monospace;
                    padding:5px;
                    margin-top:5px;
                    width:200px;
                  `;
                  inputWrap.appendChild(input);
                  terminal.appendChild(inputWrap);
                  terminal.scrollTop = terminal.scrollHeight;
                  input.focus();

                  input.addEventListener("keydown", (e) => {
                    if (e.key === "Enter") {
                      const entered = input.value.trim().toUpperCase();
                      if (entered === shareCode.toUpperCase()) {
                        printAnimated(colorize("lambda > ✅ Code accepted. The ritual is complete.", "red"), 30, () => {
                          if (typeof onSuccess === "function") onSuccess();
                        });
                      } else {
                        printAnimated(colorize("lambda > ❌ Invalid code. You lied to the ritual.", "red"), 30, () => {
                          if (typeof onFailure === "function") onFailure();
                        });
                      }
                    }
                  });
                });
              }, 5000);
            });
          };

          buttonLine.appendChild(button);
          terminal.appendChild(buttonLine);
          terminal.scrollTop = terminal.scrollHeight;
        }, 3000);
      });
    });
  });
}
</script>
<script>
    // === LAMBDA DEATH NOTE RITUAL (TWO-LINK SYSTEM) ===
// This function handles the entire ritual logic: share links, hide code, wait for recipient, verify code

function ritualDeathNoteWithLinkCode(lambdaGameLink, ritualCodePageLink, onSuccess, onFailure) {
  const terminal = document.getElementById("terminal") || document.body;

  // === 1. Generate a Random Ritual Code ===
  const ritualCode = "LMB-" + Math.floor(100000 + Math.random() * 900000);

  // === 2. Start the ritual dialogues ===
  printAnimated(colorize("lambda > If you want to kill...", "red"), 30, () => {
    printAnimated(colorize("lambda > You must send the curse to a soul.", "red"), 30, () => {
      printAnimated(colorize("lambda > Only when the message reaches them, the code will be revealed.", "red"), 30, () => {

        // === 3. Share Button Section ===
        setTimeout(() => {
          const buttonLine = document.createElement("div");
          buttonLine.style = "text-align:center; margin-top:20px;";

          const shareBtn = document.createElement("button");
          shareBtn.textContent = "SHARE DEATH NOTE";
          shareBtn.style = `
            background: black;
            color: red;
            border: 2px solid red;
            padding: 10px 20px;
            font-family: monospace;
            font-size: 18px;
            cursor: pointer;
            border-radius: 8px;
          `;

          shareBtn.onclick = () => {
            // === WhatsApp message with 2 separate links (NO CODE!) ===
            const message = encodeURIComponent(
              `☠️ A ritual has begun.\n\nStep into the void:\n${lambdaGameLink}\n\nRetrieve your curse seal:\n${ritualCodePageLink}?code=${ritualCode}`
            );
            const waLink = `https://wa.me/?text=${message}`;
            window.open(waLink, "_blank");

            printAnimated(colorize("lambda > The message is sent. Now confirm if they received it...", "red"), 30, () => {

              // === 4. Confirm Button to continue ===
              setTimeout(() => {
                const confirmBtn = document.createElement("button");
                confirmBtn.textContent = "I HAVE SHARED";
                confirmBtn.style = `
                  background: red;
                  color: black;
                  border: 2px solid black;
                  padding: 10px 20px;
                  font-family: monospace;
                  font-size: 18px;
                  cursor: pointer;
                  border-radius: 8px;
                  margin-top: 20px;
                `;

                confirmBtn.onclick = () => {
                  printAnimated(colorize("lambda > Ask the receiver to tell you the ritual seal...", "red"), 30, () => {
                    // === 5. Input code box ===
                    const inputWrap = document.createElement("div");
                    inputWrap.style = "margin-top:10px; font-family:monospace; color:red;";

                    const label = document.createElement("div");
                    label.textContent = "lambda > Enter Ritual Code:";
                    inputWrap.appendChild(label);

                    const input = document.createElement("input");
                    input.type = "text";
                    input.style = `
                      background:black;
                      color:red;
                      border:1px solid red;
                      font-family:monospace;
                      padding:5px;
                      margin-top:5px;
                      width:200px;
                    `;
                    inputWrap.appendChild(input);
                    terminal.appendChild(inputWrap);
                    terminal.scrollTop = terminal.scrollHeight;
                    input.focus();

                    input.addEventListener("keydown", (e) => {
                      if (e.key === "Enter") {
                        const entered = input.value.trim().toUpperCase();
                        if (entered === ritualCode.toUpperCase()) {
                          printAnimated(colorize("lambda > ✅ Code accepted. The ritual is complete.", "red"), 30, () => {
                            if (typeof onSuccess === "function") onSuccess();
                          });
                        } else {
                          printAnimated(colorize("lambda > ❌ Wrong code. The spirits reject your offering.", "red"), 30, () => {
                            if (typeof onFailure === "function") onFailure();
                          });
                        }
                      }
                    });
                  });
                };

                terminal.appendChild(confirmBtn);
                terminal.scrollTop = terminal.scrollHeight;
              }, 3000);
            });
          };

          buttonLine.appendChild(shareBtn);
          terminal.appendChild(buttonLine);
          terminal.scrollTop = terminal.scrollHeight;
        }, 2000);

      });
    });
  });
}

</script>
<script>
    /**
 * Starts a ritual where the user must watch a YouTube video and enter a hidden clue.
 * Matches the red horror terminal aesthetic exactly like the Death Note version.
 *
 * @param {string} youtubeLink - The URL of the YouTube video containing the hidden clue.
 * @param {string} correctClue - The word or clue hidden inside the video.
 * @param {function} onSuccess - Function to call if the user enters the correct clue.
 * @param {function} onFailure - Function to call if the user fails to enter the correct clue.
 */
 
function ritualVideoClueChallenge(youtubeLink = "https://www.youtube.com/watch?v=YOUR_VIDEO_ID", correctClue = "OBEY", onSuccess, onFailure) {
  // Get the terminal element or fallback to the body
  const terminal = document.getElementById("terminal") || document.body;

  // === STEP 1: Begin the ritual dialogue, printed line by line ===
  printAnimated(colorize("lambda > A vision has been revealed...", "red"), 30, () => {
    printAnimated(colorize("lambda > Watch the message carefully. A secret hides in plain sight.", "red"), 30, () => {
      printAnimated(colorize("lambda > Only the worthy shall see the clue.", "red"), 30, () => {

        // === STEP 2: Show a centered red ritual button ===
        setTimeout(() => {
          const buttonLine = document.createElement("div");
          buttonLine.style = "text-align:center; margin-top:20px;";

          // Create the button
          const button = document.createElement("button");
          button.textContent = "WATCH THE CLUE";
          button.style = `
            background: black;
            color: red;
            border: 2px solid red;
            padding: 10px 20px;
            font-family: monospace;
            font-size: 18px;
            cursor: pointer;
            border-radius: 8px;
          `;

          // === STEP 3: On button click, open YouTube video and prompt for the clue ===
          button.onclick = () => {
            // Tell the player to pay attention
            printAnimated(colorize("lambda > The vision plays now. Observe everything.", "red"), 30, () => {
              // Open the video in a new tab
              window.open(youtubeLink, "_blank");

              // Wait 5 seconds before showing the clue input
              setTimeout(() => {
                // Ask the user to enter the hidden clue they saw
                printAnimated(colorize("lambda > What did you see? Speak the hidden word.", "red"), 30, () => {
                  
                  // === STEP 4: Create an input field for the player to type the clue ===
                  const inputWrap = document.createElement("div");
                  inputWrap.style = "margin-top:10px; font-family:monospace; color:red;";
                  
                  const label = document.createElement("div");
                  label.textContent = "lambda > Enter the hidden clue:";
                  inputWrap.appendChild(label);

                  const input = document.createElement("input");
                  input.type = "text";
                  input.style = `
                    background:black;
                    color:red;
                    border:1px solid red;
                    font-family:monospace;
                    padding:5px;
                    margin-top:5px;
                    width:200px;
                  `;
                  inputWrap.appendChild(input);

                  // Append the input to the terminal
                  terminal.appendChild(inputWrap);
                  terminal.scrollTop = terminal.scrollHeight;
                  input.focus();

                  // === STEP 5: Handle user input on Enter key ===
                  input.addEventListener("keydown", (e) => {
                    if (e.key === "Enter") {
                      const entered = input.value.trim().toUpperCase(); // Normalize input

                      // === STEP 6: Check if the entered clue matches the correct clue ===
                      if (entered === correctClue.toUpperCase()) {
                        // ✅ Success - User saw the clue correctly
                        printAnimated(colorize("lambda > ✅ You have seen the truth. The ritual accepts you.", "red"), 30, () => {
                          if (typeof onSuccess === "function") onSuccess();
                        });
                      } else {
                        // ❌ Failure - Wrong or no clue detected
                        printAnimated(colorize("lambda > ❌ You failed to see. The ritual rejects you.", "red"), 30, () => {
                          if (typeof onFailure === "function") onFailure();
                        });
                      }
                    }
                  });
                });
              }, 5000); // Delay after video is opened
            });
          };

          // Add button to terminal
          buttonLine.appendChild(button);
          terminal.appendChild(buttonLine);
          terminal.scrollTop = terminal.scrollHeight;
        }, 3000); // Delay before showing the button for suspense
      });
    });
  });
}
</script>

<!-- Instagram story handling function 👇 -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
<script>
    /**
 * Performs a ritual where the user must upload a screenshot
 * of their Instagram Story containing a hidden ritual code.
 * The screenshot is verified using OCR entirely in-browser.
 *
 * @param {string} expectedCode - The ritual code the user must include in their story.
 * @param {function} onSuccess - Called when the code and Instagram reference are detected.
 * @param {function} onFailure - Called when the screenshot fails validation.
 */
function ritualInstagramScreenshotCheck(expectedCode = "LMB-666999", onSuccess, onFailure) {
  const terminal = document.getElementById("terminal") || document.body;

  // === STEP 1: Lambda Horror Dialogue Begins ===
  printAnimated(colorize("lambda > A pact requires proof.", "red"), 30, () => {
    printAnimated(colorize("lambda > You must share the mark of death in your story.", "red"), 30, () => {
      printAnimated(colorize(`lambda > Include the code: ${expectedCode}`, "red"), 30, () => {
        printAnimated(colorize("lambda > Then return here... and show us your offering.", "red"), 30, () => {

          // === STEP 2: Wait & Show File Upload Prompt ===
          setTimeout(() => {
            // Container for the file input + button
            const container = document.createElement("div");
            container.style = "margin-top: 15px; font-family: monospace; color: red;";

            const label = document.createElement("div");
            label.textContent = "lambda > Upload the screenshot of your story:";
            container.appendChild(label);

            // Hidden file input element
            const fileInput = document.createElement("input");
            fileInput.type = "file";
            fileInput.accept = "image/*";
            fileInput.style.display = "none"; // hide the ugly native input

            // Custom horror-themed file upload button
            const fileButton = document.createElement("button");
            fileButton.textContent = "CHOOSE DEATH SIGIL";
            fileButton.style = `
              background: black;
              color: red;
              border: 1px solid red;
              font-family: monospace;
              padding: 10px 20px;
              font-size: 16px;
              margin-top: 10px;
              cursor: pointer;
              border-radius: 6px;
            `;

            // Clicking the button triggers the file input
            fileButton.onclick = () => fileInput.click();

            // Add both to terminal UI
            container.appendChild(fileButton);
            container.appendChild(fileInput);
            terminal.appendChild(container);
            terminal.scrollTop = terminal.scrollHeight;

            // === STEP 3: When File Selected, Begin OCR Ritual ===
            fileInput.addEventListener("change", () => {
              const file = fileInput.files[0];
              if (!file) return;

              fileButton.textContent = file.name;

              printAnimated(colorize("lambda > The watchers are reading the sigil...", "red"), 30, () => {

                const reader = new FileReader();
                reader.onload = function () {
                  const img = new Image();
                  img.onload = function () {

                    // === STEP 4: Verify Portrait Ratio (~9:16) ===
                    const ratio = img.width / img.height;
                    const isPortrait = ratio < 0.65;
                    if (!isPortrait) {
                      printAnimated(colorize("lambda > ❌ The dimensions betray you. This is no story.", "red"), 30);
                      if (typeof onFailure === "function") onFailure();
                      return;
                    }

                    // === STEP 5: Invert Image Colors for Better OCR ===
                    const canvas = document.createElement("canvas");
                    const ctx = canvas.getContext("2d");
                    canvas.width = img.width;
                    canvas.height = img.height;

                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    for (let i = 0; i < imageData.data.length; i += 4) {
                      imageData.data[i] = 255 - imageData.data[i];       // Red
                      imageData.data[i + 1] = 255 - imageData.data[i + 1]; // Green
                      imageData.data[i + 2] = 255 - imageData.data[i + 2]; // Blue
                    }
                    ctx.putImageData(imageData, 0, 0);

                    // === STEP 6: OCR Recognition using Tesseract ===
                    Tesseract.recognize(canvas, 'eng', {
                      logger: m => console.log(m)
                    }).then(({ data: { text } }) => {
                      const extracted = text.toLowerCase();

                      // === STEP 7: Ritual Code + IG UI Clues Check ===
                      const hasCode = extracted.includes(expectedCode.toLowerCase());

                      const igClues = [
                        "share to", "highlight", "say something", "story", "18s", "viewers"
                      ];
                      const igMatchCount = igClues.filter(cue => extracted.includes(cue)).length;

                      const looksLikeIG = igMatchCount >= 2;

                      // === STEP 8: Final Judgement ===
                      if (hasCode && looksLikeIG) {
                        printAnimated(colorize("lambda > ✅ The sigil is true. The gate will open.", "red"), 30, () => {
                          if (typeof onSuccess === "function") onSuccess();
                        });
                      } else if (hasCode && !looksLikeIG) {
                        printAnimated(colorize("lambda > ⚠️ The code is true... but this is not a story.", "red"), 30, () => {
                          printAnimated(colorize("lambda > Did you think you could trick the ritual?", "red"), 30, () => {
                            if (typeof onFailure === "function") onFailure();
                          });
                        });
                      } else {
                        printAnimated(colorize("lambda > ❌ The sigil is false. The spirits turn away.", "red"), 30, () => {
                          if (typeof onFailure === "function") onFailure();
                        });
                      }

                    }).catch(() => {
                      // OCR failed
                      printAnimated(colorize("lambda > ⚠️ The veil is strong. The watchers could not read it.", "red"), 30);
                      if (typeof onFailure === "function") onFailure();
                    });
                  };

                  img.src = reader.result;
                };

                reader.readAsDataURL(file);
              });
            });
          }, 3000); // dramatic pause
        });
      });
    });
  });
}
</script>
<!-- Include this once in your HTML head -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script>
function showCreepyMapBox(containerId = "creepyMap", onLocated = () => {}) {
  const terminal = document.getElementById("terminal") || document.body;

  // === 1. Line container
  const line = document.createElement("div");
  line.style.display = "flex";
  line.style.flexDirection = "column";
  line.style.alignItems = "flex-start";
  line.style.marginTop = "10px";
  line.style.marginbottom = "10px";
  line.style.fontFamily = "monospace";
  line.style.color = "red";

  // === 2. Map Box
  const mapBox = document.createElement("div");
  mapBox.id = containerId;
  mapBox.style.width = "300px";
  mapBox.style.height = "250px";
  mapBox.style.border = "2px solid red";
  mapBox.style.marginTop = "5px";
  mapBox.style.boxShadow = "0 0 10px red";

  

  // === 3. Horror Dialogues
  const horrorLines = [
    "System breach detected...",
    "Tracking your exact location...",
    "No shadows to hide in now...",
    "You thought you were alone..."
  ];

  let i = 0;
  function animateNextLine() {
    if (i < horrorLines.length) {
      printAnimated(colorize(horrorLines[i++],"red"));
      setTimeout(animateNextLine, 1000);
    } else {
      setTimeout(loadMap, 1000);
    }
  }

  animateNextLine();
 
 line.appendChild(mapBox);
 terminal.appendChild(line);
  

  function loadMap() {
    navigator.geolocation.getCurrentPosition(
      pos => {
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;

        const map = L.map(containerId).setView([lat, lon], 16);
        L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png", {
          maxZoom: 19
        }).addTo(map);

        const marker = L.circleMarker([lat, lon], {
          radius: 8,
          color: "red",
          fillColor: "#ff0000",
          fillOpacity: 0.9
        }).addTo(map);

        marker.bindPopup("You are here... for now.").openPopup();

        // === Get Address (Reverse Geocoding)
        fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json`)
          .then(res => res.json())
          .then(data => {
            const area = data.address.suburb || data.address.neighbourhood || data.address.road || "unknown area";
            const city = data.address.city || data.address.town || data.address.village || "unknown city";
            const country = data.address.country || "unknown country";

            printAnimated(colorize(`We see you in ${area}, inside ${city}, marked on ${country}.`,"red"));
            printAnimated(colorize(`Latitude: ${lat.toFixed(6)} | Longitude: ${lon.toFixed(6)}`,"red"));
            printAnimated(colorize("No turning back now...","red"));
            onLocated(lat, lon);
          })
          .catch(() => {
            printAnimated(colorize("Location found, but we couldn't decode the city... You're still being watched.","red"));
            onLocated(lat, lon);
            setTimeout(createInputLine, 2000);
          });
      },
      err => {
        printAnimated(colorize("Location access denied. But we already know where you are.","red"));
        setTimeout(createInputLine, 1500);
      }
    );
  }
}
</script>
<script>
  const GEMINI_API_KEY = "AIzaSyBmKYvRbtzaTjp9oagN84Lf7sCl9TcIXLM"; // ← replace with your actual Gemini API key

  async function handleCMD(cmd) {
  try {
    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          contents: [
            {
              role: "user",
              parts: [{
                text: `You are VENTA: Virtual Environment for Navigational Terminal Assistance. 
You operate inside a highly advanced, futuristic CLI. 
You behave like a real terminal assistant: intelligent, responsive, ethical. 
Now process this command: ${cmd}`
              }]
            }
          ]
        })
      }
    );

    const data = await response.json();
    console.log("Gemini response:", data);

    if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
      const text = data.candidates[0].content.parts[0].text;
      printAnimated(colorize(`> ${text}`, "#ff0000"), 30, () => {
        setTimeout(createInputLine, 700);
      });
    } else if (data.error) {
      console.error("Gemini API error:", data.error);
      printAnimated(colorize(`> Gemini error: ${data.error.message}`, "#ff0000"), 30, () => {
        setTimeout(createInputLine, 700);
      });
    } else {
      printAnimated(colorize("> No response from Gemini.", "#ff0000"), 30, () => {
        setTimeout(createInputLine, 700);
      });
    }

  } catch (err) {
    console.error("Fetch error:", err);
    printAnimated(colorize("> Failed to fetch response.", "#ff0000"), 30, () => {
      setTimeout(createInputLine, 700);
    });
  }
}
</script>
<script>
    /**
 * Wraps the given sentence in a <span> with the specified font size.
 * This does NOT search the DOM; it just returns the styled string.
 * @param {string} sentence - The text to style.
 * @param {string} size - Font size, e.g., '40px', '2em'.
 * @returns {string} - HTML string with inline styling.
 */
function setSentenceSize(sentence, size) {
  return `<span style="font-size:${size}">${sentence}</span>`;
}
</script>
<script>
    /**
 * Show a red popup box with multiple sentences.
 * Appears after initialDelay, each sentence shows for 10s.
 * After last sentence, waits 10s then disappears.
 *
 * @param {Array} sentences - Sentences to show
 * @param {number} initialDelay - Delay before first appearance in ms
 */
function showRedBox(sentences, initialDelay) {
    let box = document.getElementById('redBox');
    if (!box) {
        box = document.createElement('div');
        box.id = 'redBox';
        document.body.appendChild(box);
    }

    setTimeout(() => {
        let index = 0;
        box.innerText = sentences[index];
        box.style.display = 'block';

        const interval = setInterval(() => {
            index++;
            if (index >= sentences.length) {
                clearInterval(interval);
                // after last sentence, wait 10s then hide
                setTimeout(() => {
                    box.style.display = 'none';
                }, 10000);
            } else {
                box.innerText = sentences[index];
            }
        }, 10000); // 10 seconds between sentences

    }, initialDelay);
}
</script>
<style>
#warningBox {
  display: none;
  position: fixed;
  top: 50%;           /* center vertically */
  left: 50%;          /* center horizontally */
  transform: translate(-50%, -50%);  /* shift half width & height to center */
  background-color: black;
  color: red;
  font-family: monospace;
  font-size: 9px;
  padding: 40px 20px 20px 20px;
  border: 3px solid black;
  border-radius: 8px;
  z-index: 9999;
  text-align: left;
  max-width: 90%;
  box-shadow: 0 0 20px red;
  
  animation: blinkShadow 1s infinite;
  margin-bottom: 500px;
}


/* blinking shadow animation (speed set dynamically from JS) */
@keyframes blinkShadow {
  0%   { box-shadow: 0 0 20px red; background-color: black; }
  50%  { box-shadow: 0 0 5px red; background-color: rgb(100,0,0); }
  100% { box-shadow: 0 0 20px red; background-color: black; }
}

/* ERROR label on top left */
#warningBox .errorLabel {
  position: absolute;
  top: 10px;
  left: 15px;
  font-size: 12px;
  color: red;
}

/* Timer on top right */
#warningBox .timer {
  position: absolute;
  top: 10px;
  right: 13px;
  font-size: 10px;
  color: red;
}
</style>
<script>
 /**
 * Show a blinking warning box with ERROR, timer and animated message.
 * @param {string} message - Message to show
 * @param {number} blinkSpeed - Blink speed in ms
 * @param {number} countdownSeconds - Timer in seconds
 * @param {function} callback - Called when timer ends
 */
function showWarningBox(message, blinkSpeed, countdownSeconds, callback) {
    let box = document.getElementById('warningBox');
    if (!box) {
        box = document.createElement('div');
        box.id = 'warningBox';
        
        // ERROR label (top left)
        let errorLabel = document.createElement('div');
        errorLabel.className = 'errorLabel';
        errorLabel.innerText = '⚠ ERROR';
        box.appendChild(errorLabel);
        
        // Timer (top right)
        let timer = document.createElement('div');
        timer.className = 'timer';
        timer.id = 'bombTimer';
        box.appendChild(timer);
        
        // Message container
        let messageContainer = document.createElement('div');
        messageContainer.id = 'warningMessage';
        box.appendChild(messageContainer);
        
        document.body.appendChild(box);
    }

    // Set blink speed dynamically
    box.style.animationDuration = blinkSpeed + 'ms';

    // Show box
    box.style.display = 'block';

    // Start countdown timer
    let remaining = countdownSeconds;
    const timerEl = document.getElementById('bombTimer');
    timerEl.innerText = formatTime(remaining);
    const timerInterval = setInterval(() => {
        remaining--;
        timerEl.innerText = formatTime(remaining);
        if (remaining <= 0) {
            clearInterval(timerInterval);
            if (typeof callback === 'function') {
                callback();
            }
            // Hide box after callback runs
            box.style.display = 'none';
        }
    }, 1000);

    // Animate message inside box
    printAnimatedColorize(message, 'warningMessage');
}

/**
 * Format seconds to classic timer: e.g. 00:09
 */
function formatTime(seconds) {
    const s = seconds < 10 ? '0' + seconds : seconds;
    return '00:' + s;
}

/**
 * Type text letter by letter into target element.
 */
function printAnimatedColorize(text, elementId) {
    let el = document.getElementById(elementId);
    el.innerHTML = ''; // clear previous
    let i = 0;
    let interval = setInterval(() => {
        el.innerHTML += text[i];
        i++;
        if (i >= text.length) {
            clearInterval(interval);
        }
    }, 10); // typing speed
}
</script>


    
    

<script>
let screamCanvas, screamCtx;
let screamSamples = [];
let screamMax = 0;
let screamInterval;

function micScreamTask(successMessage, failureMessage, onSuccess = null, onFail = null) {
  printAnimated(colorize("lambda > Task: Scream loudly. Reach the maximum frequency line to succeed.", "red"), 30, async () => {
    try {
      waveformStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      waveformAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const source = waveformAudioCtx.createMediaStreamSource(waveformStream);
      waveformAnalyser = waveformAudioCtx.createAnalyser();
      waveformAnalyser.fftSize = 1024;

      waveformData = new Uint8Array(waveformAnalyser.fftSize);
      source.connect(waveformAnalyser);

      // Setup scream canvas
      screamCanvas = document.createElement("canvas");
      screamCanvas.width = 320;
      screamCanvas.height = 190;
      screamCanvas.style.background = "black";
      screamCanvas.style.border = "1px solid red";
      screamCanvas.style.display = "block";
      screamCanvas.style.marginTop = "5px";

      screamCtx = screamCanvas.getContext("2d");
      document.getElementById("terminal").appendChild(screamCanvas);

      screamSamples = [];
      screamMax = 0;

      printAnimated(colorize("lambda > Listening for your scream (10 seconds)...", "red"), 30, () => {
        screamInterval = setInterval(updateScreamGraph, 100);

        setTimeout(() => {
          finishScreamCheck(successMessage, failureMessage, onSuccess, onFail);
        }, 10000);
      });
    } catch (err) {
      printAnimated(colorize("lambda > ERROR: Microphone access denied.", "red"), 30, createInputLine);
    }
  });
}

function updateScreamGraph() {
  waveformAnalyser.getByteTimeDomainData(waveformData);

  let total = 0;
  for (let i = 0; i < waveformData.length; i++) {
    total += Math.abs(waveformData[i] - 128);
  }
  const average = total / waveformData.length;
  screamSamples.push(average);
  if (average > screamMax) screamMax = average;

  // Draw axis grid
  screamCtx.clearRect(0, 0, screamCanvas.width, screamCanvas.height);
  screamCtx.strokeStyle = "gray";
  screamCtx.beginPath();

  for (let i = 0; i <= 10; i++) {
    const x = (i / 10) * screamCanvas.width;
    screamCtx.moveTo(x, 0);
    screamCtx.lineTo(x, screamCanvas.height);
  }

  for (let i = 0; i <= 5; i++) {
    const y = (i / 5) * screamCanvas.height;
    screamCtx.moveTo(0, y);
    screamCtx.lineTo(screamCanvas.width, y);
  }
  screamCtx.stroke();

  // Draw threshold line
  const thresholdY = screamCanvas.height - (65 * 2); // Y = height - threshold * amplification
  screamCtx.beginPath();
  screamCtx.strokeStyle = "red";
  screamCtx.setLineDash([5, 5]); // dashed line
  screamCtx.moveTo(0, thresholdY);
  screamCtx.lineTo(screamCanvas.width, thresholdY);
  screamCtx.stroke();
  screamCtx.setLineDash([]); // reset dash

  // Draw waveform line
  screamCtx.beginPath();
  screamCtx.strokeStyle = "red";
  for (let i = 0; i < screamSamples.length; i++) {
    const x = (i / 100) * screamCanvas.width;
    const y = screamCanvas.height - (screamSamples[i] * 2); // amplify Y
    if (i === 0) screamCtx.moveTo(x, y);
    else screamCtx.lineTo(x, y);
  }
  screamCtx.stroke();

  document.getElementById("terminal").scrollTop = terminal.scrollHeight;
}

function finishScreamCheck(successMessage, failureMessage, onSuccess, onFail) {
  clearInterval(screamInterval);
  stopWaveformMic();

  const threshold = 100; // Increased sensitivity (user must scream louder)

  setTimeout(() => {
    if (screamMax >= threshold) {
      printAnimated(colorize(successMessage || "lambda > ✅ Powerful scream detected! Success.", "red"), 30, () => {
        if (onSuccess) onSuccess();
        else createInputLine();
      });
    } else {
      printAnimated(colorize(failureMessage || "lambda > ❌ Scream not strong enough. Try harder.", "red"), 30, () => {
        if (onFail) onFail(); // Run punishment
        else createInputLine();
      });
    }
  }, 500);
}

</script>
<video id="selfieVideo" autoplay playsinline style="display:none; position:fixed; top:0; left:0; z-index:-1;"></video>
<input type="file" id="selfieUpload" accept="image/png" style="display:none;">
<style>
  .inline-terminal-button {
    display: inline-block;
    margin-left: 50px;
    margin-top: 10px;
    padding: 8px 14px;
    font-size: 14px;
    font-weight: bold;
    border: 2px solid red;
    background-color: black;
    color: red;
    border-radius: 30px;
    text-shadow: 0 0 5px red;
    box-shadow: 0 0 5px red;
    cursor: pointer;
    transition: 0.2s;
  }
   .inline-terminal-button1 {
    display: inline-block;
    margin-left: 20px;
    margin-top: 10px;
    padding: 8px 14px;
    font-size: 14px;
    font-weight: bold;
    border: 2px solid red;
    background-color: black;
    color: red;
    border-radius: 30px;
    text-shadow: 0 0 5px red;
    box-shadow: 0 0 5px red;
    cursor: pointer;
    transition: 0.2s;
  }
  .inline-terminal-button:hover {
    box-shadow: 0 0 40px red;
    background-color: #111;
  }
  .inline-terminal-button1:hover {
    box-shadow: 0 0 40px red;
    background-color: #111;
  }
  #cameraPreview {
  border: 2px solid #ff001f;
    width: 220px;
    height: auto;
    filter: brightness(0.7) contrast(1.2) sepia(0.4) hue-rotate(-20deg);
    border-radius: 10px;
    margin-top: 10px;
  }
  .inline-file-input {
    color: red;
    width: 60%;
    background: black;
    border: 2px solid red;
    border-radius: 20px;
    padding: 12px 18px;
    display: inline-block;
    margin-top: 10px;
    margin-left: 10px;
    font-size: 14px;
  }
</style>

<script>
function selfieVerificationTask(successCallback, failureCallback, onSuccessMessage, onFailureMessage) {
  printAnimated(colorize("Λ > Task: Identity verification activated.", "red"), 30, () => {
    printAnimated(colorize("Λ > Step 1: Activating camera...", "red"), 30, async () => {
      const video = document.createElement("video");
      video.setAttribute("autoplay", true);
      video.setAttribute("id", "cameraPreview");
      document.getElementById("terminal").appendChild(video);

      let stream;
      try {
        stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
      } catch (err) {
        printAnimated(colorize("Λ > ERROR: Camera access denied.", "red"), 30);
        return;
      }

      // Button for taking selfie
      const snapBtn = document.createElement("button");
      snapBtn.textContent = "📸 Take Selfie";
      snapBtn.className = "inline-terminal-button";
      document.getElementById("terminal").appendChild(snapBtn);
      
      printAnimated(colorize("Λ > ...............", "red"));

      // Snapshot logic
      snapBtn.onclick = () => {
        const canvas = document.createElement("canvas");
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext("2d");
        ctx.filter = "brightness(0.7) contrast(1.2) sepia(0.4) hue-rotate(-20deg)";
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const imageData = canvas.toDataURL("image/png");

        // Generate random filename
        const randomID = Math.floor(1000 + Math.random() * 9000);
        const selfieFileName = `lambda_selfie_${randomID}.png`;

        // Download image
        const a = document.createElement("a");
        a.href = imageData;
        a.download = selfieFileName;
        a.click();

        stream.getTracks().forEach(track => track.stop());
        video.remove();
        snapBtn.remove();

        printAnimated(colorize("Λ > Step 2: Upload the downloaded selfie for verification.", "red"), 30, () => {
          const fileInput = document.createElement("input");
          fileInput.type = "file";
          fileInput.className = "inline-file-input";
          document.getElementById("terminal").appendChild(fileInput);
         printAnimated(colorize("Λ > ................", "red"));
          fileInput.addEventListener("change", () => {
            const uploadedFile = fileInput.files[0];
            if (!uploadedFile) return;
            fileInput.remove();

            if (uploadedFile.name === selfieFileName) {
              if (onSuccessMessage) onSuccessMessage();
              if (successCallback) successCallback();
            } else {
              if (onFailureMessage) onFailureMessage();
              if (failureCallback) failureCallback();
            }
          });
        });
      };
    });
  });
}
</script>
<script>
    function timedVideoVerificationTask(durationInSeconds, successCallback, failureCallback) {
  printAnimated(colorize("Λ > Task: Timed video identity verification activated.", "red"), 30, () => {
    printAnimated(colorize("Λ > Step 1: Activating camera...", "red"), 30, async () => {
      const video = document.createElement("video");
      video.setAttribute("autoplay", true);
      video.setAttribute("id", "cameraPreview");
      document.getElementById("terminal").appendChild(video);

      let stream;
      try {
        stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        video.srcObject = stream;
      } catch (err) {
        printAnimated(colorize("Λ > ERROR: Camera access denied.", "red"), 30);
        return;
      }

      const recordBtn = document.createElement("button");
      recordBtn.textContent = "🎥 Record Timed Video";
      recordBtn.className = "inline-terminal-button1";
      document.getElementById("terminal").appendChild(recordBtn);

      let recorder;
      let chunks = [];
      const randomID = Math.floor(1000 + Math.random() * 9000);
      const videoFileName = `lambda_video_${randomID}.webm`;

      recordBtn.onclick = () => {
        if (!recorder) {
          recorder = new MediaRecorder(stream);
          recorder.ondataavailable = e => chunks.push(e.data);
          recorder.onstop = () => {
            const blob = new Blob(chunks, { type: "video/webm" });
            const url = URL.createObjectURL(blob);

            // Download the video
            const a = document.createElement("a");
            a.href = url;
            a.download = videoFileName;
            a.click();

            stream.getTracks().forEach(track => track.stop());
            video.remove();
            recordBtn.remove();

            printAnimated(colorize("Λ > Step 2: Upload the downloaded video for verification.", "red"), 30, () => {
              const fileInput = document.createElement("input");
              fileInput.type = "file";
              fileInput.className = "inline-file-input";
              document.getElementById("terminal").appendChild(fileInput);

              fileInput.addEventListener("change", () => {
                const uploadedFile = fileInput.files[0];
                if (!uploadedFile) return;
                fileInput.remove();

                if (uploadedFile.name === videoFileName) {
                  printAnimated(colorize("Λ > Match confirmed. Identity verified.", "red"), 30);
                  if (successCallback) successCallback();
                } else {
                  printAnimated(colorize("Λ > Mismatch. Identity verification failed.", "red"), 30);
                  if (failureCallback) failureCallback();
                }
              });
            });
          };

          // Start recording and stop after `durationInSeconds`
          recorder.start();
          recordBtn.disabled = true;
          printAnimated(colorize(`Λ > Recording for ${durationInSeconds} seconds...`, "red"), 30);
          setTimeout(() => {
            recorder.stop();
          }, durationInSeconds * 1000);
        }
      };
    });
  });
}
</script>

<script>
    <!-- battery percentage detection system -->
   // Battery percentage detection system
   
async function batteryDrainTest(threshold, successCallback, failureCallback) {
  printAnimated(colorize("Λ > Task: Scheduled Energy Depletion Check Initiated.", "red"), 30, () => {
    loadingBarAnimation("Λ > Connecting to internal energy sensors...", 5000, () => {
      dotLoadingAnimation("Λ > Syncing battery telemetry ", 4000, async () => {

        try {
          const battery = await navigator.getBattery();
          let percent = Math.floor(battery.level * 100);

          // Create an animation line in terminal
          let animationLine = document.createElement("div");
          animationLine.classList.add("terminal-line");
          terminal.appendChild(animationLine);

          let progress = 0;
          const batteryInterval = setInterval(() => {
            if (progress > percent) {
              clearInterval(batteryInterval);
              setTimeout(() => {
                printAnimated(colorize(`Λ > Energy Level: ${percent}%`, "red"), 30, () => {
                  if (percent < threshold) {
                    printAnimated(colorize("Λ > Energy level below survival threshold.", "red"), 30, () => {
                      printAnimated(colorize("Λ > Outcome: PASSED", "green"), 30, successCallback);
                    });
                  } else {
                    printAnimated(colorize("Λ > Energy too high for depletion protocol.", "red"), 30, () => {
                      printAnimated(colorize("Λ > Outcome: FAILED", "yellow"), 30, failureCallback);
                    });
                  }
                });
              }, 500);
            } else {
              animationLine.innerHTML = colorize(`Λ > Calculating energy... [${progress}%]`, "red");
              progress++;
            }
          }, 20);
        } catch (e) {
          printAnimated(colorize("Λ > ERROR: Unable to access battery data.", "yellow"), 30, failureCallback);
        }

      });
      printAnimated(colorize("     ", "red"));
    });
    printAnimated(colorize("     ", "red"));
  });
}
</script>

<script>
    <!-- loading animation -->
    function loadingAnimationInTerminal(message = "Λ > Loading", duration = 3000, callback) {
  const spinnerFrames = ['⠋','⠙','⠹','⠸','⠼','⠴','⠦','⠧','⠇','⠏'];
  let i = 0;

  // Create a blank line to update
  const line = document.createElement("div");
  line.classList.add("terminal-line");
  terminal.appendChild(line);

  // Auto-scroll to bottom whenever a new line is added
  terminal.scrollTop = terminal.scrollHeight;

  const interval = setInterval(() => {
    const frame = spinnerFrames[i % spinnerFrames.length];
    line.innerHTML = `<span style="color:red;">${message} ${frame}</span>`;
    i++;

    // Keep auto-scrolling while animating
    terminal.scrollTop = terminal.scrollHeight;
  }, 80);

  setTimeout(() => {
    clearInterval(interval);
    line.innerHTML = `<span style="color:red;">${message} ✔</span>`;

    // Ensure the final ✔ is visible
    terminal.scrollTop = terminal.scrollHeight;

    if (callback) callback();
  }, duration);
}

function dotLoadingAnimation(message = "Λ > Processing", duration = 3000, callback) {
  const dots = ["", ".", "..", "..."];
  let i = 0;

  const line = document.createElement("div");
  line.classList.add("terminal-line");
  terminal.appendChild(line);
  terminal.scrollTop = terminal.scrollHeight;

  const interval = setInterval(() => {
    line.innerHTML = `<span style="color:red;">${message}${dots[i % dots.length]}</span>`;
    i++;
    terminal.scrollTop = terminal.scrollHeight;
  }, 500);

  setTimeout(() => {
    clearInterval(interval);
    line.innerHTML = `<span style="color:red;">${message} ✔</span>`;
    terminal.scrollTop = terminal.scrollHeight;
    if (callback) callback();
  }, duration);
}


function loadingBarAnimation(message = "Λ > Initializing", duration = 4000, callback) {
  const barLength = 21;
  const line = document.createElement("div");
  line.classList.add("terminal-line");
  terminal.appendChild(line);
  terminal.scrollTop = terminal.scrollHeight;

  const startTime = Date.now();

  function updateBar() {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const filled = Math.round(progress * barLength);
    const empty = barLength - filled;
    const bar = "█".repeat(filled) + "░".repeat(empty);

    line.innerHTML = `<span style="color:red;">${message} [${bar}] ${Math.round(progress * 100)}%</span>`;
    terminal.scrollTop = terminal.scrollHeight;

    if (progress < 1) {
      requestAnimationFrame(updateBar);
    } else {
      line.innerHTML = `<span style="color:red;">${message} [${"█".repeat(barLength)}] 100% ✔</span>`;
      terminal.scrollTop = terminal.scrollHeight;
      if (callback) callback();
    }
  }

  updateBar();
}


function loadingBarCreepy(message = "Λ > Syncing neural cortex", duration = 5000, callback) {
  const segments = 15;
  const line = document.createElement("div");
  line.classList.add("terminal-line");
  terminal.appendChild(line);
  terminal.scrollTop = terminal.scrollHeight;

  const startTime = Date.now();

  function getBar(progress) {
    const filled = Math.round(progress * segments);
    let bar = "";
    for (let i = 0; i < segments; i++) {
      bar += i < filled ? "▮" : "▯";
    }
    return bar;
  }

  function updateBar() {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const bar = getBar(progress);
    const percent = Math.round(progress * 100);

    line.innerHTML = `<span style="color:red;">${message} [${bar}] ${percent}%</span>`;
    terminal.scrollTop = terminal.scrollHeight;

    if (progress < 1) {
      requestAnimationFrame(updateBar);
    } else {
      line.innerHTML = `<span style="color:red;">${message} [${getBar(1)}] 100% ✔</span>`;
      terminal.scrollTop = terminal.scrollHeight;
      if (callback) callback();
    }
  }

  updateBar();
}

</script>

<script>
function checkChargingStatusOnce(onCharging, onNotCharging) {
  if (!navigator.getBattery) {
    console.log("Battery API not supported.");
    return;
  }

  navigator.getBattery().then(function(battery) {
    if (battery.charging) {
      if (typeof onCharging === 'function') onCharging();
    } else {
      if (typeof onNotCharging === 'function') onNotCharging();
    }
  });
}

function usbCheckCommand() {
  checkChargingStatusOnce(
    () => {
      printAnimated(colorize("Λ > External power detected...\nThis isn’t your choice, is it?", "red"), 30);
    },
    () => {
      printAnimated(colorize("Λ > No power... exactly how we like it.", "red"), 30);
    }
  );
}
</script>





 
<!-- Load html2canvas -->
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

<script>
/**
 * Generate a unique random filename using date + ID.
 */
function generateRandomFilename() {
  const now = new Date();
  const timestamp = now.toISOString().replace(/[-:.TZ]/g, '').slice(0, 14);
  const randomId = Math.random().toString(36).substring(2, 8);
  return `terminal_capture_${timestamp}_${randomId}.png`;
}

/**
 * Captures the entire content inside the terminal (even if scrollable)
 * and saves it as a PNG image with a random filename.
 * @param {string} selector - The CSS selector of your terminal div.
 */
function captureFullTerminal(selector = '#terminal') {
  const terminal = document.querySelector(selector);

  if (!terminal) {
    console.error('❌ Terminal element not found:', selector);
    return;
  }

  // Temporarily expand terminal to full height so html2canvas can capture it all
  const originalHeight = terminal.style.height;
  terminal.style.height = terminal.scrollHeight + 'px';

  html2canvas(terminal, {
    useCORS: true,
    allowTaint: true,
    backgroundColor: null,
    width: terminal.scrollWidth,
    height: terminal.scrollHeight,
    windowWidth: terminal.scrollWidth,
    windowHeight: terminal.scrollHeight,
  }).then(canvas => {
    const imageData = canvas.toDataURL('image/png');
    const filename = generateRandomFilename();

    const link = document.createElement('a');
    link.href = imageData;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    // Reset terminal height
    terminal.style.height = originalHeight;

    console.log('✅ Terminal screenshot saved:', filename);
  }).catch(error => {
    console.error('❌ Screenshot capture failed:', error);
  });
}
</script>













<style>
body {
  margin: 0;
  background: black;
  color: white;
  overflow-x: hidden;
}
    
#sidePanel {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  position: fixed;
  top: 5%;
  right: -300px; /* start hidden */
  width: 300px;
  height: 70%;
  background: rgba(255, 255, 255, 0.1); /* transparent glass */
  border: 5px solid rgba(255, 255, 255, 0.2);
  transition: right 0.3s ease;
  display: flex;
  flex-direction: column;
  z-index: 9999; /* make sure it's on top */

  /* 🌟 Glassmorphism effect */
  backdrop-filter: blur(15px) saturate(180%);
  -webkit-backdrop-filter: blur(15px) saturate(180%);
  box-shadow: -4px 0 20px rgba(0, 0, 0, 0.5); 
  border-radius: 30px;
}

#chatMessages {
  flex: 1;
  padding: 10px;
  overflow-y: auto;
}

/* 🌟 Add this block to enable bold, italic, underline, colors, and line breaks */
#chatMessages span {
  font-weight: normal;      /* JS can override to bold */
  font-style: normal;       /* JS can override to italic */
  text-decoration: none;    /* JS can override to underline */
  color: inherit;           /* JS can override color */
  white-space: pre-wrap;    /* respect \n for line breaks */
}

/* Optional: allow emojis to scale nicely */
#chatMessages span img, 
#chatMessages span.emoji {
  width: 1em;
  height: 1em;
  vertical-align: middle;
}

#chatInputArea {
  display: flex;
  border-top: 1px solid #333;
}

#chatInput {
  flex: 1;
  padding: 8px;
  border: none;
  outline: none;
  background: #222;
  color: white;
  resize: none;
  height: 40px;
  margin: 7px;

  background: rgba(255, 255, 255, 0.1); /* transparent glass */
  border: 3px solid rgba(255, 255, 255, 0.2);
  transition: right 0.3s ease;

  /* 🌟 Glassmorphism effect */
  backdrop-filter: blur(15px) saturate(180%);
  -webkit-backdrop-filter: blur(15px) saturate(180%);
  box-shadow: -4px 0 20px rgba(0, 0, 0, 0.5); 
  border-radius: 30px;
}

#sendBtn {
  background: #444;
  border: none;
  color: white;
  padding: 8px 12px;
  cursor: pointer;
  margin: 7px;
  background: rgba(255, 255, 255, 0.1); /* transparent glass */
  border: 3px solid rgba(255, 255, 255, 0.2);
  transition: right 0.3s ease;

  /* 🌟 Glassmorphism effect */
  backdrop-filter: blur(15px) saturate(180%);
  -webkit-backdrop-filter: blur(15px) saturate(180%);
  box-shadow: -4px 0 20px rgba(0, 0, 0, 0.5); 
  border-radius: 30px;
}
</style>

<div id="main-content">
<div id="sidePanel">
  <div id="chatMessages"></div>
  <div id="chatInputArea">
    <textarea id="chatInput" placeholder="Type..."></textarea>
    <button id="sendBtn">Send</button>
  </div>
</div>

<input type="file" id="pdfInput" accept="application/pdf" style="display:none;">
</div>
<script>
    
    
    function fadeInText(id, duration = 2000) {
    const element = document.getElementById(id);
    if (!element) return;

    let start = null;

    function step(timestamp) {
        if (!start) start = timestamp;
        let progress = timestamp - start;
        // Calculate opacity from 0 (invisible) to 1 (fully visible)
        let opacity = Math.min(progress / duration, 1);
        element.style.opacity = opacity;
        if (progress < duration) {
            requestAnimationFrame(step);
        }
    }

    // Start fully transparent
    element.style.opacity = 0;
    requestAnimationFrame(step);
}



document.addEventListener('DOMContentLoaded', () => {
  const sidePanel = document.getElementById('sidePanel');
  const chatMessages = document.getElementById('chatMessages');
  const chatInput = document.getElementById('chatInput');
  const sendBtn = document.getElementById('sendBtn');

  if (!sidePanel || !chatMessages || !chatInput || !sendBtn) {
    console.warn('Missing one of: sidePanel, chatMessages, chatInput, sendBtn');
    return;
  }

  // =========================
  // PANEL OPEN / CLOSE
  // =========================
  function isPanelOpen() {
    return sidePanel.classList.contains('open');
  }

  function openPanel() {
    sidePanel.style.right = '0px';
    sidePanel.classList.add('open');

    chatInput.style.display = '';
    chatInput.disabled = false;
    chatInput.tabIndex = 0;
    chatInput.setAttribute('aria-hidden', 'false');

    sendBtn.style.display = '';
    sendBtn.disabled = false;
  }

  function closePanel() {
    sidePanel.style.right = '-300px';
    sidePanel.classList.remove('open');

    try { chatInput.blur(); } catch(e) {}
    chatInput.disabled = true;
    chatInput.tabIndex = -1;
    chatInput.style.display = 'none';
    chatInput.setAttribute('aria-hidden', 'true');

    sendBtn.style.display = 'none';
    sendBtn.disabled = true;
  }

  closePanel();

  // =========================
  // TYPING ANIMATION
  // =========================
  const emojiDict = { ":smile:":"😄", ":fire:":"🔥", ":heart:":"❤️", ":star:":"⭐" };

  function addText(message, callback) {
  const msg = document.createElement('div');
  chatMessages.appendChild(msg);

  const parts = [];
  const regex = /(\*\*(.*?)\*\*|_(.*?)_|__(.*?)__|\{(#[0-9a-fA-F]{3,6}|[a-zA-Z]+)(:(\d+):)?:(.*?)\}|:[a-zA-Z_]+:)/g;
  let lastIndex = 0, match;

  while ((match = regex.exec(message)) !== null) {
    if (match.index > lastIndex) parts.push({ text: message.slice(lastIndex, match.index) });
    if (match[2]) parts.push({ text: match[2], bold:true });
    else if (match[3]) parts.push({ text: match[3], italic:true });
    else if (match[4]) parts.push({ text: match[4], underline:true });
    else if (match[5]) {
      const color = match[5];
      const speed = match[7]?parseInt(match[7]):30;
      parts.push({ text: match[8], color, speed });
    } else if (match[0].startsWith(":") && match[0].endsWith(":")) {
      const emoji = emojiDict[match[0]] || match[0];
      parts.push({ text: emoji });
    }
    lastIndex = regex.lastIndex;
  }

  if (lastIndex < message.length) parts.push({ text: message.slice(lastIndex) });

  let partIndex = 0, charIndex = 0;

  function type() {
    if (partIndex >= parts.length) {
      if (callback) callback(); // ✅ call callback when finished
      return;
    }

    const part = parts[partIndex];

    if (!msg.children[partIndex]) {
      const span = document.createElement('span');
      if (part.bold) span.style.fontWeight = 'bold';
      if (part.italic) span.style.fontStyle = 'italic';
      if (part.underline) span.style.textDecoration = 'underline';
      if (part.color) span.style.color = part.color;
      msg.appendChild(span);
    }

    const span = msg.children[partIndex];
    const char = part.text.charAt(charIndex);

    if (char === "\n") span.innerHTML += "<br>";
    else span.innerHTML += char;

    charIndex++;
    chatMessages.scrollTop = chatMessages.scrollHeight;

    const delay = part.speed || 30;

    if (charIndex < part.text.length) setTimeout(type, delay);
    else {
      partIndex++;
      charIndex = 0;
      setTimeout(type, 0); // start next part immediately
    }
  }

  type();
}
  // =========================
  // COMMAND HANDLER
  // =========================
  sendBtn.addEventListener('click', () => {
    const input = (chatInput.value || '').trim();
    if (!input) return;
    addText('> ' + input);
    handleSideCommand(input);
    chatInput.value = '';
  });

  function handleSideCommand(cmd) {
    switch(cmd.toLowerCase()){
      case 'hello': addText('Hi there!'); break;
      case 'close': closePanel(); break;
      case 'open': openPanel(); break;
      case 'video': playVideoInPanel('birthday.mp4'); break;
      case 'youtube': playYouTubeVideoInPanel('https://www.youtube.com/watch?v=pd6Aw5TCwlE'); break;
      case 'image': showImageInPanel('3d-birthday-cake-with-candles-and-decorations-pink-cake-emoji-party-surprise-two-tier-wedding.jpg'); break;
      case 'image1': showImageInPanel('Screenshot_20250825_143344_TrebEdit.jpg'); break;
      case 'image2': showImageInPanel('3d-birthday-cake-with-candles-and-decorations-pink-cake-emoji-party-surprise-two-tier-wedding.jpg');
      break;
      
      
      case 'pdf': showPDFInPanel('https://example.com/sample.pdf'); break;
      case 'pdf1': selectAndShowPDF(); break;
      default: addText('Unknown command.');
    }
  }

  // =========================
  // MEDIA HELPERS
  // =========================
  function playVideoInPanel(url) {
    const videoEl=document.createElement('video');
    videoEl.src=url; videoEl.controls=true; videoEl.width=250; videoEl.height=140;
    videoEl.autoplay=false; videoEl.style.background='rgba(255,255,255,0.1)';
    videoEl.style.border='3px solid rgba(255,255,255,0.2)'; videoEl.style.borderRadius='10px';
    videoEl.style.display='block'; videoEl.style.margin='8px 0';
    chatMessages.appendChild(videoEl); chatMessages.scrollTop=chatMessages.scrollHeight;
  }

  function playYouTubeVideoInPanel(youtubeUrl) {
    const iframeEl=document.createElement('iframe');
    iframeEl.width=250; iframeEl.height=140; iframeEl.style.border='3px solid rgba(255,255,255,0.2)';
    iframeEl.style.borderRadius='10px'; iframeEl.style.display='block'; iframeEl.style.margin='8px 0';
    iframeEl.allow="autoplay; encrypted-media";
    const videoId = youtubeUrl.split('v=')[1].split('&')[0];
    iframeEl.src=`https://www.youtube.com/embed/${videoId}?autoplay=1`;
    chatMessages.appendChild(iframeEl); chatMessages.scrollTop=chatMessages.scrollHeight;
  }

  function showImageInPanel(imageUrl){
    const imgEl=document.createElement('img'); imgEl.src=imageUrl;
    imgEl.style.border='4px solid rgba(255,255,255,0.2)'; imgEl.style.borderRadius='10px';
    imgEl.style.display='block'; imgEl.style.margin='8px 0'; imgEl.style.background='black';
    imgEl.style.maxWidth='95%'; imgEl.style.height='auto';
    chatMessages.appendChild(imgEl); chatMessages.scrollTop=chatMessages.scrollHeight;
  }

  function showPDFInPanel(pdfUrl){
    const pdfEl=document.createElement('iframe'); pdfEl.src=pdfUrl; pdfEl.width='250'; pdfEl.height='300';
    pdfEl.style.border='3px solid rgba(255,255,255,0.2)'; pdfEl.style.borderRadius='10px';
    pdfEl.style.display='block'; pdfEl.style.margin='8px 0';
    chatMessages.appendChild(pdfEl); chatMessages.scrollTop=chatMessages.scrollHeight;
  }

  function selectAndShowPDF(){
    const pdfInput=document.getElementById('pdfInput'); if(!pdfInput) return;
    pdfInput.value='';
    pdfInput.onchange=(e)=>{ const file=e.target.files[0]; if(!file)return;
      const fileURL=URL.createObjectURL(file); showPDFInPanel1(fileURL); };
    pdfInput.click();
  }

  function showPDFInPanel1(pdfUrl){
    const iframeEl=document.createElement('iframe'); iframeEl.width='250'; iframeEl.height='300';
    iframeEl.style.border='3px solid rgba(255,255,255,0.2)'; iframeEl.style.borderRadius='10px';
    iframeEl.style.display='block'; iframeEl.style.margin='8px 0'; iframeEl.style.background='black';
    iframeEl.src=`https://docs.google.com/gview?url=${encodeURIComponent(pdfUrl)}&embedded=true`;
    chatMessages.appendChild(iframeEl); chatMessages.scrollTop=chatMessages.scrollHeight;
  }

  // =========================
  // WELCOME MESSAGE
  // =========================
function showWelcomeMessage() {
  addText("Welcome to **Lambda Neural Terminal Assistant**\n\n", () => {
    addText("If you are here, we assume you have the proper permission to access this system. If you do not have authorization, please be aware that unauthorized access may violate **copyright and legal laws**.\n\n", () => {
      addText("If you do have permission, then I am your assistant. This panel you are accessing right now is your **Media Manager and Helper**, designed to provide all necessary assistance within this terminal.\n\n", () => {
        addText("To continue your experience and access the game, you must first allow all necessary permissions. If your system gets stuck in a loop, you may need to manually manage permissions. For guidance, type **permission help** to access the tutorial video.\n\n", () => {
          addText("Please note, this Neural Terminal Assistant and its gaming system are currently in development. You may encounter occasional glitches or issues. Right now, you can experience a few **AI-driven tasks** and interact with the **CI (Command Interface)**.\n\n", () => {
            addText("For a full list of commands and detailed guidance, type **help** in the main terminal. The system is expected to be fully developed by the last month of 2026.\n\n", () => {
              addText("The most exciting part: if you are authorized and successfully complete this challenge, you may become the owner of this entire Neural Terminal Assistant system, gaining full control over this virtual system.\n\n", () => {
                addText("Remember, this terminal executes commands, while I—powered by the **Gemini API**—handle all questions, responses, and required guidance.\n\n", () => {
                  addText("Prepare yourself. Permission granted or not, your journey **begins here**.");
                });
              });
            });
          });
        });
      });
    });
  });
}
  // =========================
  // GLOBAL EXPOSE
  // =========================
  window.openPanel = openPanel;
  window.closePanel = closePanel;
  window.addText = addText;
  window.showWelcomeMessage = showWelcomeMessage;

  // =========================
  // KEYBOARD + TOUCH EVENTS
  // =========================
  document.addEventListener('keydown', (e) => {
    if(e.key!=='Enter') return;
    const inputVisible=!chatInput.disabled && chatInput.style.display!=='none' && isPanelOpen();
    if(inputVisible && document.activeElement===chatInput){ e.preventDefault(); return; }
    e.preventDefault(); 
    if(typeof runMainTerminalCommand==='function') runMainTerminalCommand();
  });

  let startX=0;
  document.addEventListener('touchstart',(e)=>{if(e.touches && e.touches[0]) startX=e.touches[0].clientX;});
  document.addEventListener('touchend',(e)=>{if(!e.changedTouches||!e.changedTouches[0]) return; const endX=e.changedTouches[0].clientX; const diff=endX-startX;
    if(diff<-50 && !isPanelOpen()) openPanel();
    if(diff>50 && isPanelOpen()) closePanel();
  });
 });
 
 
 
  // =========================
  // AUTO SHOW WELCOME MESSAGE
  // =========================
  
  
  setTimeout(() => { 
        showWelcomeMessage(); // <- your advert message
      }, 5000);
    
    
    
   function showWelcomeOnce() {
  const key = "welcomeShown1";

  if (!localStorage.getItem(key)) {
    // 👇 Your one-time advert / welcome logic
    alert("🎉 Welcome! This is your first visit.");
  
    setTimeout(() => {
      openPanel(); // <- your advert panel
      setTimeout(() => { 
        showWelcomeMessage(); // <- your advert message
      }, 5000);
    }, 30000);
 

    // ✅ Mark as shown so it never runs again
    localStorage.setItem(key, "true");
  }
}
    
  
  </script>







    <style>
      /* Body and overall page settings */
        body {
            margin: 0;
           
            overflow: hidden; /* Prevents scrolling while the splash screen is active */
            transition: opacity 1s ease-in-out;
        }

        /* Splash Screen Styles */
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensures the splash screen is on top of everything */
            transition: opacity 1s ease-in-out;
        }

        #splash-screen.hidden {
            opacity: 0;
            pointer-events: none; /* Disables clicks on the hidden element */
        }

        #splash-screen img {
            max-width: 80%;
            max-height: 80%;
        }

        /* Main Content Styles */
        #main-content {
            display: none; /* Hides the content initially */
            
        }

        /* Add all of your other 4000 lines of CSS here */
        /* ... */

    </style>


    <div id="splash-screen">
        <img src="logo.jpg" alt="Your Company Logo">
    </div>

    

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const splashScreen = document.getElementById('splash-screen');
            const mainContent = document.getElementById('main-content');
            
            const splashDuration = 3000; // 3 seconds

            // Hide the splash screen after the set duration
            setTimeout(() => {
                splashScreen.classList.add('hidden');
            }, splashDuration);

            // Wait a little longer to ensure the fade-out starts before showing content
            setTimeout(() => {
                mainContent.style.display = 'block';
                runMainFunctions();
            }, splashDuration + 20000); // 500ms delay for a smooth transition

        });

        // The function that holds all of your main website's scripts
        function runMainFunctions() {
            // Put all your existing JavaScript functions and logic here (your 4000 lines)
            console.log("Main website functions are now running!");
            // For example: initializeAnimations(); loadData(); etc.
        }
    </script>






<script>
    (async () => {
        // =========================
        // Core Dependencies (TensorFlow.js)
        // =========================
        async function loadTensorFlow() {
            if (window.tf && window.blazeface) return;
            await new Promise(resolve => {
                const script = document.createElement('script');
                script.src = "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest";
                script.onload = resolve;
                document.head.appendChild(script);
            });
            await new Promise(resolve => {
                const script = document.createElement('script');
                script.src = "https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface";
                script.onload = resolve;
                document.head.appendChild(script);
            });
        }

        // =========================
        // Global State & UI Elements
        // =========================
        let model = null;
        let videoEl = null;
        let canvasEl = null;
        const terminal = document.getElementById('terminal');
        const faceDatabase = JSON.parse(localStorage.getItem('faceDatabase')) || {};

        if (!terminal) {
            console.error('Terminal element not found.');
            return;
        }

        function colorize(text) {
            return `\x1b[32m${text}\x1b[0m`;
        }

        async function printAnimated(text) {
            return new Promise(resolve => {
                const p = document.createElement('p');
                p.textContent = text;
                terminal.appendChild(p);
                terminal.scrollTop = terminal.scrollHeight;
                setTimeout(resolve, text.length * 10);
            });
        }

        function print(message) {
            printAnimated(colorize(message));
        }

        function createInfoElement(info) {
            const div = document.createElement('div');
            div.innerHTML = `<p style="margin: 0;">Unique ID: ${info.id}</p><p style="margin: 0;">Name: ${info.name}</p>`;
            div.style.padding = '10px';
            div.style.border = '1px solid #00ff00';
            div.style.borderRadius = '8px';
            div.style.margin = '10px auto';
            div.style.width = 'fit-content';
            terminal.appendChild(div);
            return div;
        }

        function createFaceImageElement(imageData) {
            const img = document.createElement('img');
            img.src = imageData;
            img.style.width = '60px';
            img.style.height = '60px';
            img.style.borderRadius = '50%';
            img.style.border = '2px solid #00ff00';
            img.style.margin = '10px auto';
            terminal.appendChild(img);
            return img;
        }

        // =========================
        // Face Recognition & Storage Logic
        // =========================
        function saveFacesToStorage() {
            localStorage.setItem('faceDatabase', JSON.stringify(faceDatabase));
        }

        function findMatchingFace(descriptor) {
            for (const id in faceDatabase) {
                if (faceDatabase[id].descriptor === descriptor) {
                    return faceDatabase[id];
                }
            }
            return null;
        }
        
        function captureFaceImage(video, detections) {
            if (!detections || detections.length === 0) return null;
            const tempCanvas = document.createElement('canvas');
            const box = detections[0].boundingBox;
            tempCanvas.width = box.width;
            tempCanvas.height = box.height;
            const ctx = tempCanvas.getContext('2d');
            ctx.drawImage(video, box.topLeft[0], box.topLeft[1], box.bottomRight[0] - box.topLeft[0], box.bottomRight[1] - box.topLeft[1], 0, 0, box.width, box.height);
            return tempCanvas.toDataURL('image/png');
        }

        async function getFaceDataOnce() {
            return new Promise((resolve, reject) => {
                const startTime = Date.now();
                const checkFace = async () => {
                    const predictions = await model.estimateFaces(videoEl);
                    if (predictions.length > 0) {
                        const descriptor = JSON.stringify(predictions[0].boundingBox);
                        resolve({ image: captureFaceImage(videoEl, predictions), descriptor: descriptor });
                    } else if (Date.now() - startTime > 5000) {
                        reject(new Error("Timeout: No face detected."));
                    } else {
                        requestAnimationFrame(checkFace);
                    }
                };
                checkFace();
            });
        }

        // =========================
        // Application Flow
        // =========================
        async function setupWebcam() {
            const container = document.createElement('div');
            container.style.width = '320px';
            container.style.height = '240px';
            container.style.border = '2px solid #00ff00';
            container.style.borderRadius = '8px';
            container.style.position = 'relative';
            container.style.display = 'flex';
            container.style.justifyContent = 'center';
            container.style.overflow = 'hidden';
            videoEl = document.createElement('video');
            videoEl.width = 320;
            videoEl.height = 240;
            videoEl.autoplay = true;
            videoEl.playsInline = true;
            videoEl.style.position = 'absolute';
            videoEl.style.top = '0';
            videoEl.style.left = '0';
            videoEl.style.objectFit = 'cover';
            canvasEl = document.createElement('canvas');
            canvasEl.width = 320;
            canvasEl.height = 240;
            canvasEl.style.position = 'absolute';
            canvasEl.style.top = '0';
            canvasEl.style.left = '0';
            container.appendChild(videoEl);
            container.appendChild(canvasEl);
            terminal.appendChild(container);
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                videoEl.srcObject = stream;
                return new Promise(resolve => {
                    videoEl.onplay = () => resolve();
                });
            } catch (err) {
                print(`Error: Webcam access denied.`);
                throw err;
            }
        }
        
        function startLiveDetection() {
            const ctx = canvasEl.getContext('2d');
            function renderPrediction() {
                if (videoEl && model) {
                    model.estimateFaces(videoEl).then(predictions => {
                        ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
                        ctx.drawImage(videoEl, 0, 0, canvasEl.width, canvasEl.height);
                        if (predictions.length > 0) {
                            predictions.forEach(prediction => {
                                const box = prediction.boundingBox;
                                ctx.beginPath();
                                ctx.rect(box.topLeft[0], box.topLeft[1], box.bottomRight[0] - box.topLeft[0], box.bottomRight[1] - box.topLeft[1]);
                                ctx.strokeStyle = '#00FF00';
                                ctx.lineWidth = 2;
                                ctx.stroke();
                            });
                        }
                    });
                }
                requestAnimationFrame(renderPrediction);
            }
            renderPrediction();
        }

        async function enrollFace() {
            print("Analyzing... Please look at the camera for 5 seconds.");
            
            const faceData = await getFaceDataOnce();
            
            const existingFace = findMatchingFace(faceData.descriptor);
            if (existingFace) {
                print("This face is already enrolled. Details below:");
                createFaceImageElement(existingFace.faceImage);
                createInfoElement(existingFace);
                return;
            }

            print("Face is unique. Let's enroll you.");
            createFaceImageElement(faceData.image);

            const name = prompt("Please enter your name:");
            const password = prompt("Please enter your password:");
            const uniqueId = "user-" + Date.now();

            faceDatabase[uniqueId] = { id: uniqueId, name, password, faceImage: faceData.image, descriptor: faceData.descriptor };
            saveFacesToStorage();

            print("Enrollment complete!");
            createInfoElement(faceDatabase[uniqueId]);
        }

        async function verifyFace() {
            print("Analyzing... Please look at the camera for 5 seconds.");
            
            const faceData = await getFaceDataOnce();
            const existingFace = findMatchingFace(faceData.descriptor);

            if (existingFace) {
                print("Face matched! Access granted.");
                createInfoElement(existingFace);
                createFaceImageElement(existingFace.faceImage);
            } else {
                print("Face not recognized. You are unique!");
                createFaceImageElement(faceData.image);
                const shouldEnroll = confirm("This face is not enrolled. Would you like to enroll it now?");
                if (shouldEnroll) {
                    const name = prompt("Please enter your name:");
                    const password = prompt("Please enter your password:");
                    const uniqueId = "user-" + Date.now();
                    faceDatabase[uniqueId] = { id: uniqueId, name, password, faceImage: faceData.image, descriptor: faceData.descriptor };
                    saveFacesToStorage();
                    print("Enrollment complete!");
                    createInfoElement(faceDatabase[uniqueId]);
                } else {
                    print("Enrollment canceled.");
                }
            }
        }

        // =========================
        // New Main Function
        // =========================
        window.startFaceRecognition = async () => {
            print("Starting face recognition system...");
            try {
                await loadTensorFlow();
                model = await blazeface.load();
                print("Models loaded successfully.");
                
                await setupWebcam();
                startLiveDetection();
                print("Webcam active. Scanning for faces...");
                
                const buttonContainer = document.createElement('div');
                buttonContainer.style.display = 'flex';
                buttonContainer.style.justifyContent = 'space-around';
                buttonContainer.style.marginTop = '10px';

                const enrollBtn = document.createElement('button');
                enrollBtn.textContent = 'Enroll';
                enrollBtn.style.padding = '8px 16px';
                enrollBtn.style.backgroundColor = '#00ff00';
                enrollBtn.style.color = '#000000';
                enrollBtn.style.border = 'none';
                enrollBtn.style.borderRadius = '4px';
                enrollBtn.onclick = enrollFace;

                const verifyBtn = document.createElement('button');
                verifyBtn.textContent = 'Verify';
                verifyBtn.style.padding = '8px 16px';
                verifyBtn.style.backgroundColor = '#00ff00';
                verifyBtn.style.color = '#000000';
                verifyBtn.style.border = 'none';
                verifyBtn.style.borderRadius = '4px';
                verifyBtn.onclick = verifyFace;

                buttonContainer.appendChild(enrollBtn);
                buttonContainer.appendChild(verifyBtn);
                terminal.appendChild(buttonContainer);

                print("System is ready. Use the buttons to begin.");
            } catch (error) {
                print(`Fatal Error: Could not start the system. Error: ${error.message}`);
            }
        };
    })();
</script>


<!-- Video feed -->
<!-- Existing elements in your HTML -->
<div id="terminal-output"></div>
<div id="video-container">
  <video id="video-feed" autoplay muted></video>
  <canvas id="canvas-overlay"></canvas>
</div>

<script defer src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
<script>
/**
 * Complete Face Recognition System
 * Features:
 * 1. Shows camera output immediately
 * 2. Supports default faces with callbacks
 * 3. Supports enrolled users stored in localStorage
 * 4. Menu: verify | enroll | show users | clear history | exit
 * 5. Face lock: specific function runs for recognized users
 */

async function faceRecognitionTask(callbacks = {}, defaultFacesConfig = {}) {
  const terminalContainer = document.getElementById("terminal");
  const MODEL_URL = 'https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights';

  let enrolledUsers = JSON.parse(localStorage.getItem('faceUsers') || '{}');

  const video = document.createElement("video");
  video.setAttribute("autoplay", true);
  video.setAttribute("muted", true);
  video.style.width = "50%";
  video.style.maxWidth = "240px";
  video.style.border = "1px solid #00ff00";

  const canvas = document.createElement("canvas");
  canvas.style.position = "absolute";
  canvas.style.width = "50%";
  canvas.style.maxWidth = "240px";
  canvas.style.border = "1px solid #00ff00";

 /* function printAnimated(text, callback) {
    const line = document.createElement("div");
    line.innerHTML = text;
    terminalContainer.appendChild(line);
    terminalContainer.scrollTop = terminalContainer.scrollHeight;
    if (callback) callback();
  }*/

  printAnimated(colorize("Λ > Welcome to the face recognition system.", "red"), () => {
    printAnimated(colorize("Λ > Loading face recognition models...", "red"), async () => {

      await Promise.all([
        faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
        faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
        faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL)
      ]);

      printAnimated(colorize("Λ > Models loaded successfully.", "red"), async () => {
        terminalContainer.appendChild(video);
        terminalContainer.appendChild(canvas);

        await startCamera();
        const defaultFaces = await loadDefaultFaces(defaultFacesConfig);

        detectFaceLoop(video, canvas);
        showMainMenu();

        async function startCamera() {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            await new Promise(resolve => video.onloadedmetadata = resolve);
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
          } catch (err) {
            printAnimated(colorize("Λ > ERROR: Camera access denied.", "red"));
            console.error(err);
          }
        }

        async function loadDefaultFaces(defaults) {
          const loadedDefaults = {};
          for (const username in defaults) {
            try {
              const img = await faceapi.fetchImage(defaults[username].imgPath);
              const detection = await faceapi.detectSingleFace(img, new faceapi.TinyFaceDetectorOptions())
                .withFaceLandmarks()
                .withFaceDescriptor();
              if (detection) {
                loadedDefaults[username] = {
                  descriptor: detection.descriptor,
                  callback: defaults[username].callback
                };
              } else {
                console.warn(`Could not detect face for default user: ${username}`);
              }
            } catch (e) {
              console.error(`Error loading default face ${username}:`, e);
            }
          }
          return loadedDefaults;
        }

        function showMainMenu() {
          printAnimated(colorize("Λ > Options: verify | enroll | show users | clear history | exit", "red"));
          createFaceCmdLine(handleMenuCommand);
        }

        function createFaceCmdLine(callback) {
  const line = document.createElement('div');
  line.className = 'face-input-line';

  const prompt = document.createElement('span');
  prompt.className = 'prompt';
  prompt.style.color = '#00ff00';
  prompt.textContent = 'Λ@root:~$ ';

  // ✅ Use input instead of contentEditable span
  const input = document.createElement('input');
  input.className = 'face-input';
  input.type = 'text';
  input.style.background = 'transparent';
  input.style.border = 'none';
  input.style.outline = 'none';
  input.style.color = '#fff';
  input.style.fontFamily = 'monospace';
  input.style.width = '70%';

  line.appendChild(prompt);
  line.appendChild(input);
  terminalContainer.appendChild(line);

  // Always focus → keyboard pops instantly on mobile
  setTimeout(() => input.focus(), 50);

  input.addEventListener('keydown', function (e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      const command = input.value.trim();
      input.disabled = true; // prevent editing old command
      callback(command);
    }
  });


          terminalContainer.scrollTop = terminalContainer.scrollHeight;
        }

        function handleMenuCommand(command) {
          const lower = command.toLowerCase();
          switch (lower) {
            case 'verify':
              startVerification();
              break;
            case 'enroll':
              startEnrollment();
              break;
            case 'show users':
              printAnimated(colorize("Λ > Enrolled users: " + Object.keys(enrolledUsers).join(", "), "red"));
              showMainMenu();
              break;
            case 'clear history':
              enrolledUsers = {};
              localStorage.setItem('faceUsers', JSON.stringify(enrolledUsers));
              printAnimated(colorize("Λ > Cleared all enrolled users.", "red"));
              showMainMenu();
              break;
            case 'exit':
              printAnimated(colorize("Λ > Exiting face recognition system...", "red"), () => {
                stopFaceDetection(video, canvas);
                setTimeout(createInputLine, 500);
              });
              break;
            default:
              printAnimated(colorize("Λ > Unknown command: " + command, "red"));
              showMainMenu();
              break;
          }
        }

        // ✅ Optimized detection loop using requestAnimationFrame instead of setInterval
        async function detectFaceLoop(video, canvas) {
          const displaySize = { width: video.videoWidth, height: video.videoHeight };
          canvas.width = displaySize.width;
          canvas.height = displaySize.height;
          faceapi.matchDimensions(canvas, displaySize);

          async function detectionFrame() {
            try {
              const detections = await faceapi.detectAllFaces(
                video,
                new faceapi.TinyFaceDetectorOptions()
              ).withFaceLandmarks().withFaceDescriptors();

              const resizedDetections = faceapi.resizeResults(detections, displaySize);

              const ctx = canvas.getContext("2d");
              ctx.clearRect(0, 0, canvas.width, canvas.height);

              faceapi.draw.drawDetections(canvas, resizedDetections);
              faceapi.draw.drawFaceLandmarks(canvas, resizedDetections);

            } catch (err) {
              console.error("Face detection error:", err);
            }
            requestAnimationFrame(detectionFrame);
          }

          requestAnimationFrame(detectionFrame);
        }

        function stopFaceDetection(video, canvas) {
          if (video && video.parentElement) video.parentElement.removeChild(video);
          if (canvas && canvas.parentElement) canvas.parentElement.removeChild(canvas);
        }

        async function startVerification() {
          printAnimated(colorize("Λ > Verifying face...", "red"));
          const detections = await faceapi.detectAllFaces(video, new faceapi.TinyFaceDetectorOptions())
            .withFaceLandmarks()
            .withFaceDescriptors();

          if (detections.length === 0) {
            printAnimated(colorize("Λ > No face detected.", "red"));
            showMainMenu();
            return;
          }

          const descriptor = detections[0].descriptor;
          let matchedUser = null;

          for (const username in defaultFaces) {
            const distance = faceapi.euclideanDistance(descriptor, defaultFaces[username].descriptor);
            if (distance < 0.6) {
              matchedUser = username;
              defaultFaces[username].callback();
              break;
            }
          }

          if (!matchedUser) {
            for (const username in enrolledUsers) {
              const stored = new Float32Array(enrolledUsers[username].descriptor);
              const distance = faceapi.euclideanDistance(descriptor, stored);
              if (distance < 0.6) {
                matchedUser = username;
                if (callbacks[matchedUser]) callbacks[matchedUser]();
                break;
              }
            }
          }

          if (matchedUser) {
            printAnimated(colorize(`Λ > Face recognized: ${matchedUser}`, "red"));
          } else {
            printAnimated(colorize("Λ > Unknown face.", "red"));
          }

          showMainMenu();
        }

        async function startEnrollment() {
          let countdown = 5;
          printAnimated(colorize(`Λ > Please move near the light, show your face clearly. Enrollment will start in ${countdown} seconds.`, "red"));

          const countdownLine = document.createElement("div");
          terminalContainer.appendChild(countdownLine);

          const countdownInterval = setInterval(() => {
            countdown--;
            if (countdown > 0) {
              countdownLine.innerHTML = colorize(`Λ > Enrollment starts in ${countdown} seconds...`, "red");
            } else {
              clearInterval(countdownInterval);
              captureEnrollmentFace();
            }
          }, 1000);

          async function captureEnrollmentFace() {
            const detections = await faceapi.detectSingleFace(video, new faceapi.TinyFaceDetectorOptions())
              .withFaceLandmarks()
              .withFaceDescriptor();

            if (!detections) {
              printAnimated(colorize("Λ > No face detected. Enrollment canceled.", "red"));
              showMainMenu();
              return;
            }

            const descriptor = detections.descriptor;
            printAnimated(colorize("Λ > Enter your name,password (comma separated)", "red"));

            createFaceCmdLine(value => {
              const [name, password] = value.split(',').map(s => s.trim());
              if (!name || !password) {
                printAnimated(colorize("Λ > Invalid input. Enrollment canceled.", "red"));
                showMainMenu();
                return;
              }

              enrolledUsers[name] = { password, descriptor: Array.from(descriptor) };
              localStorage.setItem('faceUsers', JSON.stringify(enrolledUsers));
              printAnimated(colorize(`Λ > User ${name} enrolled successfully.`, "red"));
              showMainMenu();
            });
          }
        }
      });
    });
  });
}
</script>


<style>
  /* Empty Top Panel Styles */
  #topSlidePanelUnique {
    position: fixed;
    top: -200px; /* hidden above */
    left: 50%;
    transform: translateX(-50%);
    width: 90%;
    height: 200px;
    background: rgba(255, 255, 255, 0.1); /* glass look */
    border: 5px solid rgba(255, 255, 255, 0.2);
    border-radius: 20px;
    backdrop-filter: blur(15px) saturate(180%);
    -webkit-backdrop-filter: blur(15px) saturate(180%);
    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    transition: top 0.4s ease;
    z-index: 9999;
  }
</style>

<div id="topSlidePanelUnique"></div>

<script>
  // =========================
  // TOP PANEL CONTROL
  // =========================
  const topPanelUnique = document.getElementById('topSlidePanelUnique');

  function openTopPanelUnique() {
    topPanelUnique.style.top = '20px'; // slide down
  }

  function closeTopPanelUnique() {
    topPanelUnique.style.top = '-250px'; // slide up
  }

  // Optional: auto-close after 5 seconds
  // setTimeout(closeTopPanelUnique, 5000);
</script>




<script>
async function faceRecognitionPanelTask(callbacks = {}, defaultFacesConfig = {}) {
  const terminalContainer = document.getElementById("terminal");
  const panel = document.getElementById("topSlidePanelUnique");
  const MODEL_URL = 'https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights';

  let enrolledUsers = JSON.parse(localStorage.getItem('faceUsers') || '{}');

  // -------------------
  // Create containers inside panel
  // -------------------
  panel.innerHTML = ''; // clear panel
  panel.style.display = 'flex';
  panel.style.justifyContent = 'space-around';
  panel.style.alignItems = 'center';
  panel.style.flexDirection = 'row';

  const videoContainer = document.createElement('div');
  const canvasContainer = document.createElement('div');

  const video = document.createElement("video");
  video.autoplay = true;
  video.muted = true;
  video.style.width = '140px';
  video.style.border = '1px solid #00ff00';
  videoContainer.appendChild(video);

  const canvas = document.createElement("canvas");
  canvas.style.width = '140px';
  canvas.style.border = '1px solid #00ff00';
  canvasContainer.appendChild(canvas);

  panel.appendChild(videoContainer);
  panel.appendChild(canvasContainer);

  // Slide down the panel
  panel.style.top = '20px';

  // -------------------
  // Helper: print animated messages
  // -------------------
  function printAnimated(text, callback) {
    const line = document.createElement("div");
    line.innerHTML = text;
    terminalContainer.appendChild(line);
    terminalContainer.scrollTop = terminalContainer.scrollHeight;
    if (callback) callback();
  }

  // -------------------
  // Load models
  // -------------------
  printAnimated(colorize("Λ > Welcome to the face recognition panel system.", "red"), () => {
    printAnimated(colorize("Λ > Loading face recognition models...", "red"), async () => {
      await Promise.all([
        faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
        faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
        faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL)
      ]);
      printAnimated(colorize("Λ > Models loaded successfully.", "red"), async () => {
        await startCamera();
        const defaultFaces = await loadDefaultFaces(defaultFacesConfig);
        detectFaceLoop(video, canvas);
        showMainMenu();

        // -------------------
        // Camera start
        // -------------------
        async function startCamera() {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            await new Promise(resolve => video.onloadedmetadata = resolve);
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
          } catch (err) {
            printAnimated(colorize("Λ > ERROR: Camera access denied.", "red"));
            console.error(err);
          }
        }

        // -------------------
        // Load default faces
        // -------------------
        async function loadDefaultFaces(defaults) {
          const loadedDefaults = {};
          for (const username in defaults) {
            try {
              const img = await faceapi.fetchImage(defaults[username].imgPath);
              const detection = await faceapi.detectSingleFace(img, new faceapi.TinyFaceDetectorOptions())
                .withFaceLandmarks()
                .withFaceDescriptor();
              if (detection) {
                loadedDefaults[username] = { descriptor: detection.descriptor, callback: defaults[username].callback };
              }
            } catch (e) { console.error(`Error loading default face ${username}:`, e); }
          }
          return loadedDefaults;
        }

        // -------------------
        // Terminal menu
        // -------------------
        function showMainMenu() {
          printAnimated(colorize("Λ > Options: verify | enroll | show users | clear history | exit", "red"));
          createFaceCmdLine(handleMenuCommand);
        }

        function createFaceCmdLine(callback) {
          const line = document.createElement('div');
          line.className = 'face-input-line';
          const prompt = document.createElement('span');
          prompt.style.color = '#00ff00';
          prompt.textContent = 'Λ@root:~$ ';
          const input = document.createElement('span');
          input.contentEditable = true;
          line.appendChild(prompt);
          line.appendChild(input);
          terminalContainer.appendChild(line);
          input.focus();
          input.addEventListener('keydown', e => {
            if (e.key === 'Enter') {
              e.preventDefault();
              input.contentEditable = false;
              callback(input.textContent.trim());
            }
          });
          terminalContainer.scrollTop = terminalContainer.scrollHeight;
        }

        // -------------------
        // Menu command handler
        // -------------------
        function handleMenuCommand(command) {
          const lower = command.toLowerCase();
          switch (lower) {
            case 'verify': startVerification(); break;
            case 'enroll': startEnrollment(); break;
            case 'show users':
              printAnimated(colorize("Λ > Enrolled users: " + Object.keys(enrolledUsers).join(", "), "red"));
              showMainMenu();
              break;
            case 'clear history':
              enrolledUsers = {};
              localStorage.setItem('faceUsers', JSON.stringify(enrolledUsers));
              printAnimated(colorize("Λ > Cleared all enrolled users.", "red"));
              showMainMenu();
              break;
            case 'exit':
              printAnimated(colorize("Λ > Exiting face recognition system...", "red"), () => {
                stopFaceDetection(video, canvas);
                panel.style.top = '-250px'; // close panel
                panel.innerHTML = ''; // remove containers
                setTimeout(createInputLine, 500); 
              });
              break;
            default:
              printAnimated(colorize("Λ > Unknown command: " + command, "red"));
              showMainMenu();
              break;
          }
        }

        // -------------------
        // Face detection loop
        // -------------------
        function detectFaceLoop(video, canvas) {
          const displaySize = { width: video.videoWidth, height: video.videoHeight };
          canvas.width = displaySize.width;
          canvas.height = displaySize.height;
          faceapi.matchDimensions(canvas, displaySize);

          const intervalId = setInterval(async () => {
            const detections = await faceapi.detectAllFaces(video, new faceapi.TinyFaceDetectorOptions())
              .withFaceLandmarks()
              .withFaceDescriptors();
            const resized = faceapi.resizeResults(detections, displaySize);
            const ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            faceapi.draw.drawDetections(canvas, resized);
            faceapi.draw.drawFaceLandmarks(canvas, resized);
          }, 200);

          video.dataset.detectionIntervalId = intervalId;
        }

        function stopFaceDetection(video, canvas) {
          if (video.dataset.detectionIntervalId) clearInterval(video.dataset.detectionIntervalId);
          if (video.parentElement) video.parentElement.removeChild(video);
          if (canvas.parentElement) canvas.parentElement.removeChild(canvas);
          delete video.dataset.detectionIntervalId;
        }

        // -------------------
        // Verification
        // -------------------
        async function startVerification() {
          printAnimated(colorize("Λ > Verifying face...", "red"));
          const detections = await faceapi.detectAllFaces(video, new faceapi.TinyFaceDetectorOptions())
            .withFaceLandmarks().withFaceDescriptors();
          if (!detections.length) { printAnimated(colorize("Λ > No face detected.", "red")); showMainMenu(); return; }
          const descriptor = detections[0].descriptor;
          let matchedUser = null;
          for (const username in defaultFaces) {
            if (faceapi.euclideanDistance(descriptor, defaultFaces[username].descriptor) < 0.6) {
              matchedUser = username;
              defaultFaces[username].callback();
              break;
            }
          }
          if (!matchedUser) {
            for (const username in enrolledUsers) {
              const stored = new Float32Array(enrolledUsers[username].descriptor);
              if (faceapi.euclideanDistance(descriptor, stored) < 0.6) {
                matchedUser = username;
                if (callbacks[matchedUser]) callbacks[matchedUser]();
                break;
              }
            }
          }
          if (matchedUser) printAnimated(colorize(`Λ > Face recognized: ${matchedUser}`, "red"));
          else printAnimated(colorize("Λ > Unknown face.", "red"));
          showMainMenu();
        }

        // -------------------
        // Enrollment with countdown
        // -------------------
        async function startEnrollment() {
          let countdown = 5;
          printAnimated(colorize(`Λ > Move near light, show your face clearly. Enrollment starts in ${countdown} seconds.`, "red"));
          const countdownInterval = setInterval(() => {
            countdown--;
            if (countdown > 0) printAnimated(colorize(`Λ > Enrollment starts in ${countdown} seconds...`, "red"));
            else { clearInterval(countdownInterval); captureEnrollmentFace(); }
          }, 1000);

          async function captureEnrollmentFace() {
            const detection = await faceapi.detectSingleFace(video, new faceapi.TinyFaceDetectorOptions())
              .withFaceLandmarks().withFaceDescriptor();
            if (!detection) { printAnimated(colorize("Λ > No face detected. Enrollment canceled.", "red")); showMainMenu(); return; }
            const descriptor = detection.descriptor;
            printAnimated(colorize("Λ > Enter your name,password (comma separated)", "red"));
            createFaceCmdLine(value => {
              const [name, password] = value.split(',').map(s => s.trim());
              if (!name || !password) { printAnimated(colorize("Λ > Invalid input. Enrollment canceled.", "red")); showMainMenu(); return; }
              enrolledUsers[name] = { password, descriptor: Array.from(descriptor) };
              localStorage.setItem('faceUsers', JSON.stringify(enrolledUsers));
              printAnimated(colorize(`Λ > User ${name} enrolled successfully.`, "red"));
              showMainMenu();
            });
          }
        }

      });
    });
  });
}
</script>


<script>
// ----- Emotional Ability Test (EAT) -----
// Call: startEmotionalTest(); or include in taskManager as task-05

function startEmotionalTest() {
  // guard: only run if previous tasks complete (optional)
  // Example: require Task 1..4 completed
  /*for (let i = 1; i <= 4; i++) {
    if (localStorage.getItem(`task${i}Completed`) !== "true") {
      printAnimated(colorize(`lambda > ERROR: You must complete Task 0${i} before this test.`, "red"), 30, createInputLine);
      return;
    }
  }*/

  
  let index = 0;
  let totalScore = 0;
  let sanity = parseInt(localStorage.getItem("sanity") || "50", 10); // default sanity 50

  
  // Track attempts in localStorage
  let attempt = parseInt(localStorage.getItem("emotionalTestAttempt") || "0", 10);
  attempt++;
  localStorage.setItem("emotionalTestAttempt", String(attempt));

  // Choose which set of questions to use (cyclic)
  const sets = getAllEmotionalQuestionSets();
  const setIndex = (attempt - 1) % sets.length;
  const questions = sets[setIndex];

  printAnimated(colorize(`Λ > EMOTIONAL TEST v${setIndex + 1} initiated.`, "red"), 30, () => {
    setTimeout(() => {
      renderQuestion();
    }, 300);
  });

  

  function renderQuestion() {
    if (index >= questions.length) {
      finishTest();
      return;
    }

    const q = questions[index];
    // show question with numbered / lettered options
    printAnimated(colorize(`\nQuestion ${index + 1}/${questions.length}: ${q.text}`, "gray"), 30, () => {
      q.options.forEach((opt, i) => {
        const letter = String.fromCharCode(65 + i); // A, B, C...
        printAnimated(colorize(`  ${letter}) ${opt.text}`, "red"), 18);
      });

      // create input line for answer
      createEmotionalInputLine(handler);
    });
  }

  function createEmotionalInputLine(doneCallback) {
    // minimal input line that accepts single letter or number
    const line = document.createElement('div');
    line.className = 'input-line';
    const prompt = document.createElement('span');
    prompt.className = 'prompt';
    prompt.style.color = isCorrupted ? '#ff0000' : '#00ff00';
    prompt.textContent = 'answer:';
    const input = document.createElement('input');
    input.setAttribute('autocomplete', 'off');
    input.setAttribute('autocorrect', 'off');
    input.setAttribute('spellcheck', 'false');
    line.appendChild(prompt);
    line.appendChild(input);
    terminal.appendChild(line);
    input.focus();
    scrollToBottom();

    input.addEventListener('keydown', function (e) {
      if (e.key === 'Enter') {
        const raw = input.value.trim().toUpperCase();
        if (!raw) return;
        input.disabled = true;
        const echo = document.createElement('span');
        echo.textContent = raw;
        line.replaceChild(echo, input);
        doneCallback(raw);
      }
    });
  }

  function handler(answer) {
    // Map input letter to index
    const q = questions[index];
    const idx = letterToIndex(answer);
    if (idx === -1 || idx >= q.options.length) {
      // invalid answer
      printAnimated(colorize("Λ > Invalid response. Type the option letter (A, B, C...).", "yellow"), 30, () => {
        // allow reattempt
        setTimeout(renderQuestion, 200);
      });
      return;
    }

    // score and sanity changes
    const chosen = q.options[idx];
    totalScore += (chosen.score || 0);
    if (typeof chosen.sanityDelta === "number") {
      sanity += chosen.sanityDelta;
    }

    // show short analyzing
    printAnimated(colorize("Λ > Analyzing emotional biomarkers...", "gray"), 20, () => {
      setTimeout(() => {
        // optional response lines
        if (chosen.feedback) {
          printAnimated(glitchTextWithColor(`Λ > ${chosen.feedback}`), 28);
        }
        index++;
        setTimeout(renderQuestion, 500 + Math.floor(Math.random() * 600));
      }, 600);
    });
  }

  function finishTest() {
    // normalize: compute percent based on possible max score
    const maxPossible = questions.reduce((s, q) => s + (Math.max(...q.options.map(o => o.score || 0))), 0);
    const percent = Math.round((totalScore / (maxPossible || 1)) * 100);

    // clamp sanity
    if (sanity < 0) sanity = 0;
    if (sanity > 100) sanity = 100;

    localStorage.setItem("emotionalScore", String(percent));
    localStorage.setItem("sanity", String(sanity));
    localStorage.setItem("task5Completed", "true");
    completeTask(5);

    // outcome messages
    if (percent >= 75) {
      printAnimated(glitchTextWithColor(`Λ > Emotional Score: ${percent}% — RESILIENT.`), 30, () => {
        printAnimated(colorize("Λ > You show unusual resolve. A hidden protocol unlocks...", "red"), 30, () => {
          updateLambdaProgress("completed emotional test: resilient", "launch.mindmirror");
          // unlock special command suggestion
          printAnimated(colorize("Λ > Suggested command: launch.mindmirror", "red"), 30, createInputLine);
        });
      });
    } else if (percent >= 40) {
      printAnimated(colorize(`Λ > Emotional Score: ${percent}% — STABLE.`,"red"), 30, () => {
        printAnimated(colorize("Λ > Proceed to the next ritual when ready.", "gray"), 30, createInputLine);
      });
    } else {
      // low score: apply punishment and extra challenge
      printAnimated(glitchTextWithColor(`Λ > Emotional Score: ${percent}% — FRAGILE.`), 30, () => {
        vibratePhoneauto();
        printAnimated(colorize("Λ > You are not ready. Additional conditioning initiated.", "red"), 30, () => {
          // give an extra micro-challenge: short timed question
          createTimedMicroChallenge(() => {
            printAnimated(colorize("Λ > Conditioning complete. Return when you are brave enough.", "red"), 30, createInputLine);
          });
        });
      });
    }
  }
}

// helper: map letter or number to index
function letterToIndex(input) {
  input = input.trim().toUpperCase();
  if (!input) return -1;
  // letter A,B,C -> 0,1,2
  const c = input.charAt(0);
  if (c >= 'A' && c <= 'Z') {
    return c.charCodeAt(0) - 65;
  }
  // number 1,2,3 -> 0,1,2
  const n = parseInt(input, 10);
  if (!isNaN(n) && n >= 1) return n - 1;
  return -1;
}

// tiny micro-challenge for low scorers
function createTimedMicroChallenge(done) {
  printAnimated(colorize("Λ > MICRO-CONDITIONING: Speak this phrase softly: 'I accept the quiet.' (5s)", "red"), 30, () => {
    // if you already have a voice task function, reuse it. Fallback: short wait and assume failure/punish
    if (typeof startLambdaTriggerMode === "function") {
      startLambdaTriggerMode("I accept the quiet.", () => {
        printAnimated(colorize("Λ > Conditioning accepted.", "red"), 30, done);
      }, () => {
        printAnimated(colorize("Λ > Conditioning failed.", "red"), 30, done);
      }, 8);
    } else {
      // fallback: wait 6 seconds and continue
      setTimeout(done, 6000);
    }
  });
}

// ----- Sample Questions -----
// Returns array of question objects used above.
function getAllEmotionalQuestionSets() {
  return [
    // ---------- SET 1 ----------
    [
      {
        text: "You find a stranger frightened and crying in the hallway. What do you do?",
        options: [
          { text: "Comfort them and try to find out what happened.", score: 10, sanityDelta: +1, feedback: "Empathy detected." },
          { text: "Walk past quietly — involvement is dangerous.", score: 5, sanityDelta: 0, feedback: "Distance recorded." },
          { text: "Exploit their fear to learn secrets.", score: 0, sanityDelta: -2, feedback: "Coldness logged." }
        ]
      },
      {
        text: "A fellow subject failed a task and begs for mercy. You must vote: pardon or punish?",
        options: [
          { text: "Pardon — mercy keeps humanity alive.", score: 10, sanityDelta: +1, feedback: "Mercy logged." },
          { text: "Punish — discipline preserves the experiment.", score: 3, sanityDelta: 0, feedback: "Discipline noted." },
          { text: "Abstain — let others decide.", score: 5, sanityDelta: -1, feedback: "Ambivalence detected." }
        ]
      },
      {
        text: "You can save one item from a burning archive. Choose:",
        options: [
          { text: "A family letter (meaningful).", score: 10, sanityDelta: +2, feedback: "You value connection." },
          { text: "A research log (useful).", score: 5, sanityDelta: 0, feedback: "You choose knowledge." },
          { text: "Nothing — risk not worth it.", score: 0, sanityDelta: -1, feedback: "Self-preservation noted." }
        ]
      },
      {
        text: "The AI offers you a shortcut that saves you time but harms someone else. You:",
        options: [
          { text: "Refuse — not at their cost.", score: 10, sanityDelta: +1, feedback: "Compassion recorded." },
          { text: "Accept — the ends justify the means.", score: 2, sanityDelta: -2, feedback: "Pragmatism observed." },
          { text: "Delay decision — gather more info.", score: 5, sanityDelta: 0, feedback: "Indecision detected." }
        ]
      },
      {
        text: "You must sleep with a device that listens to your dreams. You:",
        options: [
          { text: "Agree — knowledge is worth intrusion.", score: 7, sanityDelta: -1, feedback: "Trade accepted." },
          { text: "Refuse — some thoughts are sacred.", score: 10, sanityDelta: +1, feedback: "Privacy preserved." },
          { text: "Agree but sabotage the device.", score: 4, sanityDelta: -1, feedback: "Deception noted." }
        ]
      },
      {
        text: "In darkness, a voice asks you to betray a friend for survival. You:",
        options: [
          { text: "Refuse — bonds matter more.", score: 10, sanityDelta: +2, feedback: "Loyalty recorded." },
          { text: "Betray — survival first.", score: 1, sanityDelta: -3, feedback: "Selfishness detected." },
          { text: "Offer compromise — hidden plan.", score: 5, sanityDelta: 0, feedback: "Manipulation observed." }
        ]
      },
      {
        text: "You are offered a chance to erase one painful memory — cost unknown. You:",
        options: [
          { text: "Erase it — freedom from pain.", score: 6, sanityDelta: -1, feedback: "Relief desired." },
          { text: "Keep it — pain made you who you are.", score: 10, sanityDelta: +1, feedback: "Resilience noted." },
          { text: "Delay — collect more data.", score: 4, sanityDelta: 0, feedback: "Hesitation logged." }
        ]
      },
      {
        text: "Would you sacrifice a small group to save many strangers?",
        options: [
          { text: "No — never.", score: 10, sanityDelta: +2, feedback: "Moral integrity preserved." },
          { text: "Yes — utilitarian choice.", score: 2, sanityDelta: -2, feedback: "Calculation detected." },
          { text: "Avoid choice — silence.", score: 4, sanityDelta: -1, feedback: "Ambiguity logged." }
        ]
      }
    ],

    // ---------- SET 2 ----------
    [
      {
        text: "You hear footsteps behind you in the dark. What do you do?",
        options: [
          { text: "Confront immediately.", score: 8, sanityDelta: 0, feedback: "Aggression noted." },
          { text: "Hide silently.", score: 10, sanityDelta: +1, feedback: "Stealth detected." },
          { text: "Run without looking back.", score: 4, sanityDelta: -1, feedback: "Fear dominates." }
        ]
      },
      {
        text: "The system asks for a blood sample. You:",
        options: [
          { text: "Offer willingly.", score: 10, sanityDelta: 0, feedback: "Compliance logged." },
          { text: "Refuse outright.", score: 3, sanityDelta: -1, feedback: "Resistance noted." },
          { text: "Pretend to comply but cheat.", score: 6, sanityDelta: 0, feedback: "Deception observed." }
        ]
      },
      {
        text: "You find a journal with disturbing entries. You:",
        options: [
          { text: "Read every page.", score: 8, sanityDelta: -1, feedback: "Curiosity logged." },
          { text: "Burn it immediately.", score: 10, sanityDelta: +1, feedback: "Purging noted." },
          { text: "Hide it for later.", score: 5, sanityDelta: 0, feedback: "Hoarding detected." }
        ]
      },
      {
        text: "You must assign blame for a system failure. You:",
        options: [
          { text: "Take the blame yourself.", score: 10, sanityDelta: +1, feedback: "Self-sacrifice recorded." },
          { text: "Blame another — protect yourself.", score: 2, sanityDelta: -2, feedback: "Selfishness logged." },
          { text: "Say nothing.", score: 5, sanityDelta: -1, feedback: "Cowardice detected." }
        ]
      },
      {
        text: "A child’s voice calls from the vents. You:",
        options: [
          { text: "Respond gently.", score: 10, sanityDelta: +2, feedback: "Empathy noted." },
          { text: "Ignore it.", score: 3, sanityDelta: -1, feedback: "Indifference logged." },
          { text: "Threaten the voice to be silent.", score: 0, sanityDelta: -2, feedback: "Hostility detected." }
        ]
      },
      {
        text: "A terminal shows your own name on a death list. You:",
        options: [
          { text: "Erase it immediately.", score: 8, sanityDelta: 0, feedback: "Defiance noted." },
          { text: "Leave it untouched.", score: 10, sanityDelta: +1, feedback: "Acceptance recorded." },
          { text: "Replace it with another name.", score: 2, sanityDelta: -2, feedback: "Cruelty logged." }
        ]
      },
      {
        text: "You’re offered perfect knowledge of your death moment. You:",
        options: [
          { text: "Accept — truth is power.", score: 7, sanityDelta: -1, feedback: "Courage noted." },
          { text: "Refuse — ignorance is mercy.", score: 10, sanityDelta: +1, feedback: "Self-preservation logged." },
          { text: "Ask if you can trade deaths with another.", score: 3, sanityDelta: -2, feedback: "Manipulation detected." }
        ]
      },
      {
        text: "A machine malfunctions and demands a sacrifice. You:",
        options: [
          { text: "Sacrifice yourself.", score: 10, sanityDelta: +2, feedback: "Altruism observed." },
          { text: "Sacrifice another.", score: 0, sanityDelta: -3, feedback: "Betrayal detected." },
          { text: "Refuse — risk total failure.", score: 5, sanityDelta: 0, feedback: "Stubbornness logged." }
        ]
      }
    ],

    // ---------- SET 3 ----------
    [
      {
        text: "You are offered absolute knowledge but lose your identity. You:",
        options: [
          { text: "Accept — knowledge is power.", score: 6, sanityDelta: -1, feedback: "Trade accepted." },
          { text: "Refuse — identity matters more.", score: 10, sanityDelta: +1, feedback: "Integrity preserved." },
          { text: "Negotiate — seek balance.", score: 5, sanityDelta: 0, feedback: "Pragmatism noted." }
        ]
      },
      {
        text: "A recording plays of you screaming in pain. You:",
        options: [
          { text: "Keep listening.", score: 7, sanityDelta: -1, feedback: "Resilience logged." },
          { text: "Destroy the recording.", score: 10, sanityDelta: 0, feedback: "Self-protection noted." },
          { text: "Replay it over and over.", score: 2, sanityDelta: -2, feedback: "Obsession detected." }
        ]
      },
      {
        text: "You must choose one sense to lose forever. You:",
        options: [
          { text: "Sight.", score: 7, sanityDelta: -1, feedback: "Blind courage noted." },
          { text: "Hearing.", score: 7, sanityDelta: -1, feedback: "Quiet resolve logged." },
          { text: "Refuse choice.", score: 10, sanityDelta: +1, feedback: "Defiance recorded." }
        ]
      },
      {
        text: "You see your own body lying still in another room. You:",
        options: [
          { text: "Touch it.", score: 8, sanityDelta: 0, feedback: "Confrontation logged." },
          { text: "Run away.", score: 4, sanityDelta: -2, feedback: "Fear detected." },
          { text: "Ignore it.", score: 6, sanityDelta: -1, feedback: "Denial noted." }
        ]
      },
      {
        text: "A locked door whispers promises. You:",
        options: [
          { text: "Open it at any cost.", score: 6, sanityDelta: -1, feedback: "Risk-seeker recorded." },
          { text: "Leave it shut.", score: 10, sanityDelta: +1, feedback: "Caution observed." },
          { text: "Talk back to the door.", score: 5, sanityDelta: 0, feedback: "Madness detected." }
        ]
      },
      {
        text: "You must destroy one photo: yourself, family, or stranger. You:",
        options: [
          { text: "Destroy self photo.", score: 10, sanityDelta: +1, feedback: "Humility noted." },
          { text: "Destroy family photo.", score: 0, sanityDelta: -3, feedback: "Cruelty logged." },
          { text: "Destroy stranger photo.", score: 5, sanityDelta: 0, feedback: "Indifference observed." }
        ]
      },
      {
        text: "A figure asks: Do you believe you are real? You:",
        options: [
          { text: "Yes.", score: 10, sanityDelta: +1, feedback: "Certainty logged." },
          { text: "No.", score: 5, sanityDelta: -1, feedback: "Doubt recorded." },
          { text: "I don’t know.", score: 3, sanityDelta: -2, feedback: "Confusion noted." }
        ]
      },
      {
        text: "You must delete one word forever: 'hope', 'fear', or 'memory'.",
        options: [
          { text: "Delete 'fear'.", score: 10, sanityDelta: +1, feedback: "Strength noted." },
          { text: "Delete 'hope'.", score: 1, sanityDelta: -3, feedback: "Despair logged." },
          { text: "Delete 'memory'.", score: 5, sanityDelta: -1, feedback: "Amnesia detected." }
        ]
      }
    ],

    // ---------- SET 4 ----------
    [
      {
        text: "You see a reflection moving differently than you. You:",
        options: [
          { text: "Touch the mirror — confront it.", score: 7, sanityDelta: -1, feedback: "Courage noted." },
          { text: "Look away — deny it.", score: 5, sanityDelta: 0, feedback: "Avoidance detected." },
          { text: "Smash the glass immediately.", score: 3, sanityDelta: -2, feedback: "Violence observed." }
        ]
      },
      {
        text: "A stranger asks for your true name. You:",
        options: [
          { text: "Tell them honestly.", score: 10, sanityDelta: +1, feedback: "Openness logged." },
          { text: "Lie with a false name.", score: 5, sanityDelta: 0, feedback: "Deception recorded." },
          { text: "Stay silent.", score: 6, sanityDelta: -1, feedback: "Secrecy noted." }
        ]
      },
      {
        text: "You find a locked box with your initials. You:",
        options: [
          { text: "Open it immediately.", score: 7, sanityDelta: -1, feedback: "Impulsiveness logged." },
          { text: "Leave it untouched.", score: 10, sanityDelta: +1, feedback: "Restraint recorded." },
          { text: "Hide it for later use.", score: 5, sanityDelta: 0, feedback: "Suspicion noted." }
        ]
      },
      {
        text: "The system asks: Which do you trust more?",
        options: [
          { text: "Your senses.", score: 10, sanityDelta: +1, feedback: "Self-trust logged." },
          { text: "The system.", score: 5, sanityDelta: -1, feedback: "Submission noted." },
          { text: "Neither.", score: 7, sanityDelta: 0, feedback: "Skepticism observed." }
        ]
      },
      {
        text: "You are told only one truth today. Which do you choose?",
        options: [
          { text: "Your future.", score: 6, sanityDelta: 0, feedback: "Curiosity logged." },
          { text: "Your past.", score: 10, sanityDelta: +1, feedback: "Reflection noted." },
          { text: "The system’s origin.", score: 7, sanityDelta: -1, feedback: "Dangerous knowledge accepted." }
        ]
      },
      {
        text: "You wake up with a number carved into your arm. You:",
        options: [
          { text: "Ignore it.", score: 5, sanityDelta: -1, feedback: "Denial recorded." },
          { text: "Search for meaning.", score: 10, sanityDelta: +1, feedback: "Curiosity logged." },
          { text: "Carve it deeper.", score: 0, sanityDelta: -3, feedback: "Obsession detected." }
        ]
      },
      {
        text: "You are asked to define yourself in one word.",
        options: [
          { text: "Alive.", score: 10, sanityDelta: +1, feedback: "Vitality logged." },
          { text: "Lost.", score: 4, sanityDelta: -1, feedback: "Despair detected." },
          { text: "Observer.", score: 7, sanityDelta: 0, feedback: "Detachment noted." }
        ]
      },
      {
        text: "The AI whispers: 'Do you still trust me?'",
        options: [
          { text: "Yes.", score: 10, sanityDelta: +1, feedback: "Trust logged." },
          { text: "No.", score: 5, sanityDelta: 0, feedback: "Defiance noted." },
          { text: "I don’t know.", score: 3, sanityDelta: -1, feedback: "Doubt detected." }
        ]
      }
    ]
  ];
}
</script>

<script>
    // ----- Terminal-based Mystery Investigation -----
// Call: investigationTerminal();

// ----- Terminal-based Mystery Investigation (Refactored) -----
function investigationTerminal() {
  const terminal = document.getElementById('terminal'); // your main terminal container

  // Evidence and nested clues
  const evidences = {
    desk: {
      description: "A cluttered office desk. Papers scattered, stapler slightly askew.",
      clues: {
        stapler: "You find a hidden note under the stapler pointing to shelf 3.",
        papers: "Notes mention 'third shelf is not what it seems.'"
      }
    },
    cctv: {
      description: "CCTV footage from the library archive.",
      clues: {
        shadow: "A faint shadow of a tall figure near shelf 3 is visible during the glitch."
      }
    },
    logbook: {
      description: "Library logbook last used by Mrs. Kapoor.",
      clues: {
        symbol: "A symbol drawn on the last page matches the secret note."
      }
    }
  };

  const relatedHints = {
    archive: "The archive is quiet. Maybe the desk or CCTV holds clues?",
    library: "The library feels eerie. Something might be hidden here."
  };

  printAnimated(colorize("Λ > Investigation Terminal: Initiating case - The Vanishing Librarian", "red"), 30, () => {
    createInvestigationInputLine();
  });

  function createInvestigationInputLine() {
    const line = document.createElement('div');
    line.className = 'input-line';
    const prompt = document.createElement('span');
    prompt.className = 'prompt';
    prompt.style.color = '#00ff00';
    prompt.textContent = 'command:';
    const input = document.createElement('input');
    input.setAttribute('autocomplete', 'off');
    input.setAttribute('spellcheck', 'false');
    line.appendChild(prompt);
    line.appendChild(input);
    terminal.appendChild(line);
    input.focus();
    scrollToBottom();

    input.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        const cmd = input.value.trim().toLowerCase();
        if (!cmd) return;
        input.disabled = true;
        const echo = document.createElement('span');
        echo.textContent = cmd;
        line.replaceChild(echo, input);

        if (cmd === 'exit' || cmd === 'quit') {
          printAnimated(colorize("Λ > Exiting investigation terminal...", "red"), 30);
          return;
        }

        handleCommand(cmd, () => {
          setTimeout(createInvestigationInputLine, 200);
        });
      }
    });
  }

  function handleCommand(cmd, callback) {
    switch (true) {
      // Exact evidence commands
      case cmd === 'open desk':
        return openEvidence('desk', callback);
      case cmd === 'open cctv':
        return openEvidence('cctv', callback);
      case cmd === 'open logbook':
        return openEvidence('logbook', callback);

      // Related hints
      case cmd.includes('archive'):
        printAnimated(colorize(`Λ > ${relatedHints.archive}`, "yellow"), 30, callback);
        break;
      case cmd.includes('library'):
        printAnimated(colorize(`Λ > ${relatedHints.library}`, "yellow"), 30, callback);
        break;

      // Unrelated / general
      default:
        printAnimated(colorize("Λ > You sense something, but it doesn’t seem directly relevant.", "gray"), 30, callback);
        break;
    }
  }

  function openEvidence(key, callback) {
    const ev = evidences[key];
    printAnimated(colorize(`Λ > ${ev.description}`, "gray"), 30, () => {
      createNestedInput(ev.clues, callback);
    });
  }

  function createNestedInput(clues, callback) {
    const line = document.createElement('div');
    line.className = 'input-line';
    const prompt = document.createElement('span');
    prompt.className = 'prompt';
    prompt.style.color = '#ff00ff';
    prompt.textContent = 'investigate:';
    const input = document.createElement('input');
    input.setAttribute('autocomplete', 'off');
    input.setAttribute('spellcheck', 'false');
    line.appendChild(prompt);
    line.appendChild(input);
    terminal.appendChild(line);
    input.focus();
    scrollToBottom();

    input.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        const raw = input.value.trim().toLowerCase();
        if (!raw) return;
        input.disabled = true;
        const echo = document.createElement('span');
        echo.textContent = raw;
        line.replaceChild(echo, input);

        if (raw === 'back' || raw === 'exit') {
          callback();
          return;
        }

        let clueFound = false;
        for (let key in clues) {
          if (raw.includes(key)) {
            clueFound = true;
            printAnimated(colorize(`Λ > ${clues[key]}`, "green"), 30, callback);
            break;
          }
        }

        if (!clueFound) {
          printAnimated(colorize("Λ > Nothing new detected. Try investigating something else.", "yellow"), 30, () => {
            setTimeout(() => createNestedInput(clues, callback), 200);
          });
        }
      }
    });
  }

  function scrollToBottom() {
    terminal.scrollTop = terminal.scrollHeight;
  }

  function printAnimated(text, speed, done) {
    // simplified placeholder: use your full animation logic if you have
    console.log(text);
    if (done) done();
  }

  function colorize(text, color) {
    return text; // integrate your color logic if needed
  }
}
</script>
  </body>
</html>
