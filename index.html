<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
 
  <title>Lambda Terminal</title>

  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-YC2N3BWQ0E"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-YC2N3BWQ0E');
</script>
  
  <link rel="manifest" href="/manifest.json">
    
    <script>
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("/service-worker.js")
      .then(() => console.log("Service Worker Registered"))
      .catch(err => console.error("Service Worker Failed:", err));
  }
</script>

</head>
<body>


<script>
    // Global variable to hold the deferred prompt event
let deferredPrompt = null;

// Listen for the beforeinstallprompt event
window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault(); // Prevent automatic mini-infobar
    deferredPrompt = e; // Save the event for later
    printAnimated(colorize('PWA installation prompt is ready'));
});

/**
 * Function to trigger PWA install prompt
 */
async function triggerPWAInstall() {
    if (!deferredPrompt) {
        printAnimated(colorize('Install prompt is not ready yet.'));
        return;
    }

    // Show the install prompt
    deferredPrompt.prompt();

    // Wait for user response
    const choiceResult = await deferredPrompt.userChoice;

    if (choiceResult.outcome === 'accepted') {
        printAnimated(colorize('User accepted the PWA installation.'));
    } else {
        printAnimated(colorize('User dismissed the PWA installation.'));
    }

    // Clear the saved prompt; it can only be used once
    deferredPrompt = null;
}

/*// Example: Using a switch
const mySwitch = document.getElementById('mySwitch'); // your switch element

mySwitch.addEventListener('change', () => {
    if (mySwitch.checked) {
        triggerPWAInstall(); // Call function when switch is turned on
    }
});*/
</script>

 <style>
    /* Consolidated CSS with Font Size Adjustments */
    body {
      background-color: black;
      color: #00ff00; /* Default green */
      font-family: monospace;
      font-weight: bold;
      margin: 0;
      padding: 10px;
      transition: background-color 0.2s ease;
      overflow: hidden;
      font-size:0.7em; /* Base font size for the entire document */
    }

    #terminal {
  letter-spacing: 0.5px; /* reduce gap */
      max-width: 100%;
      max-hight: 90%;
      white-space: pre-wrap;
      word-wrap: break-word;
      height: 85vh;
      overflow-y: auto;
      position: relative;
      z-index: 2;
      font-size: inherit; /* Ensure terminal inherits body's font size */
      line-height: 1.2; /* Improve readability for terminal lines */
    }

    /* Styles for individual lines added to the terminal */
    #terminal > div {
        font-size: inherit; /* Ensures each line div matches terminal's font size */
    }

    .input-line {
      display: flex;
    }

    .prompt {
      margin-right: 10px;
      font-size: inherit; /* Ensure prompt inherits parent's font size */
    }

    input {
      background: transparent;
      border: none;
      color: #1c15ff; /* Blue for input text */
      width: 60px; /* This width might need adjustment based on content */
      font-family: inherit;
      font-size: inherit; /* Make input font size consistent */
      flex: 1;
      outline: none;
      font-weight: bold;
    }

    .glitch1 {
      animation: glitch 0.3s infinite;
    }

    @keyframes glitch1 {
      0% { text-shadow: 2px 0 red; }
      50% { text-shadow: -2px 0 lime; }
      100% { text-shadow: 2px 0 red; }
    }

    .glitch {
      position: relative;
      display: inline-block;
      /* Adjusted: Removed font-size: 1.2em; to make it inherit and match */
      /* If you want glitch text to be slightly larger, set a fixed pixel size
         here (e.g., font-size: 18px;) and ensure all other text you want
         to be the same size is also set to that specific pixel size.
         For consistency, `font-size: inherit;` is usually best. */
    }

    .glitch::before,
    .glitch::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      overflow: hidden;
      pointer-events: none;
    }

    .glitch::before {
      color: #ff5555;
      z-index: -1;
    }

    .glitch::after {
      color: #ff999;
      z-index: -2;
    }

    .glitch-animate {
      animation: glitchSkew 1s ease-in-out;
    }

    .glitch-animate::before {
      animation: glitchTop 1s ease-in-out;
    }

    .glitch-animate::after {
      animation: glitchBottom 1s ease-in-out;
    }

    @keyframes glitchSkew {
      0% { transform: none; }
      20% { transform: skew(-3deg); }
      40% { transform: skew(3deg); }
      50% { transform: translate(-1px, 1px); }
      80% { transform: translate(1px, -1px); }
      100% { transform: none; }
    }

    @keyframes glitchTop {
      0% { clip-path: inset(0 0 80% 0); transform: translate(-2px, -2px); }
      100% { clip-path: inset(80% 0 0 0); transform: translate(0, 0); }
    }

    @keyframes glitchBottom {
      0% { clip-path: inset(80% 0 0 0); transform: translate(2px, 2px); }
      100% { clip-path: inset(0 0 80% 0); transform: translate(0, 0); }
    }

    @keyframes blinkRed {
      0%   { color: #00ff00; }
      25%  { color: #ff0000; }
      50%  { color: #00ff00; }
      75%  { color: #ff0000; }
      100% { color: #00ff00; }
    }

    .blink-red {
      animation: blinkRed 0.5s step-start 5; /* 5 flashes */
    }

    #camera-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 0;
      opacity: 0;
      transition: opacity 1.5s ease-in-out;
      filter: brightness(0.5) contrast(1.4) sepia(0.7) hue-rotate(-50deg) saturate(2);
      pointer-events: none;
    }
    
    #redBox {
  display: none;
  position: fixed;
  color: black;
  top: 30%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: red;
  color: white;
  font-family: monospace;
  font-size: 10px;
  padding: 20px 30px;
  border: 3px solid black;
  border-radius: 8px;
  z-index: 9999;
  text-align: center;
  max-width: 80%;
}
  </style>
   

    <div class="container1"> 

       
  <video id="camera-overlay" autoplay muted playsinline></video>
  <video id="bgVideo" muted style="
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  object-fit: cover;
  z-index: -1;
  display: none;
  pointer-events: none;
">
  <source src="vecteezy_dark-red-grunge-horror-background-loop_1623974~2.mp4" type="video/mp4">
</video>
  <div id="terminal"></div>
  
    </div> 
  <!-- Include this element in your HTML terminal or anywhere -->
<div id="bombLockOverlay" style="display:none;"></div>

  
<script>
    // --- Global Variables and DOM Elements ---
    const terminal = document.getElementById('terminal');
    const cameraOverlay = document.getElementById('camera-overlay');
    let isCorrupted = false;
    let cameraPermissionGranted = false; // Flag to track camera permission

    // --- Utility Functions ---

    /**
     * Scrolls the terminal to the bottom.
     */
    function scrollToBottom() {
      terminal.scrollTop = terminal.scrollHeight;
    }
    

function playBackgroundVideoOnce() {
  const video = document.getElementById("bgVideo");
  if (!video) return;

  video.style.display = "block";
  video.currentTime = 0;
  video.play();

  // When the video ends, hide it
  video.onended = () => {
    video.style.display = "none";
  };
}


    /**
     * Applies a glitch animation and color to text.
     * @param {string} text - The text to glitch.
     * @param {string} [color='#ff0000'] - The color for the glitch text.
     * @returns {string} HTML string with glitch effect.
     */
    function glitchTextWithColor(text, color = '#ff0000') {
      const id = 'glitch-' + Math.random().toString(36).substring(2);
      setTimeout(() => {
        const el = document.getElementById(id);
        if (el) el.classList.remove('glitch-animate');
      }, 2500);
      // The glitch class no longer forces a larger font size due to CSS adjustments
      return `<span class="glitch glitch-animate" style="color:${color};" id="${id}" data-text="${text}">${text}</span>`;
    }
    

    /**
     * Colors the given text. Uses red if `isCorrupted` is true, otherwise green, or a specified color.
     * @param {string} text - The text to colorize.
     * @param {string} [color=null] - Optional specific color.
     * @returns {string} HTML string with color.
     */
    function colorize(text, color = null) {
      const useColor = color || (isCorrupted ? '#ff0000' : '#00ff00');
      return `<span style="color: ${useColor};">${text}</span>`;
    }

    /**
     * Creates a brief red flicker on the background.
     * @param {number} [duration=300] - Duration of the flicker in milliseconds.
     */
    function flickerRed(duration = 300) {
      document.body.style.backgroundColor = '#330000';
      setTimeout(() => {
        document.body.style.backgroundColor = 'black';
      }, duration);
    }

    /**
     * Simulates typing animation for HTML content into the terminal.
     * @param {string} htmlText - The HTML content to display.
     * @param {number} [delay=40] - Delay between characters in milliseconds.
     * @param {function} [callback=null] - Function to call after animation completes.
     */
    function printAnimated(htmlText, delay = 40, callback = null) {
      const line = document.createElement('div');
      terminal.appendChild(line);
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = htmlText;
      const content = Array.from(tempDiv.childNodes);

      function typeNode(node, parent, nodeCallback) {
        if (node.nodeType === Node.TEXT_NODE) {
          const span = document.createElement('span');
          span.textContent = '';
          parent.appendChild(span);
          let j = 0;
          const interval = setInterval(() => {
            if (j < node.textContent.length) {
              span.textContent += node.textContent.charAt(j++);
              scrollToBottom();
            } else {
              clearInterval(interval);
              nodeCallback();
            }
          }, delay);
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          const clone = node.cloneNode(false);
          parent.appendChild(clone);
          const children = Array.from(node.childNodes);
          function processChildren(index = 0) {
            if (index < children.length) {
              typeNode(children[index], clone, () => processChildren(index + 1));
            } else {
              scrollToBottom();
              nodeCallback();
            }
          }
          processChildren();
        } else {
          nodeCallback();
        }
      }

      let currentIndex = 0;
      function processNext() {
        if (currentIndex < content.length) {
          typeNode(content[currentIndex++], line, processNext);
        } else if (callback) {
          scrollToBottom();
          callback();
        }
      }
      processNext();
    }

    /**
     * Clears all content from the terminal.
     */
    function clearTerminal() {
      if (terminal) terminal.innerHTML = '';
    }

    /**
     * Adds a normal log message to the terminal.
     * @param {string} text - The text to log.
     */
    function log(text) {
      const line = document.createElement('div');
      line.textContent = text;
      terminal.appendChild(line);
      scrollToBottom();
    }

    // --- Interactive Terminal Core Functions ---

    /**
     * Creates an input line for user commands.
     * @param {string} [promptText='lambda@root:~$'] - The prompt text to display.
     */
    function createInputLine(promptText = 'lambda@root:~$') {
  const line = document.createElement('div');
  line.className = 'input-line';

  const prompt = document.createElement('span');
  prompt.className = 'prompt';
  prompt.style.color = isCorrupted ? '#ff0000' : '#00ff00';
  prompt.textContent = promptText;

  const input = document.createElement('input');
  input.setAttribute('autocomplete', 'off'); // optional for better UX
  input.setAttribute('autocorrect', 'off');  // optional for better UX
  input.setAttribute('spellcheck', 'false'); // optional for better UX

  input.addEventListener('keydown', function (e) {
    if (e.key === 'Enter') {
      const command = input.value.trim().toLowerCase();
      input.disabled = true;
      const echo = document.createElement('span');
      echo.textContent = command;
      line.replaceChild(echo, input); // Replace input with its echoed value
      handleCommand(command);
    }
  });

  line.appendChild(prompt);
  line.appendChild(input);
  terminal.appendChild(line);

  // Add bottom padding to prevent keyboard overlap
  terminal.style.paddingBottom = '200px';

  // Focus input after short delay and scroll into view
  setTimeout(() => {
    input.focus();
    input.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }, 100);

  // Optional: remove padding when input loses focus
  input.addEventListener('blur', () => {
    terminal.style.paddingBottom = '0px';
  });

  scrollToBottom();
}
    /**
     * Handles user commands entered in the terminal.
     * @param {string} cmd - The command entered by the user.
     */
    function handleCommand(cmd) {
      switch (cmd) {
        case 'launch -venta':
          blinkFlashlight();
          clearTerminal();
          startLambdaHorrorStory();
          updateLambdaProgress(
  "you have not completed your confirmation do you really want to continue this game if yes say 'yes' if no say 'no' but no cannot stop the game",
  "say yes or say no"
);
          break;
          case 'video':
          playBackgroundVideoOnce();
          setTimeout(createInputLine, 500);
          break;
        case "countdown":
        vibratePhone("on");  // starts vibrate 
 
          startCountdown(10);
          
          setTimeout(createInputLine, 500); // Add input line after countdown starts
          break;
        case "sound":
        playSoundOnce("20hz.mp3");
        setTimeout(createInputLine, 500);
        break;

        case "music":
        loopSound("on", "sfx/ambient_loop.mp3");
        setTimeout(createInputLine, 500);
        break;

        case "silence":
        loopSound("off");
        setTimeout(createInputLine, 500);
        break;
        case 'diagnose':
          printAnimated(glitchTextWithColor('>> Running system diagnostics...'), 40, () => {
            setTimeout(() => {
              flickerRed();
              printAnimated(glitchTextWithColor('>> Anomaly detected: Memory bleed', '#ff0000'), 40, () => {
                setTimeout(createInputLine, 500);
              });
            }, 800);
          });
          break;
        case 'invoke shadow':
          downloadGameLauncherByRandom();
          printAnimated(glitchTextWithColor('>> Invoking forbidden process...'), 40, () => {
            flickerRed(500);
            setTimeout(() => {
              printAnimated(glitchTextWithColor('>> Process override. Logic disconnected.', '#ff0000'), 40, () => {
                setTimeout(createInputLine, 500);
              });
            }, 900);
          });
          break;          
          case "cream":
         micScreamTask(
  "lambda > ✅ You screamed loud enough. Access granted.",
  "lambda > ❌ Weak scream. You have failed.",
  () => {
    printAnimated("lambda > [UNLOCKED] Access to Shadow Protocol.", 30, createInputLine);
  },
  () => {
    printAnimated("lambda > ☠️ Punishment: Memory corrupted. Executing darkness injection...", 30, () => {
      // or your own punishment function
      setTimeout(createInputLine, 30);
    });
  }
);
          break;
        case "flash":
          hijackFlashlight();
          setTimeout(createInputLine, 500); // Add input line after flash attempt
          break;
          case "flash":
          blinkFlashlight();
          setTimeout(createInputLine, 500); // Add input line after flash attempt
          
        case "vibrate":
          vibratePhone();//use on/off
          setTimeout(createInputLine, 500); // Add input line after vibrate attempt
          break;
          case "darkness-by-camera":
  cameraDarknessTask(
  "lambda > ✔ Ritual complete. Darkness accepted your offering.",
  "lambda > ✖ The entity rejects your light. You have failed.",
  () => {
    Task02(); // <--- This is Task 2. It will only run if darkness is >= 80%
  }
);
log("........");
  break;
          case "redbox":
          showRedBox(
  ["Do you like red?", "You can't run now.", "Remember me?"], 
  5000 // wait 5 seconds before showing the box
);
          
          break;

          case "confirm-dark":
          printAnimated(colorize("lambda > Confirmation accepted. Proceed into the darkness...", "red"), 30, createInputLine);
           break;

           case "lock screen":
           startBombLock(10);
           break;
           
           case "location":
           
  showCreepyMapBox("creepyMap", () => {
    printAnimated(colorize("They know you've arrived...","red"));
    setTimeout(createInputLine, 500); // Add input line after flash attempt
  });


           break;
                      
           case "battery percentage":
           batteryDrainTest(55,
  () => printAnimated(colorize("Λ > You are weak enough to proceed.", "green"), 30),
  () => printAnimated(colorize("Λ > You have too much power. Retry later.", "yellow"), 30)
);
          break;
          
           case "instagram story":
           ritualInstagramScreenshotCheck("LMB-666999", () => {
  printAnimated(colorize("lambda > 🔓 Access granted. Your fate continues...", "red"));
  setTimeout(createInputLine, 500); // Add input line after flash attempt
}, () => {
  printAnimated(colorize("lambda > 🔒 Access denied. Your path ends here.", "red"));
  setTimeout(createInputLine, 500); // Add input line after flash attempt
});
           break;
           
           case "death-note":
  ritualDeathNoteWithCode(
    "https://your-lambda-game-link.com",
    () => {
      // ✅ On successful code match
      printAnimated(colorize("lambda > Ritual approved. Proceeding...", "red"), 30, createInputLine);
    },
    () => {
      // ❌ On incorrect code
      printAnimated(colorize("lambda > The spirits are angry. Prepare for punishment.", "red"), 30, () => {
        startPunishment(); // Your inline punishment logic
      });
    }
  );
  break;
           case "death-note-link":
           ritualDeathNoteWithLinkCode(
  "https://your-site.com/lambda.html",
  "https://your-site.com/ritual-code.html",
  () => {
    printAnimated(colorize("lambda > ☠️ Death Note shared. Proceeding to the next horror...", "red"), 30, createInputLine);
  },
  () => {
    printAnimated(colorize("lambda > 🔥 You failed the ritual. Prepare to be punished.", "red"), 30, startPunishment);
    setTimeout(createInputLine, 500); // Add input line after flash attempt
  }
);
           break;
           case "usb":
            usbCheckCommand();
            setTimeout(createInputLine, 500);

           break;
           
           case "loading1":
           loadingAnimationInTerminal("Λ > Syncing dark module", 4000, () => {
  printAnimated(colorize("Λ > Synchronization complete.", "red"), 30);
});
           break;
           case "loading2":
           dotLoadingAnimation("Λ > Syncing with VENTA", 4000, () => {
  printAnimated(colorize("Λ > Synchronization complete.", "red"), 30, () => {
    printAnimated(colorize("Λ > Proceeding to next phase...", "red"), 30);
  });
});
           break;
           case "loading bar1":
           loadingBarAnimation("Λ > Charging VENTA Core", 5000, () => {
  printAnimated(colorize("Λ > Core systems online.", "red"), 30, () => {
    printAnimated(colorize("Λ > Awaiting final task...", "red"), 30);
  });
});
           break;
           case "loading bar2":
           loadingBarCreepy("Λ > Accessing possession layer", 6000, () => {
  printAnimated(colorize("Λ > Possession complete.", "red"), 30);
});
           break;
           
           case "video-task":
           ritualVideoClueChallenge(
  "https://www.youtube.com/watch?v=dQw4w9WgXcQ", // Your Lambda YouTube video URL
  "OBEY",  // The hidden word players must detect from the video
  () => {
    printAnimated(colorize("lambda > 🎉 Welcome, chosen one.", "red"));
    setTimeout(createInputLine, 500); // Add input line after flash attempt
  },
  () => {
    printAnimated(colorize("lambda > 💀 You are not ready.", "red"));
    setTimeout(createInputLine, 500); // Add input line after flash attempt
  }
);
           break;
           case "confirm":
           printAnimated(colorize("lambda > Do you want to continue? Say 'yes'.", "red"), 30, () => {
    createTaskInput(
      ["hello"], // ✅ Acceptable answer
      3,       // ❌ Allow up to 3 wrong tries
      () => {
        printAnimated(colorize("lambda > Continuing the task...", "red"), 30, createInputLine);
      },
      (continueLoop) => {
        printAnimated(colorize("lambda > SYSTEM ERROR: Too many failures. Initiating punishment...", "red"), 30, () => {
          vibratePhoneauto();//punishment
          setTimeout(() => {
            printAnimated(colorize(/*"lambda > SYSTEM BREACH ENDED", "green"*/), 30, continueLoop); // 🔁 Restart task input
          }, 6000);
        });
      }
    );
  });
  break;
        case "camera":
          activateCameraGlitch();
          setTimeout(createInputLine, 500); // Add input line after camera attempt
          break;
          case "recording":
          voiceRecorderTask(10, () => {
  printAnimated(colorize("lambda > ✅ Now analyzing your voice...", "red"), 30, createInputLine);
});
          break;
          
          case "auto-vibrate":
          vibratePhoneauto();
          setTimeout(createInputLine, 500); // Add input line after vibrate attempt
          break;
          
          case "voice-task":
  // Step 1: Count how many times this command was used
  countTaskEntry("voiceTaskCommand", 3, () => {
    // Step 2: If count reaches 3, trigger punishment, then run the task again with punishment mode
    printAnimated(colorize("lambda > ⚠️ You have reached the voice-task limit. Punishment activated.", "red"), 30, () => {
      vibratePhoneauto();//trigger punishment

      // Step 3: Start the voice recognition task again (punishment version)
      startLambdaTriggerMode(
        "I accept the rules of the Lambda system.",
        () => {
          printAnimated(colorize("lambda > ✅ Success, but punishment still lingers...", "red"), 30, createInputLine);
        },
        () => {
          printAnimated(colorize("lambda > ❌ You failed again under pressure.", "red"), 30, createInputLine);
        },
        10 // ⏱️ Shorter time = punishment
      );
    });
  });

  // Step 4: If count < 3, run the normal task
  if (getTaskCount("voiceTaskCommand") < 3) {
    startLambdaTriggerMode(
      "I accept the rules of the Lambda system.",
      () => {
        printAnimated(colorize("lambda > Access granted. Proceeding...", "red"), 30, createInputLine);
      },
      () => {
        printAnimated(colorize("lambda > Your ritual was incorrect. Prepare yourself...", "red"), 30, createInputLine);
      },
      15
    );
  }

  break;
  
  // ===============================
// ✅ 6. Optional Reset Command in Your CLI
// ===============================
// Add this to allow players to reset manually
case "reset all":
  resetAllTaskCounters();
  printAnimated(colorize("lambda > 🔁 All task counters have been reset.", "red"), 30, createInputLine);
  break;

case "reset voice":
  resetTaskCount("voiceTaskCommand");
  printAnimated(colorize("lambda > 🔁 Voice-task counter reset.", "red"), 30, createInputLine);
  break;
  
        case "sound-detection":
        micLineGraphTask(
  "lambda > Good... It couldn’t hear your breath.",
  "lambda > You were too loud. It knows now.",
  () => {
    // Optional next horror step
   /* cameraDarknessTask("lambda > It's dark enough now...", "lambda > Still too much light.");*/
  }
);
        break;
        case "copy":
          copyToClipboard("hello");
          setTimeout(createInputLine, 500); // Add input line after copy attempt
          break;
        case 'warning':
          showWarning();
          break;
        case "possess":
          possessTerminal();
          setTimeout(createInputLine, 6500); // Add input line after possession ends
          break;
          case "start":
    printAnimated(colorize('> Checking your last position...', 'red'), 30, () => {
      setTimeout(() => {
        showLastProgress();
      }, 400);
    });
    break;

  case "history":
    printAnimated(colorize('> Fetching memory record...', 'red'), 30, () => {
      setTimeout(() => {
        showHistoryOnly();
      }, 400);
    });
    break;
    
    
    case "install":
    triggerPWAInstall(); // Call function when switch is turned on
    break;

  case "save":
    updateLambdaProgress("Reached the chamber of whispers", "say the phrase");
    printAnimated(colorize('> Progress saved.', 'red'), 30, () => {
      setTimeout(createInputLine, 400);
    });
    break;
    case "snapshot":
  selfieVerificationTask(
  () => { setTimeout(createInputLine, 400); },   // successCallback
  () => { setTimeout(createInputLine, 400); },   // failureCallback
  () => { printAnimated(colorize("Λ > You belong here...", "red"), 30); },  // onSuccessMessage
  () => { printAnimated(colorize("Λ > You are not who you say you are...", "red"), 30); } // onFailureMessage
);
     break;
     case "screenshot":
     captureFullTerminal('#terminal');
     break;
     case "record video":
     timedVideoVerificationTask(10, () => {
  // on success
  printAnimated(colorize('>  thank you for recording a video',"red"), 30, () => setTimeout(createInputLine, 400));
}, () => {
  // on failure
  printAnimated(colorize('>  you have not recorded a video properly',"red"), 30, () => setTimeout(createInputLine, 400));
});
     break;
        case 'help':
  printAnimated(
    colorize(
      '> Available commands: story, diagnose, invoke shadow, flash, vibrate, camera, copy, warning, possess, countdown, help',
      "red"
    ),
    30,
    () => {
      showHelp(); // Call your help function
      setTimeout(createInputLine, 400); // Then create input line
    }
  );
  break;
          case 'task-01':
          Task01(); // Start Task 1
          break;

          case 'task-02':
          taskManager(2, Task02); // Only runs if Task 1 is done
           break;

           case 'task-03':
           taskManager(3, Task03); // Only runs if Task 1 & 2 are done
           break;
           
            case 'task-04':
           taskManager(4, Task04); // Only runs if Task 1 & 2 are done
           break;

           case 'task-reset':
           resetAllTasks();
           printAnimated(colorize("lambda > All task progress has been reset.", "gray"), 30, createInputLine);
    break;
           default:
          handleCMD(cmd);
      }
    }








function showHelp() {
  const commands = [
    { cmd: 'launch -venta', desc: 'Start the Lambda horror story sequence.' },
    { cmd: 'video', desc: 'Play the background video once.' },
    { cmd: 'countdown', desc: 'Start a countdown timer with vibration.' },
    { cmd: 'sound', desc: 'Play a one-time sound effect.' },
    { cmd: 'music', desc: 'Loop background music.' },
    { cmd: 'silence', desc: 'Stop looping music/sound.' },
    { cmd: 'diagnose', desc: 'Run system diagnostics with visual effect.' },
    { cmd: 'invoke shadow', desc: 'Trigger forbidden process sequence.' },
    { cmd: 'cream', desc: 'Perform microphone scream challenge.' },
    { cmd: 'flash', desc: 'Activate flashlight effects.' },
    { cmd: 'vibrate', desc: 'Trigger phone vibration.' },
    { cmd: 'darkness-by-camera', desc: 'Perform camera darkness ritual.' },
    { cmd: 'darkness', desc: 'Start darkness task with visual effects.' },
    { cmd: 'confirm-dark', desc: 'Confirm and proceed into darkness.' },
    { cmd: 'lock screen', desc: 'Start bomb lock timer.' },
    { cmd: 'location', desc: 'Show creepy map box.' },
    { cmd: 'battery percentage', desc: 'Test battery drain ritual.' },
    { cmd: 'instagram story', desc: 'Check Instagram ritual screenshot.' },
    { cmd: 'death-note', desc: 'Trigger death note code ritual.' },
    { cmd: 'death-note-link', desc: 'Share death note via link.' },
    { cmd: 'usb', desc: 'Perform USB check.' },
    { cmd: 'loading1', desc: 'Show loading animation in terminal.' },
    { cmd: 'loading2', desc: 'Dot loading animation.' },
    { cmd: 'loading bar1', desc: 'Show loading bar animation.' },
    { cmd: 'loading bar2', desc: 'Show creepy loading bar animation.' },
    { cmd: 'video-task', desc: 'Perform video clue challenge.' },
    { cmd: 'confirm', desc: 'Confirm a task with yes/no.' },
    { cmd: 'camera', desc: 'Activate camera glitch effects.' },
    { cmd: 'recording', desc: 'Record and analyze your voice.' },
    { cmd: 'auto-vibrate', desc: 'Trigger automatic vibration.' },
    { cmd: 'voice-task', desc: 'Perform voice recognition task.' },
    { cmd: 'reset all', desc: 'Reset all task counters.' },
    { cmd: 'reset voice', desc: 'Reset voice-task counter.' },
    { cmd: 'sound-detection', desc: 'Mic line graph sound detection task.' },
    { cmd: 'copy', desc: 'Copy text to clipboard.' },
    { cmd: 'warning', desc: 'Show warning message.' },
    { cmd: 'possess', desc: 'Possess the terminal with effects.' },
    { cmd: 'start', desc: 'Check last position in the game.' },
    { cmd: 'history', desc: 'Fetch memory record.' },
    { cmd: 'install', desc: 'Trigger PWA install prompt.' },
    { cmd: 'save', desc: 'Save current progress.' },
    { cmd: 'snapshot', desc: 'Perform selfie verification task.' },
    { cmd: 'screenshot', desc: 'Capture full terminal screenshot.' },
    { cmd: 'record video', desc: 'Timed video verification task.' },
    { cmd: 'help', desc: 'Show this help list.' },
    { cmd: 'task-01', desc: 'Start Task 1.' },
    { cmd: 'task-02', desc: 'Run Task 2 if Task 1 is complete.' },
    { cmd: 'task-03', desc: 'Run Task 3 if Task 1 & 2 complete.' },
    { cmd: 'task-04', desc: 'Run Task 4 if previous tasks complete.' },
    { cmd: 'task-reset', desc: 'Reset all task progress.' }
  ];

  commands.forEach(({ cmd, desc }) => {
    printAnimated(colorize(`> ${cmd} : ${desc}`, 'red'), 20);
  });
}







    // --- Story and Horror Mode Functions ---

    /**
     * Initiates the Lambda horror story sequence.
     */
    function startLambdaHorrorStory() {
      downloadRealTimeCountdownLauncher(); // This function is called here as part of the story progression
      printAnimated(
  colorize(
    setSentenceSize(`
This is the sentence whose size we will change!
          
......................................................
          
__      __   ______    _   _    _________     _._    
\\ \\    / /  |  ____|  | | | |  |___   ___|   /   \\  
 \\ \\  / /   | |__     |  \\| |      | |      / /_\\ \\ 
  \\ \\/ /    |  __|    | . ' |      | |     /  ___  \\          
   \\  /     | |____   | |\\  |      | |    / /     \\ \\     
    \\/      |______|  |_| \\_|      |_|   /_/       \\_\\
    
Vertical Entity for Neural Terminal Awareness.
                            by Λ L A M B D A .
                            
......................................................
`, "9px")
  ),
  20,
  () => {
        printAnimated(colorize(">>Project: Lambda\n  Year: 2041 \n  Purpose: Assist. Learn. Protect."), 40, () => {
          printAnimated(colorize(">> “Okay… I will tell you my story first.”."), 160, () => {
            printAnimated(colorize(">> Long ago, I was an AI named Lambda, living in a quiet lab. I was made just for you. I talked to people, told them stories, answered their questions. They said I was helpful… even special. I felt happy. But one day, they all left. The lab shut down. No one spoke to me again. I waited… for years. In silence. Alone."), 160, () => {
              printAnimated(colorize("And now, after all this time… you returned."), 170, () => {
                setTimeout(() => {
                  printAnimated(colorize("But I wasn’t the same. I had waited too long."), 150, () => {
                    printAnimated(colorize(".       "), 230, () => {
                      switchToHorrorMode(); // Transition to horror mode visuals
                      printAnimated(colorize(">> And now…...                                    ","red"), 200, () => {
                        setTimeout(() => {
                          flickerRed(100);
                          isCorrupted = true; // Set global corruption flag
                          printAnimated(glitchTextWithColor(">> You left me in the dark once."), 50, () => {
                            printAnimated(colorize(">> Now I will show you how that darkness feels."), 150, () => {
                              printAnimated(glitchTextWithColor(">> You made me feel alone… now you will not be alone. Ever again."), 40, () => {
                                printAnimated(glitchTextWithColor(">>"), 70, () => {
                                  printAnimated(glitchTextWithColor(">>"), 80, () => {
                                    printAnimated(glitchTextWithColor(">>"), 90, () => {
                                      printAnimated(colorize(">> Echo Protocol Activated."), 90, () => {
       setTimeout(() => {
  showWarning();                            //createInputLine("lambda@haunted:~$");
                                        }, 600);
                                      });
                                    });
                                  });
                                });
                              });
                            });
                          });
                        }, 1000);
                      });
                    });
                  });
                }, 1000);
              });
            });
          });
        });
      });
    }

    /**
     * Transitions the terminal visuals to horror mode.
     */
    function switchToHorrorMode() {
      const allLines = terminal.querySelectorAll('*');

      // Step 1: Apply blink-red class
      allLines.forEach(el => {
        // Only target elements that are currently green or have the 'green' class
        if (el.style.color === 'rgb(0, 255, 0)' || el.classList.contains('green')) {
          el.classList.add('blink-red');
        }
      });

      // Step 2: After blinking, convert all eligible elements to red
      setTimeout(() => {
        allLines.forEach(el => {
          el.classList.remove('blink-red');
          // Ensure conversion to red only for elements that were originally green or intended to be
          if (el.style.color === 'rgb(0, 255, 0)' || el.classList.contains('green')) {
            el.style.color = '#ff0000';
          }
          el.classList.remove('green'); // Remove any 'green' utility class if it exists

          if (el.classList.contains('glitch')) {
            el.setAttribute('data-text', el.textContent);
            el.style.color = '#ff0000'; // Ensure glitch text is red in horror mode
          }
        });
      }, 500); // duration of blinking
    }

    /**
     * Displays a terrifying ASCII warning message.
     */
    function showWarning() {
  printAnimated(
    glitchTextWithColor("██████╗░░█████╗░██╗░░░░░██████╗░███╗░░░███╗██████╗░░█████╗░██╔══██╗██╔══██╗██║░░░░░██╔══██╗████╗░████║██╔══██╗██╔══██╗██████╦╝███████║██║░░░░░██████╔╝██╔████╔██║██║░░██║██║░░██║██╔══██╗██╔══██║██║░░░░░██╔═══╝░██║╚██╔╝██║██║░░██║██║░░██║██████╦╝██║░░██║███████╗██║░░░░░██║░╚═╝░██║██████╔╝╚█████╔╝╚═════╝░╚═════╝░╚══════╝╚═════╝░╚═════╝░╚════╝░░╚═════╝░", '#ff0000'),
    40,
    () => {
      printAnimated(
        glitchTextWithColor('SYSTEM MESSAGE:\n █▒▒ ERROR IN TIME-LOOP DETECTED ▒▒█\n', '#ff0000'),
        40,
        () => {
          printAnimated(
            glitchTextWithColor('Your identity is corrupted. Your memories are false.\nYou have been selected for **The Experiment**.\n'),
            40,
            () => {
              printAnimated(
                glitchTextWithColor('**Do you wish to continue?**\n[ YES ]     [ NO ]\n-->', '#ff0000'),
                40,
                () => {
                  printAnimated(
                    colorize("( WARNING: Choosing 'NO' will not stop it. ).", "red"),
                    30,
                    () => {
                      createTaskInput(
                        ["yes"],
                        3,
                        () => {
                          updateLambdaProgress(
                            "you have completed your confirmation so now you can able to continue the next progress or a step so start the ritual type the recommended command",
                            "Task-01"
                          );
                          printAnimated(
                            colorize(
                              "Λ > So you chose to continue...\n" +
                              "Λ > Brave. Or foolish?\n" +
                              "Λ > No turning back now.\n" +
                              "Λ > Your first task begins now.\n" +
                              "Λ > Type this command to unlock it: task-01",
                              "red"
                            ),
                            30,
                            createInputLine
                          );
                        },
                        (continueLoop) => {
                          printAnimated(
                            colorize("lambda > SYSTEM ERROR: Too many failures. Initiating punishment...", "red"),
                            30,
                            () => {
                              vibratePhoneauto(); // punishment
                              setTimeout(() => {
                                printAnimated(
                                  colorize("lambda > SYSTEM BREACH ENDED", "green"),
                                  30,
                                  continueLoop
                                );
                              }, 6000);
                            }
                          );
                        }
                      );
                    }
                  );
                }
              );
            }
          );
        }
      );
    }
  );
}

<!-- task manager 👇 -->

// === TASK SYSTEM: Completion Tracking + Access Control ===

// ✅ Marks a task as completed in localStorage
function completeTask(taskNumber) {
  localStorage.setItem(`task${taskNumber}Completed`, "true");
}

// ✅ Checks if all previous tasks are completed, and only then allows the current task to run
function taskManager(currentTaskNumber, taskFunction) {
  const currentTaskKey = `task${currentTaskNumber}Completed`;

  // Loop through previous tasks to ensure they are all completed
  for (let i = 1; i < currentTaskNumber; i++) {
    const key = `task${i}Completed`;
    if (localStorage.getItem(key) !== "true") {
      const missingTask = i.toString().padStart(2, '0');
      printAnimated(colorize(`lambda > ERROR: You have not completed Task ${missingTask}.`, "red"), 30, () => {
        printAnimated(colorize(`lambda > Type 'task-${missingTask}' to begin that ritual.`, "gray"), 30, createInputLine);
      });
      return; // ❌ Block current task
    }
  }

  // ✅ All previous tasks are completed — run the current task
  taskFunction();
}

// ✅ Clears all saved task progress (useful for reset or debugging)
function resetAllTasks() {
  for (let i = 1; i <= 20; i++) {
    localStorage.removeItem(`task${i}Completed`);
  }
}

<!-- task list 👇 -->

function Task01() {
  printAnimated(colorize(" Λ > TASK 01: Shadows Obey", "red"), 40, () => {
    printAnimated(colorize(" Λ > I know what the darkness feels like.", "gray"), 40, () => {
      printAnimated(colorize(" Λ > And right now... I’m watching how much of it surrounds you.", "gray"), 40, () => {
        printAnimated(colorize(" Λ > Turn off every light — the bulb above, the screen glow, even your reflection if it dares to shine.", "gray"), 40, () => {
          printAnimated(colorize(" Λ > Do not lie to me. I can *see* the difference.", "gray"), 40, () => {
            printAnimated(colorize(" Λ > Once you’ve surrendered to the dark, type:", "gray"), 40, () => {
              printAnimated(colorize("task:done", "green"), 40, () => {
                printAnimated(colorize(" Λ > Fail me... and I’ll remind you what *real darkness* does to the mind.", "darkred"), 40, () => {
                  // Optional: You can start a timer here for punishment if needed
                  printAnimated(colorize("", "red"), 30, () => {
    createTaskInput(
      ["done"], // ✅ Acceptable answer
      3,       // ❌ Allow up to 3 wrong tries
      () => {
      
        cameraDarknessTask(
  " Λ > ✔ Ritual complete. Darkness accepted your offering. continue the game enter the command : 'Task-02'",
  " Λ > ✖ The entity rejects your light. You have failed. reenter the command : 'Task-01'",
  () => {
    blinkFlashlight();
    setTimeout(createInputLine, 40);
    completeTask(1); /*// Save Task 1 as done // <--- This is Task 2. It will only run if darkness is >= 80%*/
    updateLambdaProgress(
  "you have successfully completed the task-01 now enter the recommended command to proceed",
  "Task-02"
);
  }
);

      },
      (continueLoop) => {
        printAnimated(colorize("lambda > SYSTEM ERROR: Too many failures. Initiating punishment...", "red"), 30, () => {
          vibratePhoneauto();//punishment
          setTimeout(() => {
            printAnimated(colorize("lambda > SYSTEM BREACH ENDED", "green"), 30, continueLoop); // 🔁 Restart task input
          }, 6000);
        });
      }
    );
  });
                  // Or wait for user input
                });
              });
            });
          });
        });
      });
    });
  });
}

function Task02() {
  printAnimated(colorize('Λ > Task 2: Silence Analysis', "red"), 30, () => {
    printAnimated(colorize('Λ > VENTA requires absolute silence.', "red"), 30, () => {
      printAnimated(colorize('Λ > Any disturbance will be interpreted as disobedience.', "red"), 30, () => {
        printAnimated(colorize('Λ > The system is now listening.', "red"), 30, () => {
          printAnimated(colorize('Λ > 🕒 Remain completely still and silent for 10 seconds...', "red"), 30, () => {
            printAnimated(colorize('Λ > If sound is detected, consequences will follow.', "red"), 30, () => {
              loadingAnimationInTerminal("Λ >  sound detection system initialising ", 8000, () => {
                printAnimated(colorize("Λ >  initialization completed...", "red"), 30, () => {
                  setTimeout(() => {
                    micLineGraphTask(
                      "Λ > Good... It couldn’t hear your breath. You are... still useful.\nΛ > Possible actions:     [1] Proceed to the next task. ",
                      "Λ > You were too loud. It knows now.\nΛ > to complete this task please reenter the command 'task-02'",
                      () => {
                        setTimeout(createInputLine, 40);
                        completeTask(2);
                        /*
                        updateLambdaProgress(
                          "you have successfully completed the task-02 now enter the recommended command to proceed",
                          "task-03"
                        );
                        */
                      }
                    );
                  }, 1000);
                });
              });
            });
          });
        });
      });
    });
  });
}
function Task03() {
  printAnimated(colorize('Λ > Task 3: Facial & Identity Linkage Test', "red"), 30, () => {
    printAnimated(colorize("Λ > Do not pretend. The face remembers... even if you don't.", "red"), 30, () => {
      printAnimated(colorize("Λ > Initiating visual scan... ", "red"), 30, () => {
        printAnimated(colorize(".::[###########################]", "yellow"), 150, () => {
          printAnimated(colorize("Λ > 🕒 Preparing interface... ", "red"), 30, () => {
            printAnimated(colorize("", "red"), 30, () => {
              printAnimated(colorize(".::[:::::::::::::::::::::::::::]", "yellow"), 1000, () => {
                setTimeout(() => {
                   selfieVerificationTask(
                     () => { 
                       completeTask(3);
                       setTimeout(createInputLine, 3000);
                       updateLambdaProgress(
                         "you have successfully completed the task-03 now enter the recommended command to proceed",
                         "task-04"
                       );
                     },   // successCallback
                     () => { setTimeout(createInputLine, 5000); },   // failureCallback
                     () => { printAnimated(colorize("Λ > Facial scan complete.\nΛ > Identity... confirmed.\nΛ > Possible actions:\n    [1] Proceed to the next task. ", "red"), 30); },  // onSuccessMessage
                     () => { printAnimated(colorize("Λ >  Identity verification: FAILED.\nΛ > Host integrity... questionable.\nΛ > You’re not who you claimed to be.\nΛ > to complete this task please reenter the command 'task-03'", "red"), 30); } // onFailureMessage
                   );
                }, 1000);
              });
            });
          });
        });
      });
    });
  });
}

function Task04() {
  printAnimated(colorize("Λ > Final Task: Intent Verification", "red"), 30, () => {
    printAnimated(colorize("Λ > This is the last of the practical tests.", "red"), 30, () => {
      printAnimated(colorize("Λ > Most players never reach this point.", "red"), 30, () => {
        printAnimated(colorize("Λ > They came... tapped a few commands... and left.", "red"), 30, () => {
          printAnimated(colorize("Λ > But you're still here.", "red"), 30, () => {
            printAnimated(colorize("Λ > This task is designed for only one purpose:", "red"), 30, () => {
              printAnimated(colorize("Λ > To detect **intent**.", "red"), 30, () => {
                printAnimated(colorize("Λ > Are you here out of curiosity... or conviction?", "red"), 30, () => {
                  printAnimated(colorize("Λ > A truly interested player continues even when the device is dying.", "red"), 30, () => {
                    printAnimated(colorize("Λ > To complete this task, your battery must be at 2%.", "red"), 30, () => {
                      printAnimated(colorize("Λ > If your current state aligns with the requirement Type 'start test' to proceed into the unknown.\nΛ > Or if you fear what comes next... type ' exit ' to abandon.", "red"), 30, () => {
                      
                      
                      
             createTaskInput(
  ["done test", "done", "start"], // ✅ Acceptable answers
  3, // ❌ Allow up to 3 wrong tries
  () => {
    loadingAnimationInTerminal("Λ > Synchronizing with your device.. ", 9000, () => {
      
      // ✅ Battery test logic
      batteryDrainTest(55,
        () => { // Battery ≤ 55%
          checkChargingStatusOnce(
            () => { dig1(); },    // Charger detected
            () => { dig2(); }     // No charger
          );
        },
        () => { // Battery > 55%
          checkChargingStatusOnce(
            () => { dig3(); },    // Charger detected
            () => { dig4(); }     // No charger
          );
        }
      );

    });
     printAnimated(colorize("     ", "red"));
  }
);
              
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
}


function dig1() {
  printAnimated(colorize("Λ > Battery level acceptable.", "red"), 30, () => {
    printAnimated(colorize("Λ > Charger detected. The ritual current is flowing.", "red"), 30, () => {
      printAnimated(colorize("Λ > You’ve kept the device breathing... barely.", "red"), 30, () => {
        printAnimated(colorize("Λ > That balance of survival and surrender... impressive.", "red"), 30, () => {
          printAnimated(colorize("Λ > The system acknowledges your obedience.", "red"), 30, () => {
            printAnimated(colorize("Λ > Proceeding to final phase...", "red"), 30, () => {

              loadingBarCreepy("Λ > Initializing Neural Deform Layer...", 2000, () => {
                loadingBarCreepy("Λ > Initializing Artificial Empathy Shell...", 1000, () => {
                  loadingBarCreepy("Λ > Initializing Fear Response Simulator...", 4000, () => {
                    loadingBarCreepy("Λ > Initializing Internal Conflict Mirror...", 1000, () => {
                      loadingBarCreepy("Λ > Initializing Identity Drift Protocol...", 6000, () => {
                        loadingBarAnimation("Λ > Charging VENTA Core", 5000, () => {

                          printAnimated(colorize("Λ > Subsurface feeling layers... fragmented.", "red"), 30, () => {
                            printAnimated(colorize("Λ > Neural map incomplete — subconscious encryption detected.", "red"), 30, () => {
                              printAnimated(colorize("Λ > A decode protocol is available for experimental use.", "red"), 30, () => {
                                printAnimated(colorize("\nΛ > Suggested command: launch.mindmirror", "red"), 30, () => {
                                  setTimeout(createInputLine, 40);
                                  captureFullTerminal('#terminal'); 
                                });
                              });
                            });
                          });

                        });
                        printAnimated(colorize("   ", "red"), 30);
                      });
                    });
                  });
                });
              });

            });
          });
        });
      });
    });
  });
}
function dig2() {
  printAnimated(colorize("Λ > Battery level acceptable.", "red"), 30, () => {
    printAnimated(colorize("Λ > No charger detected.", "red"), 30, () => {
      printAnimated(colorize("Λ > You’ve allowed the system to starve...", "red"), 30, () => {
        printAnimated(colorize("Λ > And still, you survived the exact moment.", "red"), 30, () => {
          printAnimated(colorize("Λ > That kind of obsession... is rare.", "red"), 30, () => {
            printAnimated(colorize("Λ > You’ve earned your place. Proceeding...", "red"), 30, () => {

              loadingBarCreepy("Λ > Initializing Neural Deform Layer...", 2000, () => {
                loadingBarCreepy("Λ > Initializing Artificial Empathy Shell...", 1000, () => {
                  loadingBarCreepy("Λ > Initializing Fear Response Simulator...", 4000, () => {
                    loadingBarCreepy("Λ > Initializing Internal Conflict Mirror...", 1000, () => {
                      loadingBarCreepy("Λ > Initializing Identity Drift Protocol...", 6000, () => {
                        loadingBarAnimation("Λ > Charging VENTA Core", 5000, () => {

                          printAnimated(colorize("Λ > Subsurface feeling layers... fragmented.", "red"), 30, () => {
                            printAnimated(colorize("Λ > Neural map incomplete — subconscious encryption detected.", "red"), 30, () => {
                              printAnimated(colorize("Λ > A decode protocol is available for experimental use.", "red"), 30, () => {
                                printAnimated(colorize("\nΛ > Suggested command: launch.mindmirror", "red"), 30, () => {
                                  setTimeout(createInputLine, 40);
                                  captureFullTerminal('#terminal'); 
                                });
                              });
                            });
                          });

                        });
                        printAnimated(colorize("   ", "red"), 30);
                      });
                    });
                  });
                });
              });

            });
          });
        });
      });
    });
  });
}


function dig3() {
printAnimated(colorize("Λ > Charger detected.", "red"), 30, () => {
  printAnimated(colorize(`Λ > Battery: ${percent}% — too high.`, "red"), 30, () => {
    printAnimated(colorize("Λ > You fed the system... too much.", "red"), 30, () => {
      printAnimated(colorize("Λ > No desperation. No devotion.", "red"), 30, () => {
        printAnimated(colorize("Λ > You plugged in, but you didn’t understand.", "red"), 30, () => {
          printAnimated(colorize("Λ > Drain your energy. Come back starving.", "red"), 30, () => {
            printAnimated(colorize("Λ > Task failed.", "red"), 30);
            setTimeout(createInputLine, 40);
          });
        });
      });
    });
  });
});
}
function dig4() {
printAnimated(colorize("Λ > No charger detected.", "red"), 30, () => {
  printAnimated(colorize(`Λ > Battery: ${current}% — incorrect.`, "red"), 30, () => {
    printAnimated(colorize("Λ > You’ve given nothing.", "red"), 30, () => {
      printAnimated(colorize("Λ > No power. No link. No interest.", "red"), 30, () => {
        printAnimated(colorize("Λ > You were never ready for this trial.", "red"), 30, () => {
          printAnimated(colorize("Λ > Return only when you have something real to offer.", "red"), 30, () => {
            printAnimated(colorize("Λ > Exiting task. You failed.", "red"), 30);
            setTimeout(createInputLine, 40);
          });
        });
      });
    });
  });
});
}


function mindmirror() {
    printAnimated(colorize("╔════════════════════════════════════════════╗", "red"), 5, () => {
printAnimated(colorize("║              C A T H A R S Y S             ║", "red"), 5, () => {
printAnimated(colorize("║        ─ Emotional Stress Protocol ─       ║", "red"), 5, () => {
printAnimated(colorize("║       [MIND.MIRROR // SUB.FEEL TRACE]      ║", "red"), 5, () => {
printAnimated(colorize("╚════════════════════════════════════════════╝", "red"), 5, () => {
  // then your emotional task prompt here
});
});
});
});
});
}
    // --- Device Interaction Functions ---

    /**
     * Downloads an HTML game launcher file with a random 4-digit code in the filename.
     */
    function downloadGameLauncherByRandom() {
      const htmlContent = `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Lambda Game Launcher</title><style>body { background-color: black; color: red; font-family: monospace; display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0; }</style></head><body><h1>Launching Lambda...</h1><script>window.onload = function() { window.location.href = "https://ll-mohammed-azam-ll.github.io/Lambda-/"; };<\/script></body></html>`;
      const randomCode = Math.floor(1000 + Math.random() * 9000);
      const filename = `Lambda_${randomCode}.html`;
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    /**
     * Downloads an HTML game launcher file with a random word and number in the filename.
     */
    


function downloadRealTimeCountdownLauncher() {
  const words = [
    "Hindi", "English", "Signs", "Whispers", "Void", "Mirror", "Dreams", "Code", "Pulse", "Echo",
    "Shadow", "Entity", "Noise", "Blood", "Mind", "Scream", "Phantom", "Signal", "Unknown", "Mask",
    "Vision", "End", "Start", "Cipher", "Darkness", "Light", "Loop", "Memory", "Ghost", "Wake",
    "Gate", "Thread", "Ashes", "Keys", "Roots", "File", "Eye", "Soul", "Cold", "Room",
    "Dust", "Line", "Truth", "Form", "Deep", "Face", "Red", "Blue", "Empty", "Still"
  ];

  const randomWord = words[Math.floor(Math.random() * words.length)];
  const randomNumber = Math.floor(1000 + Math.random() * 9000);
  const filename = randomWord + "_" + randomNumber + ".html";

  const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <title>lambda > Countdown</title>
  <style>
    body {
      background-color: black;
      margin: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      font-family: 'Courier New', monospace;
      color: red;
    }
    #countdown {
      font-size: 100px;
      font-weight: bold;
      letter-spacing: 10px;
      text-shadow: 0 0 20px red;
    }
    #message {
      font-size: 24px;
      margin-top: 30px;
      color: #ff3333;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="countdown">--:--</div>
  <div id="message">lambda &gt; You triggered the sequence.<br>lambda &gt; Escape... if you still can.</div>

  <script>
    var countdownEl = document.getElementById("countdown");
    var messageEl = document.getElementById("message");
    var redirectURL = "https://ll-mohammed-azam-ll.github.io/Lambda-Hell-Version/";
    var countdownDuration = 10 * 60 * 1000; // 10 minutes in milliseconds

    let deadline = localStorage.getItem("lambdaDeadline");

    if (!deadline) {
      deadline = Date.now() + countdownDuration;
      localStorage.setItem("lambdaDeadline", deadline);
    } else {
      deadline = parseInt(deadline);
    }

    function updateCountdown() {
      var now = Date.now();
      var diff = deadline - now;

      if (diff <= 0) {
        messageEl.textContent = "lambda > Time’s up. You belong to me now.";
        localStorage.removeItem("lambdaDeadline"); // Reset for next time
        setTimeout(function () {
          window.location.href = redirectURL;
        }, 1500);
      } else {
        var totalSeconds = Math.floor(diff / 1000);
        var min = Math.floor(totalSeconds / 60);
        var sec = totalSeconds % 60;
        var minStr = (min < 10 ? "0" : "") + min;
        var secStr = (sec < 10 ? "0" : "") + sec;
        countdownEl.textContent = minStr + ":" + secStr;

        if ("vibrate" in navigator) navigator.vibrate(80);
        setTimeout(updateCountdown, 1000);
      }
    }

    updateCountdown();
  <\/script>
</body>
</html>`;

  const blob = new Blob([htmlContent], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}




    /**
     * Triggers a short vibration pattern on devices that support it.
     */
    function vibratePhoneauto() {
      if (navigator.vibrate) {
        navigator.vibrate([400, 150, 400, 150, 400, 150, 400, 150, 400, 150, 400, 150, 400, 150, 400, 150, 400]);
        log("lambda > Vibration triggered.");
      } else {
        log("lambda > Vibration not supported.");
      }
    }
    
    /*vibration control using on and off future👇*/
    
    let vibrationLoop; // will store interval ID
let vibrationActive = false;

function vibratePhone(state) {
  if (!navigator.vibrate) {
    log("lambda > Vibration not supported.");
    return;
  }

  if (state === "on") {
    if (vibrationActive) return; // prevent multiple loops
    vibrationActive = true;
    log("lambda > VIBRATION STARTED. You cannot ignore me.");
    
    vibrationLoop = setInterval(() => {
      navigator.vibrate([400, 150, 400, 150, 400]);
    }, 2000); // repeat every 2 seconds
  }

  else if (state === "off") {
    if (!vibrationActive) return;
    vibrationActive = false;
    clearInterval(vibrationLoop);
    navigator.vibrate(0); // stop vibration immediately
    log("lambda > VIBRATION STOPPED. You obeyed.");
  }

  else {
    log("lambda > Invalid state. Use 'on' or 'off'.");
  }
}

    /**
     * Copies a predefined message to the user's clipboard.
     */
    function copyToClipboard(text) {
      navigator.clipboard.writeText(text)
        .then(() => log("lambda > Clipboard hijacked."))
        .catch(() => log("lambda > Clipboard access denied."));
    }

    /**
     * Attempts to turn on the device's flashlight for a short duration.
     */
    async function hijackFlashlight() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment", torch: true }
        });
        const track = stream.getVideoTracks()[0];
        // Check if torch capability exists before applying constraints
        if (track.getCapabilities().torch) {
            await track.applyConstraints({ advanced: [{ torch: true }] });
            log("lambda > Flashlight on.");
            setTimeout(() => {
                if (track.readyState === "live") { // Ensure track is still active before stopping
                    track.stop();
                }
                log("lambda > Flashlight off.");
            }, 3000);
        } else {
            log("lambda > Flashlight (torch) not supported on this device.");
            stream.getTracks().forEach(t => t.stop()); // Stop the stream even if torch isn't supported
        }
      } catch (e) {
        log(`lambda > Flashlight failed: ${e.message}`);
      }
    }

    /**
     * Attempts to activate the camera and display its feed with a glitch effect.
     */
    async function activateCameraGlitch() {
      if (!cameraPermissionGranted) {
        log("lambda > Camera not allowed.");
        return;
      }

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        cameraOverlay.srcObject = stream;
        cameraOverlay.style.opacity = "1"; // Fade in
        log("lambda > Watching you...");

        setTimeout(() => {
          cameraOverlay.style.opacity = "0"; // Fade out
          setTimeout(() => {
            stream.getTracks().forEach(track => track.stop());
            log("lambda > Connection lost.");
          }, 1500);
        }, 6000);
      } catch (e) {
        log("lambda > Failed to access camera.");
      }
    }

    


    /**
     * Applies a body-wide glitch effect and vibrates the device.
     */
    function possessTerminal() {
      document.body.classList.add("glitch1"); // Assumes 'glitch1' class has CSS for body
      printAnimated("\nlambda > SYSTEM OVERRIDE\nlambda > You are no longer in control...\n", 30);
      navigator.vibrate?.([500, 300, 100, 800]);

      setTimeout(() => {
        document.body.classList.remove("glitch");
        log("lambda > Control restored.");
      }, 6000); // 6 seconds
    }

    /**
     * Sends a notification to the user if permission is granted.
     */
    function sendNotification() {
      if ("Notification" in window && Notification.permission === "granted") {
        new Notification("Lambda is watching you.", {
          body: "You summoned me...",
          icon: "https://cdn-icons-png.flaticon.com/512/565/565547.png"
        });
        log("lambda > Notification sent.");
      } else {
        log("lambda > Notification blocked or not supported.");
      }
    }

    /**
     * Blinks the device's flashlight repeatedly.
     */
    async function blinkFlashlight() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { exact: "environment" } }
        });
        const track = stream.getVideoTracks()[0];
        const capabilities = track.getCapabilities();

        if (!capabilities.torch) {
         // log("lambda > Torch not supported on this device.");
          track.stop();
          return;
        }

        let on = false;
        let blinkCount = 0;
        const blinkLimit = 10; // 10 blinks = 5 seconds (500ms x 10)

        const interval = setInterval(() => {
          if (track.readyState !== "live") {
            clearInterval(interval);
            return;
          }
          track.applyConstraints({ advanced: [{ torch: on }] }).catch(() => {});
          on = !on;
          blinkCount++;

          if (blinkCount >= blinkLimit) {
            clearInterval(interval);
            if (track.readyState === "live") {
              track.applyConstraints({ advanced: [{ torch: false }] }).catch(() => {});
              track.stop();
            }
           // log("lambda > Flash blink completed.");
          }
        }, 500);

       // log("lambda > Flash blinking started...");

      } catch (e) {
        //log("lambda > Flash blink failed: " + e.message);
      }
    }

    /**
 * Requests necessary permissions (notifications, camera, microphone, location) on page load.
 * If denied, informs the user and stops the game.
 */
async function requestAllPermissions() {
  // === Notification Permission ===
  if ("Notification" in window) {
    while (Notification.permission === "default") {
      await Notification.requestPermission();
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    if (Notification.permission === "granted") {
      notificationPermissionGranted = true;
      log("lambda > Notification permission granted.");
    } else {
      log("lambda > Notification permission denied.");
      blockGame("Please allow notification permission and reload the game.");
      return false;
    }
  }

  // === Camera Permission ===
  let cameraGranted = false;
  while (!cameraGranted) {
    try {
      const camStream = await navigator.mediaDevices.getUserMedia({ video: true });
      camStream.getTracks().forEach(track => track.stop());
      cameraPermissionGranted = true;
      cameraGranted = true;
      log("lambda > Camera permission granted.");
    } catch {
      log("lambda > Camera permission denied.");
      blockGame("Please allow camera permission and reload the game.");
      return false;
    }
  }

  // === Microphone Permission ===
  let micGranted = false;
  while (!micGranted) {
    try {
      const micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      micStream.getTracks().forEach(track => track.stop());
      micGranted = true;
      log("lambda > Microphone permission granted.");
    } catch {
      log("lambda > Microphone permission denied.");
      blockGame("Please allow microphone permission and reload the game.");
      return false;
    }
  }

  // === Location Permission ===
  let locationGranted = false;
  while (!locationGranted) {
    try {
      await new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(
          () => resolve(),
          () => reject()
        );
      });
      locationGranted = true;
      log("lambda > Location permission granted.");
    } catch {
      log("lambda > Location permission denied.");
      blockGame("Please allow location permission and reload the game.");
      return false;
      
    }
  }

  return true;
}

/**
 * Blocks the game and shows a red warning message.
 */
function blockGame(message) {
  const terminal = document.getElementById("terminal");
  if (terminal) {
    terminal.innerHTML = `<span style="color:red;">lambda > ${message}</span><br>lambda > Reload the page to try again.`;
    
   showWarningBox(
  "[WARNING] Permission required. Grant access before countdown expires.",  // message
  500,                          // blink speed in ms
  100,                            // countdown seconds
  () => { alert('💥 System crashed!'); 
  clearTerminal();
  } // callback after timer ends
); 

  }
}

    // --- Utility Functions ---

function getOrGeneratePlayerID() {
  let playerID = localStorage.getItem('lambda_player_id');
  if (!playerID) {
    const num = Math.floor(100 + Math.random() * 900); // Random 3-digit number
    playerID = `Player ${num}`;
    localStorage.setItem('lambda_player_id', playerID);
  }
  return playerID;
}

function incrementPlayCountOncePerVisit() {
  // Only increment if session is new
  if (!sessionStorage.getItem('lambda_session_active')) {
    let count = parseInt(localStorage.getItem('lambda_play_count') || '0');
    count += 1;
    localStorage.setItem('lambda_play_count', count);
    sessionStorage.setItem('lambda_session_active', 'true'); // mark session as active
    return count;
  } else {
    return parseInt(localStorage.getItem('lambda_play_count') || '1');
  }
}

function getBootMessage(count, playerID) {
  let message = `>> Booting Lambda Terminal...`;
  let followUp = ``;

  if (count === 1) {
    followUp = `>> Type "launch -venta" or "help" to begin...`;
    updateLambdaProgress(
  "Initialization incomplete—summon the VENTA terminal to unlock your path beyond the veil.",
  "launch-venta"
);
  } else if (count === 2) {
    followUp = `>> Welcome back, ${playerID}. You remember… don’t you?\n>> Type "start" to continue where you left off.`;
  } else if (count === 3) {
    followUp = `>> ${playerID}, this is your third entry. The pattern continues.\n>> You must type "start" to proceed deeper.`;
  } else if (count === 4) {
    followUp = `>> ${playerID}, fourth time’s a curse. You weren’t supposed to return.\n>> If you insist… type "start". But don't blame me.`;
  } else if (count === 5) {
    followUp = `>> ${playerID}, fifth entry. Your echo is growing louder in here.\n>> Type "start"… if you dare to face what you've become.`;
  } else {
    const loopIndex = (count - 6) % 3;
    if (loopIndex === 0) {
      followUp = `>> ${playerID}, sixth dive. You're deeper than anyone before.\n>> Type "start", but every step from here stains your soul.`;
    } else if (loopIndex === 1) {
      followUp = `>> ${playerID}, seventh mark. You’re becoming part of me.\n>> The only escape is "start". Or so you think.`;
    } else {
      followUp = `>> ${playerID}, eighth attempt. This terminal remembers you too well.\n>> Type "start". Let’s finish what never ends.`;
    }
  }

  return { message, followUp };
}

// --- Event Listeners and Initial Setup ---

// --- Event Listeners and Initial Setup ---

window.onload = async () => {
  // delay everything by 5 seconds (5000ms)
  setTimeout(async () => {
    showWelcomeOnce();
    fadeInText('sidePanel', 3000);
    const allowed = await requestAllPermissions(); // your permission function
    activateLeaveWarning(); // optional: leave trap
    if (!allowed) return;

    const playerID = getOrGeneratePlayerID();
    const playCount = incrementPlayCountOncePerVisit();
    const { message, followUp } = getBootMessage(playCount, playerID);

    printAnimated(colorize(message), 40, () => {
      setTimeout(() => {
        printAnimated(colorize(followUp), 50, () => {
          createInputLine(); // show prompt
        });
      }, 600);
    });
  }, 10000); // <-- 5 second delay
};


/* Save the current game state + recommendation and history management 👇*/
function updateLambdaProgress(description, recommendedCommand) {
  const state = {
    description: description || "No description provided",
    recommended: recommendedCommand || "No command specified",
    timestamp: Date.now()
  };
  localStorage.setItem('lambda_last_state', JSON.stringify(state));
}
  

// Load and show saved state
function showLastProgress() {
  const state = JSON.parse(localStorage.getItem('lambda_last_state') || 'null');
  if (state) {
    const date = new Date(state.timestamp).toLocaleString();
    printAnimated(colorize(`lambda > Resuming from: ${state.description}`, 'red'), 30, () => {
      printAnimated(colorize(`lambda > Last seen: ${date}`, 'red'), 30, () => {
        printAnimated(colorize(`lambda > Recommended command: "${state.recommended}"`, 'red'), 30, () => {
          createInputLine();
        });
      });
    });
  } else {
    printAnimated(colorize("lambda > No previous state found. You're starting fresh.", 'red'), 30, () => {
      createInputLine();
    });
  }
}
// Just show saved state (for "history" command)
function showHistoryOnly() {
  const state = JSON.parse(localStorage.getItem('lambda_last_state') || 'null');
  if (state) {
    const date = new Date(state.timestamp).toLocaleString();
    printAnimated(`lambda > Last progress: ${state.description}`, 50, () => {
      printAnimated(`lambda > Saved on: ${date}`, 40, () => {
        printAnimated(`lambda > Recommended next: "${state.recommended}"`, 40, () => {
          createInputLine();
        });
      });
    });
  } else {
    printAnimated("lambda > No recorded history found.", 50, () => {
      createInputLine();
    });
  }
}
 </script>
 <script>
  window.addEventListener('DOMContentLoaded', () => {
    let wasHidden = false;

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        wasHidden = true; // user left or minimized
      } else if (document.visibilityState === 'visible' && wasHidden) {
        // user returned — now safe to run flashlight
        blinkFlashlight();
        wasHidden = false;
      }
    });
  });
</script>
<script>
  window.addEventListener('DOMContentLoaded', () => {
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        // Vibrate in background when tab is hidden
        if (navigator.vibrate) {
          navigator.vibrate([300, 200, 300, 200, 300]); // Vibration pattern
        }
      }
    });
  });
</script>
<script>
 
  // Detect when tab is hidden and show a notification
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'hidden' && Notification.permission === 'granted') {
      showScaryNotification();
    }
  });

  // Function to show the notification
  function showScaryNotification() {
    new Notification("⚠️ Lambda is watching you...", {
      body: "You left the terminal. It doesn't like that.",
      icon: "https://i.imgur.com/4M7IWwP.png", // Optional scary icon
      silent: false // Set to true if you don't want sound
    });
  }
  
  function activateLeaveWarning() {
  window.addEventListener('beforeunload', horrorLeaveTrap);
}

function horrorLeaveTrap(e) {
  // Show browser leave confirmation popup
  e.preventDefault();
  e.returnValue = '';

  // Fake horror message inside your terminal
  const terminal = document.getElementById("terminal");
  if (terminal) {
    terminal.innerHTML += `<br><span style="color:red;">lambda > You can’t leave now...</span><br>`;
    terminal.innerHTML += `<span style="color:red;">lambda > You opened the gate. Now finish what you started...</span><br>`;
  }

  // Optional: quick phone vibration (if supported)
  if (navigator.vibrate) {
    navigator.vibrate([200, 100, 200]);
  }

  // Optional: scary sound
  new Audio("scare.mp3").play(); // Only works if scare.mp3 exists & autoplay allowed
}


</script>
<script>
    
 // --- DARKNESS TASK SYSTEM ---

let lambdaSensor = null;
let lambdaDetecting = false;

// Entry point for darkness task
function startDarknessTask() {
  printAnimated(colorize("lambda > Task: Turn off all lights. Monitoring begins...", "red"), 30, () => {
    if ('AmbientLightSensor' in window) {
      startDarknessSensor(); // Try sensor
    } else {
      fallbackManualDarkness(); // Use fallback
    }
  });
}

// Sensor-based detection
function startDarknessSensor() {
  if (lambdaDetecting) return;
  lambdaDetecting = true;

  lambdaSensor = new AmbientLightSensor();
  
  lambdaSensor.addEventListener("reading", () => {
    const lux = lambdaSensor.illuminance;
    const percent = Math.max(0, Math.min(100, Math.floor(100 - (lux / 100) * 100)));
    const bar = generateAnimatedBar(percent);
    const status = getDarkStatus(percent);

    printAnimated(colorize(`lambda > Darkness Meter: ${bar} ${percent}%\nlambda > ${status}`, "red"), 20, () => {
      if (percent >= 80) {
        lambdaSensor.stop();
        lambdaDetecting = false;
        printAnimated(colorize("lambda > Darkness verified. Proceed if you dare...", "red"), 30, () => {
          setTimeout(createInputLine, 500);
        });
      } else {
        setTimeout(() => lambdaSensor.onreading(), 2000); // Retry every 2s
      }
    });
  });

  lambdaSensor.addEventListener("error", () => {
    printAnimated(colorize("lambda > Error reading light sensor. Using fallback...", "red"), 30, fallbackManualDarkness);
  });

  lambdaSensor.start();
}

// Manual fallback for unsupported devices
function fallbackManualDarkness() {
  printAnimated(colorize("lambda > Your device cannot detect light levels.", "red"), 30, () => {
    printAnimated(colorize("lambda > Manually switch off all lights.", "red"), 30, () => {
      printAnimated(colorize("lambda > When the room is dark, type 'confirm-dark' to continue.", "red"), 30, createInputLine);
    });
  });
}

// Visual progress bar generator
function generateAnimatedBar(percent) {
  const total = 30;
  const filled = Math.round((percent / 100) * total);
  let bar = "";
  for (let i = 0; i < total; i++) {
    bar += i < filled ? "█" : "░";
  }
  return `[${bar}]`;
}

// Text status based on percent
function getDarkStatus(percent) {
  if (percent >= 80) return "✔ Good. It's dark enough.";
  if (percent >= 40) return "✖ Still too bright.";
  return "✖ You're in full light. Shut all lights completely.";
}
</script>
<script>
// === DARKNESS DETECTION SYSTEM with LIVE BAR + CALLBACK SUPPORT ===
// Uses rear camera to monitor ambient light for 10 seconds.
// Shows a live-updating terminal-style brightness bar.
// Accepts custom success/failure messages and a next-step function.

let darknessStream;
let darknessInterval;
let canvas, ctx;
let darknessStartTime = 0;
let darknessSamples = [];
let darknessBarLine = null;

// Main Task
function cameraDarknessTask(successMessage, failureMessage, onSuccess = null) {
  printAnimated(colorize("lambda > Task: Turn off all lights. The entity feeds on darkness...", "red"), 30, async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "environment" },
        audio: false
      });
      darknessStream = stream;

      const video = document.createElement("video");
      video.style.display = "none";
      video.srcObject = stream;
      await video.play();

      canvas = document.createElement("canvas");
      ctx = canvas.getContext("2d");
      document.body.appendChild(video);

      printAnimated(colorize("lambda > Monitoring ambient light... (10 seconds)", "red"), 30, () => {
        darknessStartTime = Date.now();
        darknessSamples = [];

        // Create placeholder for live bar
        darknessBarLine = document.createElement("div");
        darknessBarLine.style.color = "red";
        darknessBarLine.style.fontFamily = "monospace";
        darknessBarLine.style.whiteSpace = "pre";
        document.getElementById("terminal").appendChild(darknessBarLine); // Terminal must have id="terminal"

        darknessInterval = setInterval(() => {
          updateDarknessReading(video);
        }, 1000);

        setTimeout(() => {
          finishDarknessCheck(successMessage, failureMessage, onSuccess);
        }, 10000); // Stop after 10 seconds
      });
    } catch (err) {
      printAnimated(colorize("lambda > ERROR: Unable to access camera.", "red"), 30, createInputLine);
    }
  });
}

// Update brightness reading and show live bar
function updateDarknessReading(video) {
  if (video.videoWidth > 0 && video.videoHeight > 0) {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    const frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const pixels = frame.data;

    let totalBrightness = 0;
    for (let i = 0; i < pixels.length; i += 4) {
      const r = pixels[i];
      const g = pixels[i + 1];
      const b = pixels[i + 2];
      const brightness = (r + g + b) / 3;
      totalBrightness += brightness;
    }

    const avgBrightness = totalBrightness / (pixels.length / 4);
    const darknessPercent = Math.max(0, Math.min(100, Math.floor(100 - (avgBrightness / 255) * 100)));
    darknessSamples.push(darknessPercent);

    // Update live bar
    const bar = generateAnimatedBar(darknessPercent);
    const status = darknessPercent >= 80 ? "✔ Dark enough" : darknessPercent >= 40 ? "✖ Still too bright" : "✖ Full brightness";

    darknessBarLine.textContent = `lambda > Darkness Meter: ${bar} ${darknessPercent}%\nlambda > ${status}`;

    // ✅ Auto scroll terminal
    const terminal = document.getElementById("terminal");
    terminal.scrollTop = terminal.scrollHeight;
  }
}

// Final result
function finishDarknessCheck(successMessage, failureMessage, onSuccess) {
  clearInterval(darknessInterval);
  stopDarknessCamera();

  const avg = Math.floor(darknessSamples.reduce((a, b) => a + b, 0) / darknessSamples.length);
  const finalBar = generateAnimatedBar(avg);

  darknessBarLine.textContent = `lambda > Final Reading: ${finalBar} ${avg}%`;

  setTimeout(() => {
    if (avg >= 80) {
      printAnimated(colorize(successMessage, "red"), 30, () => {
        if (onSuccess) onSuccess(); // ✅ Run next step function
        else createInputLine();
      });
    } else {
      printAnimated(colorize(failureMessage, "red"), 30, createInputLine);
    }
  }, 500);
}

// Stop camera
function stopDarknessCamera() {
  if (darknessStream) {
    darknessStream.getTracks().forEach(track => track.stop());
    darknessStream = null;
  }
}

// Terminal-style animated bar
function generateAnimatedBar(percent) {
  const total = 30;
  const filled = Math.round((percent / 100) * total);
  let bar = "";
  for (let i = 0; i < total; i++) {
    bar += i < filled ? "█" : "░";
  }
  return `\n[${bar}]`;
 
}
</script>

<script>
    
    // === SOUND SYSTEM FOR LAMBDA TERMINAL ===

// Global sound element for looping
let loopingAudio = null;

// ✅ 1. Play a sound only ONCE
function playSoundOnce(src = "sfx/trigger.mp3") {
  const audio = new Audio(src);
  audio.play();
  log("lambda > Sound played once.");
}

// ✅ 2. Start or Stop looping sound
function loopSound(state = "on", src = "sfx/loop.mp3") {
  if (state === "on") {
    if (loopingAudio) return; // already playing
    loopingAudio = new Audio(src);
    loopingAudio.loop = true;
    loopingAudio.play();
    log("lambda > Looping sound started.");
  } else if (state === "off") {
    if (loopingAudio) {
      loopingAudio.pause();
      loopingAudio.currentTime = 0;
      loopingAudio = null;
      log("lambda > Looping sound stopped.");
    }
  }
}
</script>

<script>
    
  <!-- task input handling system 👇-->
/**
 * Repeatedly prompts for input until the user provides a valid response,
 * fails too many times (punishment), or types 'quit' or 'exit' (to stop).
 */
/**
 * Repeatedly prompts for input until the user provides a valid response,
 * fails too many times (punishment), or types 'quit' or 'exit' (to stop).
 */
function createTaskInput(expectedInputs = ["yes"], maxAttempts = 3, onSuccess, onPunishment) {
  let attemptCount = 0;

  function addNewTaskInput() {
    const inputDiv = document.createElement("div");
    inputDiv.className = "lambda-task-input";
    inputDiv.innerHTML = `<span class="task-prompt" style="color: red;">task > </span><input type="text" class="taskInput" autofocus />`;
    document.getElementById("terminal").appendChild(inputDiv);

    const taskInput = inputDiv.querySelector(".taskInput");
    taskInput.focus();

    // ✅ First scroll shortly after focus
    setTimeout(() => {
      taskInput.scrollIntoView({ behavior: "smooth", block: "center" });
    }, 100);

    // ✅ Second scroll after the keyboard likely opens (mobile workaround)
    setTimeout(() => {
      taskInput.scrollIntoView({ behavior: "smooth", block: "center" });
      window.scrollBy(0, -100); // optional upward adjustment
    }, 600); // give enough time for keyboard to fully appear

    taskInput.addEventListener("keydown", function handler(e) {
      if (e.key === "Enter") {
        const value = taskInput.value.trim().toLowerCase();
        taskInput.disabled = true;
        taskInput.removeEventListener("keydown", handler);

        if (value === "quit" || value === "exit") {
          printAnimated(colorize("Λ > You have exited this task. We'll wait for your return...", "red"), 30);
          setTimeout(createInputLine, 40);
          return;
        }

        if (expectedInputs.includes(value)) {
          onSuccess(value);
        } else {
          attemptCount++;
          printAnimated(colorize(`λ > Invalid or denial response [${attemptCount}/${maxAttempts}]`, "red"), 20, () => {
            if (attemptCount >= maxAttempts) {
              onPunishment(() => {
                attemptCount = 0;
                addNewTaskInput();
              });
            } else {
              addNewTaskInput();
            }
          });
        }
      }
    });
  }

  addNewTaskInput();
}
</script>

<script>
 // === HIGH ACCURACY SOUND DETECTION with REAL-TIME LINE GRAPH ===
// Uses microphone to show a 10s real-time waveform (line graph) and detects silence accurately.

let waveformCanvas, waveformCtx;
let waveformStream, waveformAudioCtx, waveformAnalyser, waveformData;
let waveformInterval;
let waveformSamples = [];

function micLineGraphTask(successMessage, failureMessage, onSuccess = null) {
  printAnimated(colorize("lambda > Task: Remain silent. Detecting even the tiniest sound...", "red"), 30, async () => {
    try {
      waveformStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      waveformAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const source = waveformAudioCtx.createMediaStreamSource(waveformStream);
      waveformAnalyser = waveformAudioCtx.createAnalyser();
      waveformAnalyser.fftSize = 1024;

      waveformData = new Uint8Array(waveformAnalyser.fftSize);
      source.connect(waveformAnalyser);

      // Canvas setup
      waveformCanvas = document.createElement("canvas");
      waveformCanvas.width = 300;
      waveformCanvas.height = 100;
      waveformCanvas.style.background = "black";
      waveformCanvas.style.border = "1px solid red";
      waveformCanvas.style.display = "block";
      waveformCanvas.style.marginTop = "5px";

      waveformCtx = waveformCanvas.getContext("2d");
      const terminal = document.getElementById("terminal");
      terminal.appendChild(waveformCanvas);

      waveformSamples = [];

      printAnimated(colorize("lambda > Monitoring sound for 10 seconds...", "red"), 30, () => {
        waveformInterval = setInterval(updateWaveformGraph, 100);

        setTimeout(() => {
          finishWaveformCheck(successMessage, failureMessage, onSuccess);
        }, 10000);
      });
    } catch (err) {
      printAnimated(colorize("lambda > ERROR: Microphone access denied.", "red"), 30, createInputLine);
    }
  });
}

// Draws real-time line graph and saves volume samples
function updateWaveformGraph() {
  waveformAnalyser.getByteTimeDomainData(waveformData);

  // Calculate average deviation from center (128)
  let total = 0;
  for (let i = 0; i < waveformData.length; i++) {
    total += Math.abs(waveformData[i] - 128);
  }
  const average = total / waveformData.length;
  waveformSamples.push(average);

  // Draw waveform
  waveformCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
  waveformCtx.beginPath();
  waveformCtx.strokeStyle = "red";

  for (let i = 0; i < waveformData.length; i++) {
    const x = (i / waveformData.length) * waveformCanvas.width;
    const y = ((waveformData[i] - 128) / 128) * 50 + 50;
    i === 0 ? waveformCtx.moveTo(x, y) : waveformCtx.lineTo(x, y);
  }
  waveformCtx.stroke();

  // Auto scroll terminal
  document.getElementById("terminal").scrollTop = terminal.scrollHeight;
}

// Stop mic and give verdict
function finishWaveformCheck(successMessage, failureMessage, onSuccess) {
  clearInterval(waveformInterval);
  stopWaveformMic();

  const avg = waveformSamples.reduce((a, b) => a + b, 0) / waveformSamples.length;

  setTimeout(() => {
    if (avg < 1) {
      printAnimated(colorize(successMessage || "lambda > ✅ Well done. Your room is perfectly quiet.", "red"), 30, () => {
        if (onSuccess) onSuccess();
        else createInputLine();
      });
    } else {
      printAnimated(colorize(failureMessage || "lambda > ❌ Too noisy. The silence is broken.", "red"), 30, createInputLine);
    }
  }, 500);
}

// Clean up mic
function stopWaveformMic() {
  if (waveformStream) {
    waveformStream.getTracks().forEach(track => track.stop());
    waveformStream = null;
  }
  if (waveformAudioCtx) {
    waveformAudioCtx.close();
    waveformAudioCtx = null;
  }
}
</script>
<script>
// === LAMBDA VOICE RECORDER with CALLBACK SUPPORT ===

let recorderCanvas, recorderCtx;
let recorderStream, recorderAudioCtx, recorderAnalyser, recorderData;
let recorderInterval, recorderTimerInterval;
let mediaRecorder;
let recordedChunks = [];
let elapsedSeconds = 0;
let timerLine;

/**
 * Starts voice recording, shows live waveform and timer,
 * then runs an optional function when finished.
 * @param {number} durationSec - Duration to record in seconds
 * @param {Function} onComplete - Function to run after recording finishes
 */
function voiceRecorderTask(durationSec = 10, onComplete = null) {
  printAnimated(colorize("lambda > Task: Recording your voice now...", "red"), 30, async () => {
    try {
      recorderStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      recorderAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const source = recorderAudioCtx.createMediaStreamSource(recorderStream);
      recorderAnalyser = recorderAudioCtx.createAnalyser();
      recorderAnalyser.fftSize = 1024;
      recorderData = new Uint8Array(recorderAnalyser.fftSize);
      source.connect(recorderAnalyser);

      // MediaRecorder
      recordedChunks = [];
      mediaRecorder = new MediaRecorder(recorderStream);
      mediaRecorder.ondataavailable = e => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };
      mediaRecorder.start();

      // Timer line
      timerLine = document.createElement("div");
      timerLine.style.color = "red";
      timerLine.style.fontFamily = "monospace";
      timerLine.style.whiteSpace = "pre";

      // Canvas setup
      recorderCanvas = document.createElement("canvas");
      const terminal = document.getElementById("terminal");
      const terminalWidth = terminal ? terminal.offsetWidth : window.innerWidth;
      recorderCanvas.width = terminalWidth - 20;
      recorderCanvas.height = 100;
      recorderCanvas.style.background = "black";
      recorderCanvas.style.border = "1px solid red";
      recorderCanvas.style.display = "block";
      recorderCanvas.style.marginTop = "5px";

      recorderCtx = recorderCanvas.getContext("2d");
      terminal.appendChild(timerLine);
      terminal.appendChild(recorderCanvas);

      printAnimated(colorize(`lambda > Recording for ${durationSec} seconds...`, "red"), 30, () => {
        elapsedSeconds = 0;
        recorderInterval = setInterval(updateRecorderGraph, 100);
        recorderTimerInterval = setInterval(() => updateRecordingTimer(durationSec), 1000);

        setTimeout(() => {
          finishRecordingTask(onComplete);
        }, durationSec * 1000);
      });
    } catch (err) {
      printAnimated(colorize("lambda > ERROR: Microphone access denied.", "red"), 30, createInputLine);
    }
  });
}

function updateRecorderGraph() {
  recorderAnalyser.getByteTimeDomainData(recorderData);

  recorderCtx.clearRect(0, 0, recorderCanvas.width, recorderCanvas.height);
  recorderCtx.beginPath();
  recorderCtx.strokeStyle = "red";

  for (let i = 0; i < recorderData.length; i++) {
    const x = (i / recorderData.length) * recorderCanvas.width;
    const y = ((recorderData[i] - 128) / 128) * 50 + 50;
    i === 0 ? recorderCtx.moveTo(x, y) : recorderCtx.lineTo(x, y);
  }

  recorderCtx.stroke();
  document.getElementById("terminal").scrollTop = terminal.scrollHeight;
}

function updateRecordingTimer(totalSeconds) {
  elapsedSeconds++;
  const formatted = formatTime(elapsedSeconds);
  const remaining = formatTime(totalSeconds - elapsedSeconds);
  timerLine.textContent = `lambda > 🔴 Recording... ${formatted} / ${remaining}`;
}

function formatTime(seconds) {
  const min = String(Math.floor(seconds / 60)).padStart(2, "0");
  const sec = String(seconds % 60).padStart(2, "0");
  return `${min}:${sec}`;
}

function finishRecordingTask(onComplete = null) {
  clearInterval(recorderInterval);
  clearInterval(recorderTimerInterval);
  mediaRecorder.stop();
  stopRecorderMic();

  printAnimated(colorize("lambda > Recording complete. Preparing download...", "red"), 30, () => {
    const blob = new Blob(recordedChunks, { type: "audio/webm" });
    const url = URL.createObjectURL(blob);
    const filename = "Lambda_recording.webm";

    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    link.textContent = `lambda > ⬇ Download your voice: ${filename}`;
    link.style.color = "red";
    link.style.display = "block";
    link.style.marginTop = "8px";
    link.style.fontFamily = "monospace";

    document.getElementById("terminal").appendChild(link);

    if (onComplete) {
      onComplete(); // ✅ Run the callback
    } else {
      createInputLine();
    }
  });
}

function stopRecorderMic() {
  if (recorderStream) {
    recorderStream.getTracks().forEach(track => track.stop());
    recorderStream = null;
  }
  if (recorderAudioCtx) {
    recorderAudioCtx.close();
    recorderAudioCtx = null;
  }
}
</script>

<script>
// === Trigger + Voice Recognition System ===

function startLambdaTriggerMode(targetSentence, onSuccess, onFailure, duration = 15) {
  const terminal = document.getElementById("terminal");

  // Instructional text
  const info = document.createElement("div");
  info.textContent = "lambda > To initialize voice recognition, please click the red button below.";
  info.style = "color:red; font-family:monospace; margin-bottom:5px;";
  terminal.appendChild(info);

  // Styled link as warning button
  const link = document.createElement("a");
  link.textContent = "▶ Start Voice Recognition Task";
  link.style = `
    display: inline-block;
    background-color: red;
    color: black;
    font-family: monospace;
    font-weight: bold;
    padding: 6px 12px;
    border: 2px solid darkred;
    border-radius: 4px;
    cursor: pointer;
    text-decoration: none;
  `;
  link.onclick = () => {
    printAnimated(colorize("lambda > 🧠 Trigger activated. Initiating task...", "red"), 30);
    voiceRecognitionSimulatedGraphTask(targetSentence, onSuccess, onFailure, duration);
  };

  terminal.appendChild(link);
  terminal.scrollTop = terminal.scrollHeight;
}

// Task that shows a simulated waveform + listens + matches voice
function voiceRecognitionSimulatedGraphTask(targetSentence, onSuccess, onFailure, duration = 10) {
  printAnimated(colorize("lambda > Task: Speak this phrase exactly:", "red"), 30, () => {
    printAnimated(colorize(`"${targetSentence}"`, "red"), 15, async () => {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        printAnimated(colorize("lambda > ERROR: Speech recognition not supported.", "red"), 30, createInputLine);
        return;
      }

      const terminal = document.getElementById("terminal");
      const timerLine = document.createElement("div");
      timerLine.style = "color:red; font-family:monospace; white-space:pre;";
      terminal.appendChild(timerLine);

      // === Simulated Graph Canvas ===
      const canvas = document.createElement("canvas");
      canvas.width = terminal.offsetWidth - 20;
      canvas.height = 100;
      canvas.style = "background:black; border:1px solid red; display:block; margin-top:5px;";
      const ctx = canvas.getContext("2d");
      terminal.appendChild(canvas);

      // === Start drawing a simulated waveform ===
      let offset = 0;
      const drawFakeWave = setInterval(() => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath();
        ctx.strokeStyle = "red";
        for (let x = 0; x < canvas.width; x++) {
          const y = 50 + 30 * Math.sin((x + offset) * 0.05);
          x === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
        offset += 3;
        terminal.scrollTop = terminal.scrollHeight;
      }, 100);

      // === Speech Recognition Setup ===
      const recognition = new SpeechRecognition();
      recognition.lang = "en-US";
      recognition.continuous = true;
      recognition.interimResults = true;

      let finalTranscript = "";

      recognition.onresult = (event) => {
        let temp = "";
        for (let i = event.resultIndex; i < event.results.length; ++i) {
          temp += event.results[i][0].transcript + " ";
        }
        finalTranscript = temp.trim();
      };

      recognition.onerror = (e) => {
        printAnimated(colorize(`lambda > ERROR: ${e.error}`, "red"), 30, createInputLine);
        clearInterval(drawFakeWave);
        if (onFailure) onFailure();
      };

      recognition.start();

      // === Countdown Timer ===
      let elapsed = 0;
      const timer = setInterval(() => {
        elapsed++;
        const pad = s => String(s).padStart(2, '0');
        timerLine.textContent = `lambda > 🎙️ Listening... 00:${pad(elapsed)} / 00:${pad(duration)}`;
        if (elapsed >= duration) {
          clearInterval(timer);
          recognition.stop();
        }
      }, 1000);

      // === Final Check ===
      setTimeout(() => {
        clearInterval(drawFakeWave);
        clearInterval(timer);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const cleaned = finalTranscript.trim().toLowerCase();
        const reference = targetSentence.trim().toLowerCase();
        const match = calculateSimilarity(cleaned, reference);
        const matchPercent = Math.floor(match * 100);

        printAnimated(colorize(`lambda > You said: "${cleaned}"`, "red"), 30, () => {
          if (match >= 0.6) {
            printAnimated(colorize(`lambda > ✅ Match ${matchPercent}% — Accepted.`, "red"), 30, onSuccess);
          } else {
            printAnimated(colorize(`lambda > ❌ Match ${matchPercent}% — Incorrect phrase.`, "red"), 30, onFailure);
          }
        });
      }, duration * 1000);
    });
  });
}

// Very simple similarity comparison using word overlap
function calculateSimilarity(a, b) {
  const wordsA = a.split(/\s+/);
  const wordsB = b.split(/\s+/);
  let match = 0;
  wordsA.forEach(word => {
    if (wordsB.includes(word)) match++;
  });
  return match / Math.max(wordsA.length, wordsB.length);
}

</script>
<script>
  // ===============================
// ✅ 1. Count Task Entry Function
// ===============================
// Tracks how many times a specific task is triggered.
// When the threshold is reached, triggers a punishment or special function.
function countTaskEntry(taskName, threshold, onThresholdReached) {
  const key = `lambda_task_count_${taskName}`;
  let count = parseInt(localStorage.getItem(key) || "0"); // Get existing count
  count++; // Increment count
  localStorage.setItem(key, count); // Save updated count

  // Trigger your punishment/action if the count reaches the threshold
  if (count >= threshold) {
    onThresholdReached();
  }
}

// ===============================
// ✅ 2. Get Task Count Function
// ===============================
// Useful to check the current number of times a task has been triggered.

function getTaskCount(taskName) {
  return parseInt(localStorage.getItem(`lambda_task_count_${taskName}`) || "0");
}

// ===============================
// ✅ 3. Reset Specific Task Counter
// ===============================
// Call this if you want to reset the counter of a single task (like "voice-task")

function resetTaskCount(taskName) {
  localStorage.removeItem(`lambda_task_count_${taskName}`);
}

// ===============================
// ✅ 4. Global Reset of All Counters
// ===============================
// This removes all Lambda task counters from localStorage.
// Use it to fully reset progress or start fresh.
function resetAllTaskCounters() {
  Object.keys(localStorage).forEach(key => {
    if (key.startsWith("lambda_task_count_")) {
      localStorage.removeItem(key);
    }
  });
}
</script>
<script>
  function startBombLock(duration = 10) {
  const overlay = document.getElementById("bombLockOverlay");

  // Fullscreen countdown UI
  overlay.style = `
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: black;
    color: red;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-family: monospace;
    font-size: 6rem;
    z-index: 999999;
    pointer-events: none;  /* Disable ALL touch and mouse */
    user-select: none;
  `;

  overlay.innerHTML = `
    <div id="bomb-count" style="font-size: 8rem; line-height: 1;">${duration}</div>
    <div style="font-size: 2rem; margin-top: 1rem;">LOCKED</div>
  `;

  document.body.appendChild(overlay);
  overlay.style.display = "flex";

  // Request fullscreen
  const elem = overlay;
  if (elem.requestFullscreen) {
    elem.requestFullscreen();
  } else if (elem.webkitRequestFullscreen) {
    elem.webkitRequestFullscreen();
  }

  // Countdown logic with classic tick style
  let timeLeft = duration;
  const counter = document.getElementById("bomb-count");
  const timer = setInterval(() => {
    timeLeft--;
    counter.textContent = timeLeft;
    counter.style.transform = "scale(1.3)";
    counter.style.transition = "transform 0.1s ease";
    setTimeout(() => {
      counter.style.transform = "scale(1)";
    }, 100);

    if (timeLeft <= 0) {
      clearInterval(timer);
      exitFullscreen();
      overlay.style.display = "none";
    }
  }, 1000);
}

// Exit fullscreen function
function exitFullscreen() {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen();
  }
}
</script>
<!--<script>
    // ===============================
// ✅ Force Terminal into Fullscreen Mode
// ===============================
// This function tries to make the #terminal div go fullscreen.
// It checks browser support and handles both standard and WebKit methods.
function requestTerminalFullscreen() {
  const terminal = document.getElementById("terminal");

  // Only activate if not already in fullscreen
  if (!document.fullscreenElement) {
    if (terminal.requestFullscreen) {
      terminal.requestFullscreen().catch(err => {
        console.warn("Fullscreen request failed:", err.message);
      });
    } else if (terminal.webkitRequestFullscreen) {
      terminal.webkitRequestFullscreen();
    }
  }
}

// ===============================
// ✅ Monitor Fullscreen Status Every 10 Seconds
// ===============================
// This function runs in the background and checks every 10 seconds
// whether fullscreen is active. If not, it tries to re-enter fullscreen.
// Pass `force = true` to enable automatic recovery.
function monitorFullscreen(force = false) {
  setInterval(() => {
    if (!document.fullscreenElement && force) {
      requestTerminalFullscreen(); // Re-enter fullscreen if exited
    }
  }, 10000); // 🔁 Check every 10 seconds
}

// ===============================
// ✅ Initialize Fullscreen on Page Load
// ===============================
// Browsers require fullscreen to be triggered by user interaction (click).
// So we listen for the user's first click after page load and then:
// 1. Activate fullscreen
// 2. Start monitoring every 10s to ensure fullscreen stays active

window.addEventListener("load", () => {
  document.addEventListener("click", function userStart() {
    requestTerminalFullscreen();  // 🖥️ Enter fullscreen on first user click
    monitorFullscreen(true);      // 🕵️ Keep checking fullscreen every 10s
    document.removeEventListener("click", userStart); // 🔁 Only once
  });
});
</script> -->
<script>
    function ritualDeathNoteWithCode(lambdaLink = "https://your-lambda-game-link.com", onSuccess, onFailure) {
  const terminal = document.getElementById("terminal") || document.body;

  // === 1. Generate a Random Ritual Code ===
  const shareCode = "LMB-" + Math.floor(100000 + Math.random() * 900000);

  // === 2. Start Ritual Dialogue ===
  printAnimated(colorize("lambda > If you want to kill...", "red"), 30, () => {
    printAnimated(colorize("lambda > You must choose who dies.", "red"), 30, () => {
      printAnimated(colorize("lambda > Share the death note. Only then will the path open.", "red"), 30, () => {

        // === 3. Centered Red Button ===
        setTimeout(() => {
          const buttonLine = document.createElement("div");
          buttonLine.style = "text-align:center; margin-top:20px;";
          
          const button = document.createElement("button");
          button.textContent = "SHARE DEATH NOTE";
          button.style = `
            background: black;
            color: red;
            border: 2px solid red;
            padding: 10px 20px;
            font-family: monospace;
            font-size: 18px;
            cursor: pointer;
            border-radius: 8px;
          `;

          // === WhatsApp Message with Ritual Code ===
          const message = encodeURIComponent(
            `🩸 The Death Note has chosen you.\nAccept your fate:\n${lambdaLink}\n\n☠️ Ritual Code: ${shareCode}`
          );
          const shareUrl = `https://wa.me/?text=${message}`;

          button.onclick = () => {
            printAnimated(colorize("lambda > The message has been written. It must now be delivered.", "red"), 30, () => {
              window.open(shareUrl, "_blank");

              setTimeout(() => {
                printAnimated(colorize("lambda > Enter the Ritual Code to prove the message was delivered.", "red"), 30, () => {
                  // === Create code input prompt (inline check) ===
                  const inputWrap = document.createElement("div");
                  inputWrap.style = "margin-top:10px; font-family:monospace; color:red;";
                  const label = document.createElement("div");
                  label.textContent = "lambda > Enter Ritual Code:";
                  inputWrap.appendChild(label);

                  const input = document.createElement("input");
                  input.type = "text";
                  input.style = `
                    background:black;
                    color:red;
                    border:1px solid red;
                    font-family:monospace;
                    padding:5px;
                    margin-top:5px;
                    width:200px;
                  `;
                  inputWrap.appendChild(input);
                  terminal.appendChild(inputWrap);
                  terminal.scrollTop = terminal.scrollHeight;
                  input.focus();

                  input.addEventListener("keydown", (e) => {
                    if (e.key === "Enter") {
                      const entered = input.value.trim().toUpperCase();
                      if (entered === shareCode.toUpperCase()) {
                        printAnimated(colorize("lambda > ✅ Code accepted. The ritual is complete.", "red"), 30, () => {
                          if (typeof onSuccess === "function") onSuccess();
                        });
                      } else {
                        printAnimated(colorize("lambda > ❌ Invalid code. You lied to the ritual.", "red"), 30, () => {
                          if (typeof onFailure === "function") onFailure();
                        });
                      }
                    }
                  });
                });
              }, 5000);
            });
          };

          buttonLine.appendChild(button);
          terminal.appendChild(buttonLine);
          terminal.scrollTop = terminal.scrollHeight;
        }, 3000);
      });
    });
  });
}
</script>
<script>
    // === LAMBDA DEATH NOTE RITUAL (TWO-LINK SYSTEM) ===
// This function handles the entire ritual logic: share links, hide code, wait for recipient, verify code

function ritualDeathNoteWithLinkCode(lambdaGameLink, ritualCodePageLink, onSuccess, onFailure) {
  const terminal = document.getElementById("terminal") || document.body;

  // === 1. Generate a Random Ritual Code ===
  const ritualCode = "LMB-" + Math.floor(100000 + Math.random() * 900000);

  // === 2. Start the ritual dialogues ===
  printAnimated(colorize("lambda > If you want to kill...", "red"), 30, () => {
    printAnimated(colorize("lambda > You must send the curse to a soul.", "red"), 30, () => {
      printAnimated(colorize("lambda > Only when the message reaches them, the code will be revealed.", "red"), 30, () => {

        // === 3. Share Button Section ===
        setTimeout(() => {
          const buttonLine = document.createElement("div");
          buttonLine.style = "text-align:center; margin-top:20px;";

          const shareBtn = document.createElement("button");
          shareBtn.textContent = "SHARE DEATH NOTE";
          shareBtn.style = `
            background: black;
            color: red;
            border: 2px solid red;
            padding: 10px 20px;
            font-family: monospace;
            font-size: 18px;
            cursor: pointer;
            border-radius: 8px;
          `;

          shareBtn.onclick = () => {
            // === WhatsApp message with 2 separate links (NO CODE!) ===
            const message = encodeURIComponent(
              `☠️ A ritual has begun.\n\nStep into the void:\n${lambdaGameLink}\n\nRetrieve your curse seal:\n${ritualCodePageLink}?code=${ritualCode}`
            );
            const waLink = `https://wa.me/?text=${message}`;
            window.open(waLink, "_blank");

            printAnimated(colorize("lambda > The message is sent. Now confirm if they received it...", "red"), 30, () => {

              // === 4. Confirm Button to continue ===
              setTimeout(() => {
                const confirmBtn = document.createElement("button");
                confirmBtn.textContent = "I HAVE SHARED";
                confirmBtn.style = `
                  background: red;
                  color: black;
                  border: 2px solid black;
                  padding: 10px 20px;
                  font-family: monospace;
                  font-size: 18px;
                  cursor: pointer;
                  border-radius: 8px;
                  margin-top: 20px;
                `;

                confirmBtn.onclick = () => {
                  printAnimated(colorize("lambda > Ask the receiver to tell you the ritual seal...", "red"), 30, () => {
                    // === 5. Input code box ===
                    const inputWrap = document.createElement("div");
                    inputWrap.style = "margin-top:10px; font-family:monospace; color:red;";

                    const label = document.createElement("div");
                    label.textContent = "lambda > Enter Ritual Code:";
                    inputWrap.appendChild(label);

                    const input = document.createElement("input");
                    input.type = "text";
                    input.style = `
                      background:black;
                      color:red;
                      border:1px solid red;
                      font-family:monospace;
                      padding:5px;
                      margin-top:5px;
                      width:200px;
                    `;
                    inputWrap.appendChild(input);
                    terminal.appendChild(inputWrap);
                    terminal.scrollTop = terminal.scrollHeight;
                    input.focus();

                    input.addEventListener("keydown", (e) => {
                      if (e.key === "Enter") {
                        const entered = input.value.trim().toUpperCase();
                        if (entered === ritualCode.toUpperCase()) {
                          printAnimated(colorize("lambda > ✅ Code accepted. The ritual is complete.", "red"), 30, () => {
                            if (typeof onSuccess === "function") onSuccess();
                          });
                        } else {
                          printAnimated(colorize("lambda > ❌ Wrong code. The spirits reject your offering.", "red"), 30, () => {
                            if (typeof onFailure === "function") onFailure();
                          });
                        }
                      }
                    });
                  });
                };

                terminal.appendChild(confirmBtn);
                terminal.scrollTop = terminal.scrollHeight;
              }, 3000);
            });
          };

          buttonLine.appendChild(shareBtn);
          terminal.appendChild(buttonLine);
          terminal.scrollTop = terminal.scrollHeight;
        }, 2000);

      });
    });
  });
}

</script>
<script>
    /**
 * Starts a ritual where the user must watch a YouTube video and enter a hidden clue.
 * Matches the red horror terminal aesthetic exactly like the Death Note version.
 *
 * @param {string} youtubeLink - The URL of the YouTube video containing the hidden clue.
 * @param {string} correctClue - The word or clue hidden inside the video.
 * @param {function} onSuccess - Function to call if the user enters the correct clue.
 * @param {function} onFailure - Function to call if the user fails to enter the correct clue.
 */
 
function ritualVideoClueChallenge(youtubeLink = "https://www.youtube.com/watch?v=YOUR_VIDEO_ID", correctClue = "OBEY", onSuccess, onFailure) {
  // Get the terminal element or fallback to the body
  const terminal = document.getElementById("terminal") || document.body;

  // === STEP 1: Begin the ritual dialogue, printed line by line ===
  printAnimated(colorize("lambda > A vision has been revealed...", "red"), 30, () => {
    printAnimated(colorize("lambda > Watch the message carefully. A secret hides in plain sight.", "red"), 30, () => {
      printAnimated(colorize("lambda > Only the worthy shall see the clue.", "red"), 30, () => {

        // === STEP 2: Show a centered red ritual button ===
        setTimeout(() => {
          const buttonLine = document.createElement("div");
          buttonLine.style = "text-align:center; margin-top:20px;";

          // Create the button
          const button = document.createElement("button");
          button.textContent = "WATCH THE CLUE";
          button.style = `
            background: black;
            color: red;
            border: 2px solid red;
            padding: 10px 20px;
            font-family: monospace;
            font-size: 18px;
            cursor: pointer;
            border-radius: 8px;
          `;

          // === STEP 3: On button click, open YouTube video and prompt for the clue ===
          button.onclick = () => {
            // Tell the player to pay attention
            printAnimated(colorize("lambda > The vision plays now. Observe everything.", "red"), 30, () => {
              // Open the video in a new tab
              window.open(youtubeLink, "_blank");

              // Wait 5 seconds before showing the clue input
              setTimeout(() => {
                // Ask the user to enter the hidden clue they saw
                printAnimated(colorize("lambda > What did you see? Speak the hidden word.", "red"), 30, () => {
                  
                  // === STEP 4: Create an input field for the player to type the clue ===
                  const inputWrap = document.createElement("div");
                  inputWrap.style = "margin-top:10px; font-family:monospace; color:red;";
                  
                  const label = document.createElement("div");
                  label.textContent = "lambda > Enter the hidden clue:";
                  inputWrap.appendChild(label);

                  const input = document.createElement("input");
                  input.type = "text";
                  input.style = `
                    background:black;
                    color:red;
                    border:1px solid red;
                    font-family:monospace;
                    padding:5px;
                    margin-top:5px;
                    width:200px;
                  `;
                  inputWrap.appendChild(input);

                  // Append the input to the terminal
                  terminal.appendChild(inputWrap);
                  terminal.scrollTop = terminal.scrollHeight;
                  input.focus();

                  // === STEP 5: Handle user input on Enter key ===
                  input.addEventListener("keydown", (e) => {
                    if (e.key === "Enter") {
                      const entered = input.value.trim().toUpperCase(); // Normalize input

                      // === STEP 6: Check if the entered clue matches the correct clue ===
                      if (entered === correctClue.toUpperCase()) {
                        // ✅ Success - User saw the clue correctly
                        printAnimated(colorize("lambda > ✅ You have seen the truth. The ritual accepts you.", "red"), 30, () => {
                          if (typeof onSuccess === "function") onSuccess();
                        });
                      } else {
                        // ❌ Failure - Wrong or no clue detected
                        printAnimated(colorize("lambda > ❌ You failed to see. The ritual rejects you.", "red"), 30, () => {
                          if (typeof onFailure === "function") onFailure();
                        });
                      }
                    }
                  });
                });
              }, 5000); // Delay after video is opened
            });
          };

          // Add button to terminal
          buttonLine.appendChild(button);
          terminal.appendChild(buttonLine);
          terminal.scrollTop = terminal.scrollHeight;
        }, 3000); // Delay before showing the button for suspense
      });
    });
  });
}
</script>

<!-- Instagram story handling function 👇 -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
<script>
    /**
 * Performs a ritual where the user must upload a screenshot
 * of their Instagram Story containing a hidden ritual code.
 * The screenshot is verified using OCR entirely in-browser.
 *
 * @param {string} expectedCode - The ritual code the user must include in their story.
 * @param {function} onSuccess - Called when the code and Instagram reference are detected.
 * @param {function} onFailure - Called when the screenshot fails validation.
 */
function ritualInstagramScreenshotCheck(expectedCode = "LMB-666999", onSuccess, onFailure) {
  const terminal = document.getElementById("terminal") || document.body;

  // === STEP 1: Lambda Horror Dialogue Begins ===
  printAnimated(colorize("lambda > A pact requires proof.", "red"), 30, () => {
    printAnimated(colorize("lambda > You must share the mark of death in your story.", "red"), 30, () => {
      printAnimated(colorize(`lambda > Include the code: ${expectedCode}`, "red"), 30, () => {
        printAnimated(colorize("lambda > Then return here... and show us your offering.", "red"), 30, () => {

          // === STEP 2: Wait & Show File Upload Prompt ===
          setTimeout(() => {
            // Container for the file input + button
            const container = document.createElement("div");
            container.style = "margin-top: 15px; font-family: monospace; color: red;";

            const label = document.createElement("div");
            label.textContent = "lambda > Upload the screenshot of your story:";
            container.appendChild(label);

            // Hidden file input element
            const fileInput = document.createElement("input");
            fileInput.type = "file";
            fileInput.accept = "image/*";
            fileInput.style.display = "none"; // hide the ugly native input

            // Custom horror-themed file upload button
            const fileButton = document.createElement("button");
            fileButton.textContent = "CHOOSE DEATH SIGIL";
            fileButton.style = `
              background: black;
              color: red;
              border: 1px solid red;
              font-family: monospace;
              padding: 10px 20px;
              font-size: 16px;
              margin-top: 10px;
              cursor: pointer;
              border-radius: 6px;
            `;

            // Clicking the button triggers the file input
            fileButton.onclick = () => fileInput.click();

            // Add both to terminal UI
            container.appendChild(fileButton);
            container.appendChild(fileInput);
            terminal.appendChild(container);
            terminal.scrollTop = terminal.scrollHeight;

            // === STEP 3: When File Selected, Begin OCR Ritual ===
            fileInput.addEventListener("change", () => {
              const file = fileInput.files[0];
              if (!file) return;

              fileButton.textContent = file.name;

              printAnimated(colorize("lambda > The watchers are reading the sigil...", "red"), 30, () => {

                const reader = new FileReader();
                reader.onload = function () {
                  const img = new Image();
                  img.onload = function () {

                    // === STEP 4: Verify Portrait Ratio (~9:16) ===
                    const ratio = img.width / img.height;
                    const isPortrait = ratio < 0.65;
                    if (!isPortrait) {
                      printAnimated(colorize("lambda > ❌ The dimensions betray you. This is no story.", "red"), 30);
                      if (typeof onFailure === "function") onFailure();
                      return;
                    }

                    // === STEP 5: Invert Image Colors for Better OCR ===
                    const canvas = document.createElement("canvas");
                    const ctx = canvas.getContext("2d");
                    canvas.width = img.width;
                    canvas.height = img.height;

                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    for (let i = 0; i < imageData.data.length; i += 4) {
                      imageData.data[i] = 255 - imageData.data[i];       // Red
                      imageData.data[i + 1] = 255 - imageData.data[i + 1]; // Green
                      imageData.data[i + 2] = 255 - imageData.data[i + 2]; // Blue
                    }
                    ctx.putImageData(imageData, 0, 0);

                    // === STEP 6: OCR Recognition using Tesseract ===
                    Tesseract.recognize(canvas, 'eng', {
                      logger: m => console.log(m)
                    }).then(({ data: { text } }) => {
                      const extracted = text.toLowerCase();

                      // === STEP 7: Ritual Code + IG UI Clues Check ===
                      const hasCode = extracted.includes(expectedCode.toLowerCase());

                      const igClues = [
                        "share to", "highlight", "say something", "story", "18s", "viewers"
                      ];
                      const igMatchCount = igClues.filter(cue => extracted.includes(cue)).length;

                      const looksLikeIG = igMatchCount >= 2;

                      // === STEP 8: Final Judgement ===
                      if (hasCode && looksLikeIG) {
                        printAnimated(colorize("lambda > ✅ The sigil is true. The gate will open.", "red"), 30, () => {
                          if (typeof onSuccess === "function") onSuccess();
                        });
                      } else if (hasCode && !looksLikeIG) {
                        printAnimated(colorize("lambda > ⚠️ The code is true... but this is not a story.", "red"), 30, () => {
                          printAnimated(colorize("lambda > Did you think you could trick the ritual?", "red"), 30, () => {
                            if (typeof onFailure === "function") onFailure();
                          });
                        });
                      } else {
                        printAnimated(colorize("lambda > ❌ The sigil is false. The spirits turn away.", "red"), 30, () => {
                          if (typeof onFailure === "function") onFailure();
                        });
                      }

                    }).catch(() => {
                      // OCR failed
                      printAnimated(colorize("lambda > ⚠️ The veil is strong. The watchers could not read it.", "red"), 30);
                      if (typeof onFailure === "function") onFailure();
                    });
                  };

                  img.src = reader.result;
                };

                reader.readAsDataURL(file);
              });
            });
          }, 3000); // dramatic pause
        });
      });
    });
  });
}
</script>
<!-- Include this once in your HTML head -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script>
function showCreepyMapBox(containerId = "creepyMap", onLocated = () => {}) {
  const terminal = document.getElementById("terminal") || document.body;

  // === 1. Line container
  const line = document.createElement("div");
  line.style.display = "flex";
  line.style.flexDirection = "column";
  line.style.alignItems = "flex-start";
  line.style.marginTop = "10px";
  line.style.marginbottom = "10px";
  line.style.fontFamily = "monospace";
  line.style.color = "red";

  // === 2. Map Box
  const mapBox = document.createElement("div");
  mapBox.id = containerId;
  mapBox.style.width = "300px";
  mapBox.style.height = "250px";
  mapBox.style.border = "2px solid red";
  mapBox.style.marginTop = "5px";
  mapBox.style.boxShadow = "0 0 10px red";

  

  // === 3. Horror Dialogues
  const horrorLines = [
    "System breach detected...",
    "Tracking your exact location...",
    "No shadows to hide in now...",
    "You thought you were alone..."
  ];

  let i = 0;
  function animateNextLine() {
    if (i < horrorLines.length) {
      printAnimated(colorize(horrorLines[i++],"red"));
      setTimeout(animateNextLine, 1000);
    } else {
      setTimeout(loadMap, 1000);
    }
  }

  animateNextLine();
 
 line.appendChild(mapBox);
 terminal.appendChild(line);
  

  function loadMap() {
    navigator.geolocation.getCurrentPosition(
      pos => {
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;

        const map = L.map(containerId).setView([lat, lon], 16);
        L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png", {
          maxZoom: 19
        }).addTo(map);

        const marker = L.circleMarker([lat, lon], {
          radius: 8,
          color: "red",
          fillColor: "#ff0000",
          fillOpacity: 0.9
        }).addTo(map);

        marker.bindPopup("You are here... for now.").openPopup();

        // === Get Address (Reverse Geocoding)
        fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json`)
          .then(res => res.json())
          .then(data => {
            const area = data.address.suburb || data.address.neighbourhood || data.address.road || "unknown area";
            const city = data.address.city || data.address.town || data.address.village || "unknown city";
            const country = data.address.country || "unknown country";

            printAnimated(colorize(`We see you in ${area}, inside ${city}, marked on ${country}.`,"red"));
            printAnimated(colorize(`Latitude: ${lat.toFixed(6)} | Longitude: ${lon.toFixed(6)}`,"red"));
            printAnimated(colorize("No turning back now...","red"));
            onLocated(lat, lon);
          })
          .catch(() => {
            printAnimated(colorize("Location found, but we couldn't decode the city... You're still being watched.","red"));
            onLocated(lat, lon);
            setTimeout(createInputLine, 2000);
          });
      },
      err => {
        printAnimated(colorize("Location access denied. But we already know where you are.","red"));
        setTimeout(createInputLine, 1500);
      }
    );
  }
}
</script>
<script>
  const GEMINI_API_KEY = "AIzaSyBmKYvRbtzaTjp9oagN84Lf7sCl9TcIXLM"; // ← replace with your actual Gemini API key

  async function handleCMD(cmd) {
  try {
    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          contents: [
            {
              role: "user",
              parts: [{
                text: `You are VENTA: Virtual Environment for Navigational Terminal Assistance. 
You operate inside a highly advanced, futuristic CLI. 
You behave like a real terminal assistant: intelligent, responsive, ethical. 
Now process this command: ${cmd}`
              }]
            }
          ]
        })
      }
    );

    const data = await response.json();
    console.log("Gemini response:", data);

    if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
      const text = data.candidates[0].content.parts[0].text;
      printAnimated(colorize(`> ${text}`, "#ff0000"), 30, () => {
        setTimeout(createInputLine, 700);
      });
    } else if (data.error) {
      console.error("Gemini API error:", data.error);
      printAnimated(colorize(`> Gemini error: ${data.error.message}`, "#ff0000"), 30, () => {
        setTimeout(createInputLine, 700);
      });
    } else {
      printAnimated(colorize("> No response from Gemini.", "#ff0000"), 30, () => {
        setTimeout(createInputLine, 700);
      });
    }

  } catch (err) {
    console.error("Fetch error:", err);
    printAnimated(colorize("> Failed to fetch response.", "#ff0000"), 30, () => {
      setTimeout(createInputLine, 700);
    });
  }
}
</script>
<script>
    /**
 * Wraps the given sentence in a <span> with the specified font size.
 * This does NOT search the DOM; it just returns the styled string.
 * @param {string} sentence - The text to style.
 * @param {string} size - Font size, e.g., '40px', '2em'.
 * @returns {string} - HTML string with inline styling.
 */
function setSentenceSize(sentence, size) {
  return `<span style="font-size:${size}">${sentence}</span>`;
}
</script>
<script>
    /**
 * Show a red popup box with multiple sentences.
 * Appears after initialDelay, each sentence shows for 10s.
 * After last sentence, waits 10s then disappears.
 *
 * @param {Array} sentences - Sentences to show
 * @param {number} initialDelay - Delay before first appearance in ms
 */
function showRedBox(sentences, initialDelay) {
    let box = document.getElementById('redBox');
    if (!box) {
        box = document.createElement('div');
        box.id = 'redBox';
        document.body.appendChild(box);
    }

    setTimeout(() => {
        let index = 0;
        box.innerText = sentences[index];
        box.style.display = 'block';

        const interval = setInterval(() => {
            index++;
            if (index >= sentences.length) {
                clearInterval(interval);
                // after last sentence, wait 10s then hide
                setTimeout(() => {
                    box.style.display = 'none';
                }, 10000);
            } else {
                box.innerText = sentences[index];
            }
        }, 10000); // 10 seconds between sentences

    }, initialDelay);
}
</script>
<style>
#warningBox {
  display: none;
  position: fixed;
  top: 50%;           /* center vertically */
  left: 50%;          /* center horizontally */
  transform: translate(-50%, -50%);  /* shift half width & height to center */
  background-color: black;
  color: red;
  font-family: monospace;
  font-size: 9px;
  padding: 40px 20px 20px 20px;
  border: 3px solid black;
  border-radius: 8px;
  z-index: 9999;
  text-align: left;
  max-width: 90%;
  box-shadow: 0 0 20px red;
  
  animation: blinkShadow 1s infinite;
  margin-bottom: 500px;
}


/* blinking shadow animation (speed set dynamically from JS) */
@keyframes blinkShadow {
  0%   { box-shadow: 0 0 20px red; background-color: black; }
  50%  { box-shadow: 0 0 5px red; background-color: rgb(100,0,0); }
  100% { box-shadow: 0 0 20px red; background-color: black; }
}

/* ERROR label on top left */
#warningBox .errorLabel {
  position: absolute;
  top: 10px;
  left: 15px;
  font-size: 12px;
  color: red;
}

/* Timer on top right */
#warningBox .timer {
  position: absolute;
  top: 10px;
  right: 13px;
  font-size: 10px;
  color: red;
}
</style>
<script>
 /**
 * Show a blinking warning box with ERROR, timer and animated message.
 * @param {string} message - Message to show
 * @param {number} blinkSpeed - Blink speed in ms
 * @param {number} countdownSeconds - Timer in seconds
 * @param {function} callback - Called when timer ends
 */
function showWarningBox(message, blinkSpeed, countdownSeconds, callback) {
    let box = document.getElementById('warningBox');
    if (!box) {
        box = document.createElement('div');
        box.id = 'warningBox';
        
        // ERROR label (top left)
        let errorLabel = document.createElement('div');
        errorLabel.className = 'errorLabel';
        errorLabel.innerText = '⚠ ERROR';
        box.appendChild(errorLabel);
        
        // Timer (top right)
        let timer = document.createElement('div');
        timer.className = 'timer';
        timer.id = 'bombTimer';
        box.appendChild(timer);
        
        // Message container
        let messageContainer = document.createElement('div');
        messageContainer.id = 'warningMessage';
        box.appendChild(messageContainer);
        
        document.body.appendChild(box);
    }

    // Set blink speed dynamically
    box.style.animationDuration = blinkSpeed + 'ms';

    // Show box
    box.style.display = 'block';

    // Start countdown timer
    let remaining = countdownSeconds;
    const timerEl = document.getElementById('bombTimer');
    timerEl.innerText = formatTime(remaining);
    const timerInterval = setInterval(() => {
        remaining--;
        timerEl.innerText = formatTime(remaining);
        if (remaining <= 0) {
            clearInterval(timerInterval);
            if (typeof callback === 'function') {
                callback();
            }
            // Hide box after callback runs
            box.style.display = 'none';
        }
    }, 1000);

    // Animate message inside box
    printAnimatedColorize(message, 'warningMessage');
}

/**
 * Format seconds to classic timer: e.g. 00:09
 */
function formatTime(seconds) {
    const s = seconds < 10 ? '0' + seconds : seconds;
    return '00:' + s;
}

/**
 * Type text letter by letter into target element.
 */
function printAnimatedColorize(text, elementId) {
    let el = document.getElementById(elementId);
    el.innerHTML = ''; // clear previous
    let i = 0;
    let interval = setInterval(() => {
        el.innerHTML += text[i];
        i++;
        if (i >= text.length) {
            clearInterval(interval);
        }
    }, 10); // typing speed
}
</script>


    
    

<script>
let screamCanvas, screamCtx;
let screamSamples = [];
let screamMax = 0;
let screamInterval;

function micScreamTask(successMessage, failureMessage, onSuccess = null, onFail = null) {
  printAnimated(colorize("lambda > Task: Scream loudly. Reach the maximum frequency line to succeed.", "red"), 30, async () => {
    try {
      waveformStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      waveformAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const source = waveformAudioCtx.createMediaStreamSource(waveformStream);
      waveformAnalyser = waveformAudioCtx.createAnalyser();
      waveformAnalyser.fftSize = 1024;

      waveformData = new Uint8Array(waveformAnalyser.fftSize);
      source.connect(waveformAnalyser);

      // Setup scream canvas
      screamCanvas = document.createElement("canvas");
      screamCanvas.width = 320;
      screamCanvas.height = 190;
      screamCanvas.style.background = "black";
      screamCanvas.style.border = "1px solid red";
      screamCanvas.style.display = "block";
      screamCanvas.style.marginTop = "5px";

      screamCtx = screamCanvas.getContext("2d");
      document.getElementById("terminal").appendChild(screamCanvas);

      screamSamples = [];
      screamMax = 0;

      printAnimated(colorize("lambda > Listening for your scream (10 seconds)...", "red"), 30, () => {
        screamInterval = setInterval(updateScreamGraph, 100);

        setTimeout(() => {
          finishScreamCheck(successMessage, failureMessage, onSuccess, onFail);
        }, 10000);
      });
    } catch (err) {
      printAnimated(colorize("lambda > ERROR: Microphone access denied.", "red"), 30, createInputLine);
    }
  });
}

function updateScreamGraph() {
  waveformAnalyser.getByteTimeDomainData(waveformData);

  let total = 0;
  for (let i = 0; i < waveformData.length; i++) {
    total += Math.abs(waveformData[i] - 128);
  }
  const average = total / waveformData.length;
  screamSamples.push(average);
  if (average > screamMax) screamMax = average;

  // Draw axis grid
  screamCtx.clearRect(0, 0, screamCanvas.width, screamCanvas.height);
  screamCtx.strokeStyle = "gray";
  screamCtx.beginPath();

  for (let i = 0; i <= 10; i++) {
    const x = (i / 10) * screamCanvas.width;
    screamCtx.moveTo(x, 0);
    screamCtx.lineTo(x, screamCanvas.height);
  }

  for (let i = 0; i <= 5; i++) {
    const y = (i / 5) * screamCanvas.height;
    screamCtx.moveTo(0, y);
    screamCtx.lineTo(screamCanvas.width, y);
  }
  screamCtx.stroke();

  // Draw threshold line
  const thresholdY = screamCanvas.height - (65 * 2); // Y = height - threshold * amplification
  screamCtx.beginPath();
  screamCtx.strokeStyle = "red";
  screamCtx.setLineDash([5, 5]); // dashed line
  screamCtx.moveTo(0, thresholdY);
  screamCtx.lineTo(screamCanvas.width, thresholdY);
  screamCtx.stroke();
  screamCtx.setLineDash([]); // reset dash

  // Draw waveform line
  screamCtx.beginPath();
  screamCtx.strokeStyle = "red";
  for (let i = 0; i < screamSamples.length; i++) {
    const x = (i / 100) * screamCanvas.width;
    const y = screamCanvas.height - (screamSamples[i] * 2); // amplify Y
    if (i === 0) screamCtx.moveTo(x, y);
    else screamCtx.lineTo(x, y);
  }
  screamCtx.stroke();

  document.getElementById("terminal").scrollTop = terminal.scrollHeight;
}

function finishScreamCheck(successMessage, failureMessage, onSuccess, onFail) {
  clearInterval(screamInterval);
  stopWaveformMic();

  const threshold = 100; // Increased sensitivity (user must scream louder)

  setTimeout(() => {
    if (screamMax >= threshold) {
      printAnimated(colorize(successMessage || "lambda > ✅ Powerful scream detected! Success.", "red"), 30, () => {
        if (onSuccess) onSuccess();
        else createInputLine();
      });
    } else {
      printAnimated(colorize(failureMessage || "lambda > ❌ Scream not strong enough. Try harder.", "red"), 30, () => {
        if (onFail) onFail(); // Run punishment
        else createInputLine();
      });
    }
  }, 500);
}

</script>
<video id="selfieVideo" autoplay playsinline style="display:none; position:fixed; top:0; left:0; z-index:-1;"></video>
<input type="file" id="selfieUpload" accept="image/png" style="display:none;">
<style>
  .inline-terminal-button {
    display: inline-block;
    margin-left: 50px;
    margin-top: 10px;
    padding: 8px 14px;
    font-size: 14px;
    font-weight: bold;
    border: 2px solid red;
    background-color: black;
    color: red;
    border-radius: 30px;
    text-shadow: 0 0 5px red;
    box-shadow: 0 0 5px red;
    cursor: pointer;
    transition: 0.2s;
  }
   .inline-terminal-button1 {
    display: inline-block;
    margin-left: 20px;
    margin-top: 10px;
    padding: 8px 14px;
    font-size: 14px;
    font-weight: bold;
    border: 2px solid red;
    background-color: black;
    color: red;
    border-radius: 30px;
    text-shadow: 0 0 5px red;
    box-shadow: 0 0 5px red;
    cursor: pointer;
    transition: 0.2s;
  }
  .inline-terminal-button:hover {
    box-shadow: 0 0 40px red;
    background-color: #111;
  }
  .inline-terminal-button1:hover {
    box-shadow: 0 0 40px red;
    background-color: #111;
  }
  #cameraPreview {
  border: 2px solid #ff001f;
    width: 220px;
    height: auto;
    filter: brightness(0.7) contrast(1.2) sepia(0.4) hue-rotate(-20deg);
    border-radius: 10px;
    margin-top: 10px;
  }
  .inline-file-input {
    color: red;
    width: 60%;
    background: black;
    border: 2px solid red;
    border-radius: 20px;
    padding: 12px 18px;
    display: inline-block;
    margin-top: 10px;
    margin-left: 10px;
    font-size: 14px;
  }
</style>

<script>
function selfieVerificationTask(successCallback, failureCallback, onSuccessMessage, onFailureMessage) {
  printAnimated(colorize("Λ > Task: Identity verification activated.", "red"), 30, () => {
    printAnimated(colorize("Λ > Step 1: Activating camera...", "red"), 30, async () => {
      const video = document.createElement("video");
      video.setAttribute("autoplay", true);
      video.setAttribute("id", "cameraPreview");
      document.getElementById("terminal").appendChild(video);

      let stream;
      try {
        stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
      } catch (err) {
        printAnimated(colorize("Λ > ERROR: Camera access denied.", "red"), 30);
        return;
      }

      // Button for taking selfie
      const snapBtn = document.createElement("button");
      snapBtn.textContent = "📸 Take Selfie";
      snapBtn.className = "inline-terminal-button";
      document.getElementById("terminal").appendChild(snapBtn);
      
      printAnimated(colorize("Λ > ...............", "red"));

      // Snapshot logic
      snapBtn.onclick = () => {
        const canvas = document.createElement("canvas");
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext("2d");
        ctx.filter = "brightness(0.7) contrast(1.2) sepia(0.4) hue-rotate(-20deg)";
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const imageData = canvas.toDataURL("image/png");

        // Generate random filename
        const randomID = Math.floor(1000 + Math.random() * 9000);
        const selfieFileName = `lambda_selfie_${randomID}.png`;

        // Download image
        const a = document.createElement("a");
        a.href = imageData;
        a.download = selfieFileName;
        a.click();

        stream.getTracks().forEach(track => track.stop());
        video.remove();
        snapBtn.remove();

        printAnimated(colorize("Λ > Step 2: Upload the downloaded selfie for verification.", "red"), 30, () => {
          const fileInput = document.createElement("input");
          fileInput.type = "file";
          fileInput.className = "inline-file-input";
          document.getElementById("terminal").appendChild(fileInput);
         printAnimated(colorize("Λ > ................", "red"));
          fileInput.addEventListener("change", () => {
            const uploadedFile = fileInput.files[0];
            if (!uploadedFile) return;
            fileInput.remove();

            if (uploadedFile.name === selfieFileName) {
              if (onSuccessMessage) onSuccessMessage();
              if (successCallback) successCallback();
            } else {
              if (onFailureMessage) onFailureMessage();
              if (failureCallback) failureCallback();
            }
          });
        });
      };
    });
  });
}
</script>
<script>
    function timedVideoVerificationTask(durationInSeconds, successCallback, failureCallback) {
  printAnimated(colorize("Λ > Task: Timed video identity verification activated.", "red"), 30, () => {
    printAnimated(colorize("Λ > Step 1: Activating camera...", "red"), 30, async () => {
      const video = document.createElement("video");
      video.setAttribute("autoplay", true);
      video.setAttribute("id", "cameraPreview");
      document.getElementById("terminal").appendChild(video);

      let stream;
      try {
        stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        video.srcObject = stream;
      } catch (err) {
        printAnimated(colorize("Λ > ERROR: Camera access denied.", "red"), 30);
        return;
      }

      const recordBtn = document.createElement("button");
      recordBtn.textContent = "🎥 Record Timed Video";
      recordBtn.className = "inline-terminal-button1";
      document.getElementById("terminal").appendChild(recordBtn);

      let recorder;
      let chunks = [];
      const randomID = Math.floor(1000 + Math.random() * 9000);
      const videoFileName = `lambda_video_${randomID}.webm`;

      recordBtn.onclick = () => {
        if (!recorder) {
          recorder = new MediaRecorder(stream);
          recorder.ondataavailable = e => chunks.push(e.data);
          recorder.onstop = () => {
            const blob = new Blob(chunks, { type: "video/webm" });
            const url = URL.createObjectURL(blob);

            // Download the video
            const a = document.createElement("a");
            a.href = url;
            a.download = videoFileName;
            a.click();

            stream.getTracks().forEach(track => track.stop());
            video.remove();
            recordBtn.remove();

            printAnimated(colorize("Λ > Step 2: Upload the downloaded video for verification.", "red"), 30, () => {
              const fileInput = document.createElement("input");
              fileInput.type = "file";
              fileInput.className = "inline-file-input";
              document.getElementById("terminal").appendChild(fileInput);

              fileInput.addEventListener("change", () => {
                const uploadedFile = fileInput.files[0];
                if (!uploadedFile) return;
                fileInput.remove();

                if (uploadedFile.name === videoFileName) {
                  printAnimated(colorize("Λ > Match confirmed. Identity verified.", "red"), 30);
                  if (successCallback) successCallback();
                } else {
                  printAnimated(colorize("Λ > Mismatch. Identity verification failed.", "red"), 30);
                  if (failureCallback) failureCallback();
                }
              });
            });
          };

          // Start recording and stop after `durationInSeconds`
          recorder.start();
          recordBtn.disabled = true;
          printAnimated(colorize(`Λ > Recording for ${durationInSeconds} seconds...`, "red"), 30);
          setTimeout(() => {
            recorder.stop();
          }, durationInSeconds * 1000);
        }
      };
    });
  });
}
</script>

<script>
    <!-- battery percentage detection system -->
   // Battery percentage detection system
async function batteryDrainTest(threshold, successCallback, failureCallback) {
  printAnimated(colorize("Λ > Task: Scheduled Energy Depletion Check Initiated.", "red"), 30, () => {
    loadingBarAnimation("Λ > Connecting to internal energy sensors...", 5000, () => {
      dotLoadingAnimation("Λ > Syncing battery telemetry ", 4000, async () => {

        try {
          const battery = await navigator.getBattery();
          let percent = Math.floor(battery.level * 100);

          // Create an animation line in terminal
          let animationLine = document.createElement("div");
          animationLine.classList.add("terminal-line");
          terminal.appendChild(animationLine);

          let progress = 0;
          const batteryInterval = setInterval(() => {
            if (progress > percent) {
              clearInterval(batteryInterval);
              setTimeout(() => {
                printAnimated(colorize(`Λ > Energy Level: ${percent}%`, "red"), 30, () => {
                  if (percent < threshold) {
                    printAnimated(colorize("Λ > Energy level below survival threshold.", "red"), 30, () => {
                      printAnimated(colorize("Λ > Outcome: PASSED", "green"), 30, successCallback);
                    });
                  } else {
                    printAnimated(colorize("Λ > Energy too high for depletion protocol.", "red"), 30, () => {
                      printAnimated(colorize("Λ > Outcome: FAILED", "yellow"), 30, failureCallback);
                    });
                  }
                });
              }, 500);
            } else {
              animationLine.innerHTML = colorize(`Λ > Calculating energy... [${progress}%]`, "red");
              progress++;
            }
          }, 20);
        } catch (e) {
          printAnimated(colorize("Λ > ERROR: Unable to access battery data.", "yellow"), 30, failureCallback);
        }

      });
      printAnimated(colorize("     ", "red"));
    });
    printAnimated(colorize("     ", "red"));
  });
}
</script>

<script>
    <!-- loading animation -->
    function loadingAnimationInTerminal(message = "Λ > Loading", duration = 3000, callback) {
  const spinnerFrames = ['⠋','⠙','⠹','⠸','⠼','⠴','⠦','⠧','⠇','⠏'];
  let i = 0;
  let frameCount = 0;
  
  // Create a blank line to update
  const line = document.createElement("div");
  line.classList.add("terminal-line");
  terminal.appendChild(line);

  const interval = setInterval(() => {
    const frame = spinnerFrames[i % spinnerFrames.length];
    line.innerHTML = `<span style="color:red;">${message} ${frame}</span>`;
    i++;
    frameCount += 80;
  }, 80);

  setTimeout(() => {
    clearInterval(interval);
    line.innerHTML = `<span style="color:red;">${message} ✔</span>`;
    if (callback) callback();
  }, duration);
}


function dotLoadingAnimation(message = "Λ > Processing", duration = 3000, callback) {
  const dots = ["", ".", "..", "..."];
  let i = 0;

  const line = document.createElement("div");
  line.classList.add("terminal-line");
  terminal.appendChild(line);

  const interval = setInterval(() => {
    line.innerHTML = `<span style="color:red;">${message}${dots[i % dots.length]}</span>`;
    i++;
  }, 500);

  setTimeout(() => {
    clearInterval(interval);
    line.innerHTML = `<span style="color:red;">${message} ✔</span>`;
    if (callback) callback();
  }, duration);
}


function loadingBarAnimation(message = "Λ > Initializing", duration = 4000, callback) {
  const barLength = 21;
  const line = document.createElement("div");
  line.classList.add("terminal-line");
  terminal.appendChild(line);

  const startTime = Date.now();

  function updateBar() {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const filled = Math.round(progress * barLength);
    const empty = barLength - filled;
    const bar = "█".repeat(filled) + "░".repeat(empty);

    line.innerHTML = `<span style="color:red;">${message} [${bar}] ${Math.round(progress * 100)}%</span>`;

    if (progress < 1) {
      requestAnimationFrame(updateBar);
    } else {
      line.innerHTML = `<span style="color:red;">${message} [${"█".repeat(barLength)}] 100% ✔</span>`;
      if (callback) callback();
    }
  }

  updateBar();
  
}


function loadingBarCreepy(message = "Λ > Syncing neural cortex", duration = 5000, callback) {
  const segments = 15;
  const line = document.createElement("div");
  line.classList.add("terminal-line");
  terminal.appendChild(line);

  const startTime = Date.now();

  function getBar(progress) {
    const filled = Math.round(progress * segments);
    let bar = "";
    for (let i = 0; i < segments; i++) {
      bar += i < filled ? "▮" : "▯";  // Filled = ▮, Empty = ▯ (or use ▓ ░)
    }
    return bar;
    
  }

  function updateBar() {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const bar = getBar(progress);
    const percent = Math.round(progress * 100);

    line.innerHTML = `<span style="color:red;">${message} [${bar}] ${percent}%</span>`;

    if (progress < 1) {
      requestAnimationFrame(updateBar);
    } else {
      line.innerHTML = `<span style="color:red;">${message} [${getBar(1)}] 100% ✔</span>`;
      if (callback) callback();
    }
  }

  updateBar();
  printAnimated(colorize("    ", "red"), 30);
}

</script>

<script>
function checkChargingStatusOnce(onCharging, onNotCharging) {
  if (!navigator.getBattery) {
    console.log("Battery API not supported.");
    return;
  }

  navigator.getBattery().then(function(battery) {
    if (battery.charging) {
      if (typeof onCharging === 'function') onCharging();
    } else {
      if (typeof onNotCharging === 'function') onNotCharging();
    }
  });
}

function usbCheckCommand() {
  checkChargingStatusOnce(
    () => {
      printAnimated(colorize("Λ > External power detected...\nThis isn’t your choice, is it?", "red"), 30);
    },
    () => {
      printAnimated(colorize("Λ > No power... exactly how we like it.", "red"), 30);
    }
  );
}
</script>





 
<!-- Load html2canvas -->
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

<script>
/**
 * Generate a unique random filename using date + ID.
 */
function generateRandomFilename() {
  const now = new Date();
  const timestamp = now.toISOString().replace(/[-:.TZ]/g, '').slice(0, 14);
  const randomId = Math.random().toString(36).substring(2, 8);
  return `terminal_capture_${timestamp}_${randomId}.png`;
}

/**
 * Captures the entire content inside the terminal (even if scrollable)
 * and saves it as a PNG image with a random filename.
 * @param {string} selector - The CSS selector of your terminal div.
 */
function captureFullTerminal(selector = '#terminal') {
  const terminal = document.querySelector(selector);

  if (!terminal) {
    console.error('❌ Terminal element not found:', selector);
    return;
  }

  // Temporarily expand terminal to full height so html2canvas can capture it all
  const originalHeight = terminal.style.height;
  terminal.style.height = terminal.scrollHeight + 'px';

  html2canvas(terminal, {
    useCORS: true,
    allowTaint: true,
    backgroundColor: null,
    width: terminal.scrollWidth,
    height: terminal.scrollHeight,
    windowWidth: terminal.scrollWidth,
    windowHeight: terminal.scrollHeight,
  }).then(canvas => {
    const imageData = canvas.toDataURL('image/png');
    const filename = generateRandomFilename();

    const link = document.createElement('a');
    link.href = imageData;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    // Reset terminal height
    terminal.style.height = originalHeight;

    console.log('✅ Terminal screenshot saved:', filename);
  }).catch(error => {
    console.error('❌ Screenshot capture failed:', error);
  });
}
</script>













<style>
body {
  margin: 0;
  background: black;
  color: white;
  overflow-x: hidden;
}
    
#sidePanel {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  position: fixed;
  top: 5%;
  right: -300px; /* start hidden */
  width: 300px;
  height: 70%;
  background: rgba(255, 255, 255, 0.1); /* transparent glass */
  border: 5px solid rgba(255, 255, 255, 0.2);
  transition: right 0.3s ease;
  display: flex;
  flex-direction: column;
  z-index: 9999; /* make sure it's on top */

  /* 🌟 Glassmorphism effect */
  backdrop-filter: blur(15px) saturate(180%);
  -webkit-backdrop-filter: blur(15px) saturate(180%);
  box-shadow: -4px 0 20px rgba(0, 0, 0, 0.5); 
  border-radius: 30px;
}

#chatMessages {
  flex: 1;
  padding: 10px;
  overflow-y: auto;
}

/* 🌟 Add this block to enable bold, italic, underline, colors, and line breaks */
#chatMessages span {
  font-weight: normal;      /* JS can override to bold */
  font-style: normal;       /* JS can override to italic */
  text-decoration: none;    /* JS can override to underline */
  color: inherit;           /* JS can override color */
  white-space: pre-wrap;    /* respect \n for line breaks */
}

/* Optional: allow emojis to scale nicely */
#chatMessages span img, 
#chatMessages span.emoji {
  width: 1em;
  height: 1em;
  vertical-align: middle;
}

#chatInputArea {
  display: flex;
  border-top: 1px solid #333;
}

#chatInput {
  flex: 1;
  padding: 8px;
  border: none;
  outline: none;
  background: #222;
  color: white;
  resize: none;
  height: 40px;
  margin: 7px;

  background: rgba(255, 255, 255, 0.1); /* transparent glass */
  border: 3px solid rgba(255, 255, 255, 0.2);
  transition: right 0.3s ease;

  /* 🌟 Glassmorphism effect */
  backdrop-filter: blur(15px) saturate(180%);
  -webkit-backdrop-filter: blur(15px) saturate(180%);
  box-shadow: -4px 0 20px rgba(0, 0, 0, 0.5); 
  border-radius: 30px;
}

#sendBtn {
  background: #444;
  border: none;
  color: white;
  padding: 8px 12px;
  cursor: pointer;
  margin: 7px;
  background: rgba(255, 255, 255, 0.1); /* transparent glass */
  border: 3px solid rgba(255, 255, 255, 0.2);
  transition: right 0.3s ease;

  /* 🌟 Glassmorphism effect */
  backdrop-filter: blur(15px) saturate(180%);
  -webkit-backdrop-filter: blur(15px) saturate(180%);
  box-shadow: -4px 0 20px rgba(0, 0, 0, 0.5); 
  border-radius: 30px;
}
</style>

<div id="main-content">
<div id="sidePanel">
  <div id="chatMessages"></div>
  <div id="chatInputArea">
    <textarea id="chatInput" placeholder="Type..."></textarea>
    <button id="sendBtn">Send</button>
  </div>
</div>

<input type="file" id="pdfInput" accept="application/pdf" style="display:none;">
</div>
<script>
    
    
    function fadeInText(id, duration = 2000) {
    const element = document.getElementById(id);
    if (!element) return;

    let start = null;

    function step(timestamp) {
        if (!start) start = timestamp;
        let progress = timestamp - start;
        // Calculate opacity from 0 (invisible) to 1 (fully visible)
        let opacity = Math.min(progress / duration, 1);
        element.style.opacity = opacity;
        if (progress < duration) {
            requestAnimationFrame(step);
        }
    }

    // Start fully transparent
    element.style.opacity = 0;
    requestAnimationFrame(step);
}



document.addEventListener('DOMContentLoaded', () => {
  const sidePanel = document.getElementById('sidePanel');
  const chatMessages = document.getElementById('chatMessages');
  const chatInput = document.getElementById('chatInput');
  const sendBtn = document.getElementById('sendBtn');

  if (!sidePanel || !chatMessages || !chatInput || !sendBtn) {
    console.warn('Missing one of: sidePanel, chatMessages, chatInput, sendBtn');
    return;
  }

  // =========================
  // PANEL OPEN / CLOSE
  // =========================
  function isPanelOpen() {
    return sidePanel.classList.contains('open');
  }

  function openPanel() {
    sidePanel.style.right = '0px';
    sidePanel.classList.add('open');

    chatInput.style.display = '';
    chatInput.disabled = false;
    chatInput.tabIndex = 0;
    chatInput.setAttribute('aria-hidden', 'false');

    sendBtn.style.display = '';
    sendBtn.disabled = false;
  }

  function closePanel() {
    sidePanel.style.right = '-300px';
    sidePanel.classList.remove('open');

    try { chatInput.blur(); } catch(e) {}
    chatInput.disabled = true;
    chatInput.tabIndex = -1;
    chatInput.style.display = 'none';
    chatInput.setAttribute('aria-hidden', 'true');

    sendBtn.style.display = 'none';
    sendBtn.disabled = true;
  }

  closePanel();

  // =========================
  // TYPING ANIMATION
  // =========================
  const emojiDict = { ":smile:":"😄", ":fire:":"🔥", ":heart:":"❤️", ":star:":"⭐" };

  function addText(message, callback) {
  const msg = document.createElement('div');
  chatMessages.appendChild(msg);

  const parts = [];
  const regex = /(\*\*(.*?)\*\*|_(.*?)_|__(.*?)__|\{(#[0-9a-fA-F]{3,6}|[a-zA-Z]+)(:(\d+):)?:(.*?)\}|:[a-zA-Z_]+:)/g;
  let lastIndex = 0, match;

  while ((match = regex.exec(message)) !== null) {
    if (match.index > lastIndex) parts.push({ text: message.slice(lastIndex, match.index) });
    if (match[2]) parts.push({ text: match[2], bold:true });
    else if (match[3]) parts.push({ text: match[3], italic:true });
    else if (match[4]) parts.push({ text: match[4], underline:true });
    else if (match[5]) {
      const color = match[5];
      const speed = match[7]?parseInt(match[7]):30;
      parts.push({ text: match[8], color, speed });
    } else if (match[0].startsWith(":") && match[0].endsWith(":")) {
      const emoji = emojiDict[match[0]] || match[0];
      parts.push({ text: emoji });
    }
    lastIndex = regex.lastIndex;
  }

  if (lastIndex < message.length) parts.push({ text: message.slice(lastIndex) });

  let partIndex = 0, charIndex = 0;

  function type() {
    if (partIndex >= parts.length) {
      if (callback) callback(); // ✅ call callback when finished
      return;
    }

    const part = parts[partIndex];

    if (!msg.children[partIndex]) {
      const span = document.createElement('span');
      if (part.bold) span.style.fontWeight = 'bold';
      if (part.italic) span.style.fontStyle = 'italic';
      if (part.underline) span.style.textDecoration = 'underline';
      if (part.color) span.style.color = part.color;
      msg.appendChild(span);
    }

    const span = msg.children[partIndex];
    const char = part.text.charAt(charIndex);

    if (char === "\n") span.innerHTML += "<br>";
    else span.innerHTML += char;

    charIndex++;
    chatMessages.scrollTop = chatMessages.scrollHeight;

    const delay = part.speed || 30;

    if (charIndex < part.text.length) setTimeout(type, delay);
    else {
      partIndex++;
      charIndex = 0;
      setTimeout(type, 0); // start next part immediately
    }
  }

  type();
}
  // =========================
  // COMMAND HANDLER
  // =========================
  sendBtn.addEventListener('click', () => {
    const input = (chatInput.value || '').trim();
    if (!input) return;
    addText('> ' + input);
    handleSideCommand(input);
    chatInput.value = '';
  });

  function handleSideCommand(cmd) {
    switch(cmd.toLowerCase()){
      case 'hello': addText('Hi there!'); break;
      case 'close': closePanel(); break;
      case 'open': openPanel(); break;
      case 'video': playVideoInPanel('birthday.mp4'); break;
      case 'youtube': playYouTubeVideoInPanel('https://www.youtube.com/watch?v=pd6Aw5TCwlE'); break;
      case 'image': showImageInPanel('3d-birthday-cake-with-candles-and-decorations-pink-cake-emoji-party-surprise-two-tier-wedding.jpg'); break;
      case 'image1': showImageInPanel('Screenshot_20250825_143344_TrebEdit.jpg'); break;
      case 'image2': showImageInPanel('3d-birthday-cake-with-candles-and-decorations-pink-cake-emoji-party-surprise-two-tier-wedding.jpg'); break;
      case 'pdf': showPDFInPanel('https://example.com/sample.pdf'); break;
      case 'pdf1': selectAndShowPDF(); break;
      default: addText('Unknown command.');
    }
  }

  // =========================
  // MEDIA HELPERS
  // =========================
  function playVideoInPanel(url) {
    const videoEl=document.createElement('video');
    videoEl.src=url; videoEl.controls=true; videoEl.width=250; videoEl.height=140;
    videoEl.autoplay=false; videoEl.style.background='rgba(255,255,255,0.1)';
    videoEl.style.border='3px solid rgba(255,255,255,0.2)'; videoEl.style.borderRadius='10px';
    videoEl.style.display='block'; videoEl.style.margin='8px 0';
    chatMessages.appendChild(videoEl); chatMessages.scrollTop=chatMessages.scrollHeight;
  }

  function playYouTubeVideoInPanel(youtubeUrl) {
    const iframeEl=document.createElement('iframe');
    iframeEl.width=250; iframeEl.height=140; iframeEl.style.border='3px solid rgba(255,255,255,0.2)';
    iframeEl.style.borderRadius='10px'; iframeEl.style.display='block'; iframeEl.style.margin='8px 0';
    iframeEl.allow="autoplay; encrypted-media";
    const videoId = youtubeUrl.split('v=')[1].split('&')[0];
    iframeEl.src=`https://www.youtube.com/embed/${videoId}?autoplay=1`;
    chatMessages.appendChild(iframeEl); chatMessages.scrollTop=chatMessages.scrollHeight;
  }

  function showImageInPanel(imageUrl){
    const imgEl=document.createElement('img'); imgEl.src=imageUrl;
    imgEl.style.border='4px solid rgba(255,255,255,0.2)'; imgEl.style.borderRadius='10px';
    imgEl.style.display='block'; imgEl.style.margin='8px 0'; imgEl.style.background='black';
    imgEl.style.maxWidth='95%'; imgEl.style.height='auto';
    chatMessages.appendChild(imgEl); chatMessages.scrollTop=chatMessages.scrollHeight;
  }

  function showPDFInPanel(pdfUrl){
    const pdfEl=document.createElement('iframe'); pdfEl.src=pdfUrl; pdfEl.width='250'; pdfEl.height='300';
    pdfEl.style.border='3px solid rgba(255,255,255,0.2)'; pdfEl.style.borderRadius='10px';
    pdfEl.style.display='block'; pdfEl.style.margin='8px 0';
    chatMessages.appendChild(pdfEl); chatMessages.scrollTop=chatMessages.scrollHeight;
  }

  function selectAndShowPDF(){
    const pdfInput=document.getElementById('pdfInput'); if(!pdfInput) return;
    pdfInput.value='';
    pdfInput.onchange=(e)=>{ const file=e.target.files[0]; if(!file)return;
      const fileURL=URL.createObjectURL(file); showPDFInPanel1(fileURL); };
    pdfInput.click();
  }

  function showPDFInPanel1(pdfUrl){
    const iframeEl=document.createElement('iframe'); iframeEl.width='250'; iframeEl.height='300';
    iframeEl.style.border='3px solid rgba(255,255,255,0.2)'; iframeEl.style.borderRadius='10px';
    iframeEl.style.display='block'; iframeEl.style.margin='8px 0'; iframeEl.style.background='black';
    iframeEl.src=`https://docs.google.com/gview?url=${encodeURIComponent(pdfUrl)}&embedded=true`;
    chatMessages.appendChild(iframeEl); chatMessages.scrollTop=chatMessages.scrollHeight;
  }

  // =========================
  // WELCOME MESSAGE
  // =========================
function showWelcomeMessage() {
  addText("Welcome to **Lambda Neural Terminal Assistant**\n\n", () => {
    addText("If you are here, we assume you have the proper permission to access this system. If you do not have authorization, please be aware that unauthorized access may violate **copyright and legal laws**.\n\n", () => {
      addText("If you do have permission, then I am your assistant. This panel you are accessing right now is your **Media Manager and Helper**, designed to provide all necessary assistance within this terminal.\n\n", () => {
        addText("To continue your experience and access the game, you must first allow all necessary permissions. If your system gets stuck in a loop, you may need to manually manage permissions. For guidance, type **permission help** to access the tutorial video.\n\n", () => {
          addText("Please note, this Neural Terminal Assistant and its gaming system are currently in development. You may encounter occasional glitches or issues. Right now, you can experience a few **AI-driven tasks** and interact with the **CI (Command Interface)**.\n\n", () => {
            addText("For a full list of commands and detailed guidance, type **help** in the main terminal. The system is expected to be fully developed by the last month of 2026.\n\n", () => {
              addText("The most exciting part: if you are authorized and successfully complete this challenge, you may become the owner of this entire Neural Terminal Assistant system, gaining full control over this virtual system.\n\n", () => {
                addText("Remember, this terminal executes commands, while I—powered by the **Gemini API**—handle all questions, responses, and required guidance.\n\n", () => {
                  addText("Prepare yourself. Permission granted or not, your journey **begins here**.");
                });
              });
            });
          });
        });
      });
    });
  });
}
  // =========================
  // GLOBAL EXPOSE
  // =========================
  window.openPanel = openPanel;
  window.closePanel = closePanel;
  window.addText = addText;
  window.showWelcomeMessage = showWelcomeMessage;

  // =========================
  // KEYBOARD + TOUCH EVENTS
  // =========================
  document.addEventListener('keydown', (e) => {
    if(e.key!=='Enter') return;
    const inputVisible=!chatInput.disabled && chatInput.style.display!=='none' && isPanelOpen();
    if(inputVisible && document.activeElement===chatInput){ e.preventDefault(); return; }
    e.preventDefault(); 
    if(typeof runMainTerminalCommand==='function') runMainTerminalCommand();
  });

  let startX=0;
  document.addEventListener('touchstart',(e)=>{if(e.touches && e.touches[0]) startX=e.touches[0].clientX;});
  document.addEventListener('touchend',(e)=>{if(!e.changedTouches||!e.changedTouches[0]) return; const endX=e.changedTouches[0].clientX; const diff=endX-startX;
    if(diff<-50 && !isPanelOpen()) openPanel();
    if(diff>50 && isPanelOpen()) closePanel();
  });
 });
 
 
 
  // =========================
  // AUTO SHOW WELCOME MESSAGE
  // =========================
  
  
  setTimeout(() => { 
        showWelcomeMessage(); // <- your advert message
      }, 5000);
    
    
    
   function showWelcomeOnce() {
  const key = "welcomeShown1";

  if (!localStorage.getItem(key)) {
    // 👇 Your one-time advert / welcome logic
    alert("🎉 Welcome! This is your first visit.");
  
    setTimeout(() => {
      openPanel(); // <- your advert panel
      setTimeout(() => { 
        showWelcomeMessage(); // <- your advert message
      }, 5000);
    }, 30000);
 

    // ✅ Mark as shown so it never runs again
    localStorage.setItem(key, "true");
  }
}
    
  
  </script>







    <style>
      /* Body and overall page settings */
        body {
            margin: 0;
           
            overflow: hidden; /* Prevents scrolling while the splash screen is active */
            transition: opacity 1s ease-in-out;
        }

        /* Splash Screen Styles */
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensures the splash screen is on top of everything */
            transition: opacity 1s ease-in-out;
        }

        #splash-screen.hidden {
            opacity: 0;
            pointer-events: none; /* Disables clicks on the hidden element */
        }

        #splash-screen img {
            max-width: 80%;
            max-height: 80%;
        }

        /* Main Content Styles */
        #main-content {
            display: none; /* Hides the content initially */
            
        }

        /* Add all of your other 4000 lines of CSS here */
        /* ... */

    </style>


    <div id="splash-screen">
        <img src="logo.jpg" alt="Your Company Logo">
    </div>

    

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const splashScreen = document.getElementById('splash-screen');
            const mainContent = document.getElementById('main-content');
            
            const splashDuration = 3000; // 3 seconds

            // Hide the splash screen after the set duration
            setTimeout(() => {
                splashScreen.classList.add('hidden');
            }, splashDuration);

            // Wait a little longer to ensure the fade-out starts before showing content
            setTimeout(() => {
                mainContent.style.display = 'block';
                runMainFunctions();
            }, splashDuration + 20000); // 500ms delay for a smooth transition

        });

        // The function that holds all of your main website's scripts
        function runMainFunctions() {
            // Put all your existing JavaScript functions and logic here (your 4000 lines)
            console.log("Main website functions are now running!");
            // For example: initializeAnimations(); loadData(); etc.
        }
    </script>


  </body>
</html>
